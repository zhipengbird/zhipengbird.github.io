<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="../../../../lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="../../../../lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="../../../../css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="../../../../images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="../../../../images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="../../../../images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="../../../../images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="../../../../atom.xml" title="志鹏的技术博客" type="application/atom+xml" />






<meta name="description" content="Blocks概要什么是BlocksBlocks是Ｃ语言的扩充功能。有一句话来表示Blocks的扩充功能：带有自动变量（局部变量）值的匿名函数。  “匿名函数”：不带名称的函数">
<meta property="og:type" content="article">
<meta property="og:title" content="Block学习">
<meta property="og:url" content="http://yuanph.org/2016/08/28/Block学习/index.html">
<meta property="og:site_name" content="志鹏的技术博客">
<meta property="og:description" content="Blocks概要什么是BlocksBlocks是Ｃ语言的扩充功能。有一句话来表示Blocks的扩充功能：带有自动变量（局部变量）值的匿名函数。  “匿名函数”：不带名称的函数">
<meta property="og:updated_time" content="2016-08-31T07:56:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Block学习">
<meta name="twitter:description" content="Blocks概要什么是BlocksBlocks是Ｃ语言的扩充功能。有一句话来表示Blocks的扩充功能：带有自动变量（局部变量）值的匿名函数。  “匿名函数”：不带名称的函数">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yuanph.org/2016/08/28/Block学习/"/>





  <title>Block学习 | 志鹏的技术博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?hexo5154a045f583f13e4b93ee8041fa5efc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">志鹏的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录成长的点滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yuanph.org">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="志鹏">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="../../../../images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="志鹏的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Block学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-28T10:21:29+08:00">
                2016-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Blocks概要"><a href="#Blocks概要" class="headerlink" title="Blocks概要"></a>Blocks概要</h1><h2 id="什么是Blocks"><a href="#什么是Blocks" class="headerlink" title="什么是Blocks"></a>什么是Blocks</h2><p>Blocks是Ｃ语言的扩充功能。有一句话来表示Blocks的扩充功能：带有自动变量（局部变量）值的匿名函数。</p>
<blockquote>
<p>“匿名函数”：不带名称的函数</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>Ｃ语言中函数的声明与使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> count)</span></span>;<span class="comment">//声明名为func的函数</span></span><br><span class="line"><span class="keyword">int</span> res = function(<span class="number">10</span>);<span class="comment">//使用函数名称调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Ｃ中使用函数指针调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (* funptr)(<span class="keyword">int</span>) = &amp;function;<span class="comment">//定义函数指针，取得函数的地址</span></span><br><span class="line"><span class="keyword">int</span> res = (* funptr)(<span class="number">10</span>);<span class="comment">//通过函数指针调用函数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过Blocks，源代码中就能够使用匿名函数。</p>
<blockquote>
<p>对于开发人员而言，命名是工作的本质，函数名、变量名、方法名、属性名、类名和框架名等都必须具备。能够编写不带名称的函数对研发人员相当具有吸引力。</p>
</blockquote>
<ol>
<li>回顾Ｃ语言的函数中可能使用的变量<ul>
<li>自动变量（局部变量）</li>
<li>函数的参数</li>
<li>静态变量（静态局部变量）</li>
<li>静态全局变量</li>
<li>全局变量<br>其中，在函数的多次调用之间能够传递值的变量有：</li>
<li>静态全局变量</li>
<li>静态变量（静态局部变量）</li>
<li>全局变量<br>这些变量的作用域不同，但在整个程序当中，一个变量总保持在一个内存区域。因此，当多次调用函数时，该变量值总能保持不变，在任何时候以任何状态调用，使用的都是同样的变量值。</li>
</ul>
</li>
</ol>
<p>“带有自动变量值的若名函数”这一概念并不仅指Blocks，它还存在其他程序语言中。在计算机科学中，称为“闭包（Closure）”、lambda计算 等；<br>如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">程序语言</th>
<th style="text-align:left">Block名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">C+Block</td>
<td style="text-align:left">Block</td>
</tr>
<tr>
<td style="text-align:left">SmallTallk</td>
<td style="text-align:left">Block</td>
</tr>
<tr>
<td style="text-align:left">Ruby</td>
<td style="text-align:left">Block</td>
</tr>
<tr>
<td style="text-align:left">LISP</td>
<td style="text-align:left">lambda</td>
</tr>
<tr>
<td style="text-align:left">Python</td>
<td style="text-align:left">lambda</td>
</tr>
<tr>
<td style="text-align:left">C++11</td>
<td style="text-align:left">lambda</td>
</tr>
<tr>
<td style="text-align:left">javascript</td>
<td style="text-align:left">Anonymous function</td>
</tr>
</tbody>
</table>
<h1 id="Blocks模式"><a href="#Blocks模式" class="headerlink" title="Blocks模式"></a>Blocks模式</h1><h2 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h2><p>block块：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用block 定义一个加操作</span></span><br><span class="line">^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a+b);</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">// 其完整的形式是</span></span><br><span class="line">^<span class="keyword">void</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a+b);</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p>
<p>C语言函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>,a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将上面两个代码进行比较，我们发现完整的Block语法与一般的Ｃ语言函数相比，有以下同点：</p>
<ul>
<li>没有函数:Block是匿名函数</li>
<li>带有”^”: 返回值前带有“^”(插入记号).  </li>
</ul>
<ol>
<li>Block的完整语法<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">^ 返回值类型 (参数列表)</span><span class="template-variable">&#123;表达式&#125;</span><span class="xml">;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个加方法</span></span><br><span class="line"><span class="keyword">int</span>  add(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>“返回值类型”同Ｃ语言函数的返回值类型，“参数列表”同Ｃ语言的参数列表，“表达式”同Ｃ语言函数中允许使用的表达式。当然与Ｃ语言函数一样，表达式中含有return语句时，其类型必须与返回值类型相同。</p>
</blockquote>
<ol>
<li>省略返回值类型<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    ^ 返回值类型 (参数列表)&#123;表达式&#125;;</span><br><span class="line">=<span class="ruby">=&gt; ^ (参数列表)&#123;表达式&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,a+b);</span><br><span class="line">  &#125;;</span><br><span class="line">  ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>省略返回值类型，如果表达式中有return 语句就使用该返回值类型，如果表达式没有return语句，使用void类型。表达工中含有多个return语句时，所有return的返回值类型必须相同。</p>
</blockquote>
<ol>
<li><p>省略返回值类型和参数列表</p>
<blockquote>
<p>如果不使用参数，参数列表也可以省略  </p>
</blockquote>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^ 返回值类型 (参数列表)&#123;表达式&#125;;</span><br><span class="line">=<span class="ruby">=&gt; ^&#123;表达式&#125;;</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">       <span class="comment">//<span class="doctag">TODO:</span>: do something</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"hello"</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">^&#123;</span><br><span class="line">     <span class="comment">//<span class="doctag">TODO:</span>:do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"hello"</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h2><blockquote>
<p>从Block语法的表述方式上来看，除了没有名称及带有“^”以外，其他都与Ｃ语言函数定义一样。在定义Ｃ函数时，可以将所定义的函数地址赋值给函数指针类型变量中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义名为add的一个加法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> add1,<span class="keyword">int</span> add2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add2+add1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> (*funcPtr)(<span class="keyword">int</span>,<span class="keyword">int</span>)=&amp;add;<span class="comment">//定义函数指针类型变量，并将变量指向add函数的地址</span></span><br></pre></td></tr></table></figure>
<p>同样地，在Block语法下，可以将Block语法赋值给声明为Block类型的变量中。<br>声明Block类型变量示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^add)(<span class="keyword">int</span> add1,<span class="keyword">int</span> add2);</span><br></pre></td></tr></table></figure>
<p>对比函数指针的定义，会发现声明Block类型变量仅仅是将声明函数指针类型变量的“＊”变成了“^”.Block类型变量与一般Ｃ语言变量完全相同，可以作以下用途使用：</p>
<ul>
<li>自动变量</li>
<li>函数参数</li>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>使用Block语法将Block赋值为Block类型变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^add)(<span class="keyword">int</span> add1,<span class="keyword">int</span> add2)=^(<span class="keyword">int</span> add1,<span class="keyword">int</span> add2)&#123;</span><br><span class="line">       <span class="keyword">return</span> add1+add2;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p>
<p>由“^”开始的Block语法生成Block被赋值给变量add中，Block变量与一般的变量一样，所以，也可以由Block类型变量向Block类型变量赋值。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^add1)(<span class="keyword">int</span>,<span class="keyword">int</span>)= add;</span><br><span class="line"><span class="keyword">int</span> (^add2)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">add2= add1;</span><br></pre></td></tr></table></figure></p>
<p>在函数参数中可以使用Block变量向函数传递Block:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addFunc(<span class="keyword">int</span> (^add)(<span class="keyword">int</span>))&#123;</span><br><span class="line">    add(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在函数返回值中指字Block类型，可以将Block作为函数的返回值返回：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^func())(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>^(<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用typedef简化Block的声明和使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typedef 的语法规则</span></span><br><span class="line"><span class="keyword">typedef</span> &lt;<span class="meta">#returnType#&gt;(^<span class="meta-string">&lt;#name#&gt;</span>)(<span class="meta-string">&lt;#arguments#&gt;</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>通过typedef,我们将上述函数中使用的Block,和函数返回值指定Block返回类型重写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span>);<span class="comment">//定义一个block类型</span></span><br><span class="line"><span class="comment">// 在函数参数中传递block</span></span><br><span class="line"><span class="keyword">void</span> addFunc(addBlock add) &#123;</span><br><span class="line">  add(<span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回block类型返回值</span></span><br><span class="line">addBlock func()&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> number)&#123;</span><br><span class="line">        <span class="keyword">return</span> number+<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在Ｃ语言中可以使用函数指针，那么block是否也可以使用Block指针类型变量呢？<br>答案：那是肯定的 。block类型变量可以像Ｃ语言中其类型变量一亲使用。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^pointBlock)(<span class="keyword">int</span>);</span><br><span class="line">pointBlock block = ^(<span class="keyword">int</span> count)&#123;</span><br><span class="line">  <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">pointBlock * pointB= &amp;block;</span><br><span class="line">(*pointB)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h2 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><blockquote>
<p>通过前面的block语法和block类型变量的说明，我们已经知道，block是“带有自动变量值的匿名函数”，与Ｃ语言函相比中，我们对匿名函数的理解会更加深入，“带有自动变量值”在block中是怎么样的表现形式？＝＝＝&gt; “截获自动变量值”</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)() =^&#123;</span><br><span class="line">  printf(fmt,val );</span><br><span class="line">&#125;;</span><br><span class="line">val = <span class="number">1000</span>;</span><br><span class="line">fmt =<span class="string">"val value was changed .val = %d\n"</span>;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<p><strong>Block语法的表达式中使用的是在它之前声明的自动变量fmt和val.在Block中Block表达式截获所使用的局部变量的值，即何存该局部变量的瞬间值。因为Block表达式保存了局部变量的值，所以在执行Block语法后，改动block表达式中使用的局部变量的值也不会影响Block执行时局部变量的值</strong></p>
<h2 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a><code>__block</code>说明符</h2><blockquote>
<p>局部变量值截获只能保存执行Block语法瞬间的值，保存后不能改写该值</p>
</blockquote>
<p>尝试改写截获的局部变量的值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">void</span> (&amp;block)()=^ &#123;</span><br><span class="line">  val = <span class="number">10000</span>;<span class="comment">//给局部变量赋上新值</span></span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">printf(<span class="string">"val = %d\n"</span>,val );</span><br></pre></td></tr></table></figure></p>
<p>尝试编译该段代码，Xcode6会给一个大大的红色错误警告，警告内容为：<code>Variable is not assignable (missing __block type specifier)</code>  </p>
<p>若想在Block语法的表达式中将值赋值给在Block语法外声明的局部变量，需要在自动变量上附加<code>__block</code>修饰符。将上述代码进行改正后如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)()=^ &#123;</span><br><span class="line">  val = <span class="number">10000</span>;<span class="comment">//给局部变量赋上新值</span></span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br><span class="line">printf(<span class="string">"val = %d\n"</span>,val );</span><br></pre></td></tr></table></figure></p>
<p>该代码段可以正常运行。</p>
<blockquote>
<p>使用附有 <code>__block</code>修饰符的局部变量可以Block中赋值。该变量称为<code>__block</code>变量</p>
</blockquote>
<h2 id="截获的自动变量"><a href="#截获的自动变量" class="headerlink" title="截获的自动变量"></a>截获的自动变量</h2><p>在前面<strong>block修饰符一小节中，我们了解到，在没有加</strong>block修饰符，直接去修改block语法表达式中截获的自动变量的值时，会产生编译错误。那么截获OC对象会产生编译错误吗？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">void</span> (^block)()=^  &#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">  [array addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure></p>
<p>代码编译运行没有问，若向变量赋上新的值就会产生编译错误了，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">void</span> (^block)()=^  &#123;</span><br><span class="line">  array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure></p>
<p>上述代码同样会产生<code>//  Variable is not assignable (missing __block type specifier)</code>错误提示<br>解决办法就是在array前添加__block修饰符<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">void</span> (^block)()=^  &#123;</span><br><span class="line">  array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure></p>
<p>使用C语言数组时的指针的坑：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> text[]= <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)() =^  &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, text[<span class="number">2</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>使用Ｃ语言的字符串数组，而没有向截获的自动变量赋值 肯定没有什么问题？</strong><br>编译代码后得到：<code>Cannot refer to declaration with an array type inside block</code>错误提示<br>因为现在block中，截获的自动变量的方法并没有实现对Ｃ语言数组的截获。使用指针可以解决这个问题<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)() =^  &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c\n"</span>, text[<span class="number">2</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Blocks实现"><a href="#Blocks实现" class="headerlink" title="Blocks实现"></a>Blocks实现</h1><h2 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h2><blockquote>
<p>Block是带有自动变量值的匿名函数，但block究竟是什么？</p>
</blockquote>
<p>Clang(LLVM编译器)具有转换为可读源码的功能。通过“-rewrite-objc”选项能将Block语法的源码转成C++源码（struct结构体）。<br>使用方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc 源码文件名</span><br></pre></td></tr></table></figure></p>
<p>以最为简单的block代码为例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include<span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">void</span>(^block)()=^&#123;</span><br><span class="line">        printf(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将以上代码Clang成源码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0 * Desc;</span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    printf(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line"><span class="keyword">void</span>(*block)()=((<span class="keyword">void</span> ( *)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">((<span class="keyword">void</span> ( *)(__block_impl * ))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们来细读下这段代码：<br>最初的block语法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">  printf(<span class="string">"hello"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>转换后：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    printf(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由上述代码所示，Block使用的匿名函数实际上被作为简单的C语言函数来处理。另外，根据Block语法所属的函数名（这里是main）和Block语法在该函数出现的位置顺序值来给经clang变换的函数命名。</p>
<h3 id="了解clang源码中的结构体"><a href="#了解clang源码中的结构体" class="headerlink" title="了解clang源码中的结构体"></a>了解clang源码中的结构体</h3><p>  先看该Ｃ函数的参数的声明：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *__<span class="title">cself</span></span></span><br></pre></td></tr></table></figure></p>
<p>  参数<code>__cself</code>是<code>__main_block_impl_0</code>结构体指针，该结构体的声明如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> * <span class="title">Desc</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  为简单明了，此处将构造函数给去了。第一个成员变量是<code>impl</code>,是<code>__block_impl</code>的一个变量，其结构体的声明如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;<span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  第二个成员变量是<code>Desc</code>指针，是<code>__main_block_desc_0</code>结构体的一个变量，其声明如下：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;<span class="comment">//保留区域</span></span><br><span class="line">  <span class="keyword">size_t</span> Block_size;<span class="comment">//Block的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  接下来我们来看下初始化含有这些结构体的<code>__main_block_impl_0</code>结构体构造函数:<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">  impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">  impl.Flags = flags;</span><br><span class="line">  impl.FuncPtr = fp;</span><br><span class="line">  Desc = desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是初始化<code>__main_block_impl_0</code>结构体成员的源码，<code>_NSConcreteStackBlock</code>用于初始化<code>__block_impl</code>结构体的<code>isa</code>成员，在后面会对<code>_NSConcreteStackBlock</code>进行讲解。</p>
<h3 id="调用结构体构造函数"><a href="#调用结构体构造函数" class="headerlink" title="调用结构体构造函数"></a>调用结构体构造函数</h3><p>  以下是<code>__main_block_impl_0</code>结构体构造函数的调用：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(*block)()=((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure></p>
<p>  什么鬼，看不懂，分解他：<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> <span class="title">temp</span> =__<span class="title">main_block_impl_0</span>(__<span class="title">main_block_func_0</span>,&amp;__<span class="title">main_block_desc_0_DATA</span>);</span><span class="comment">//生成`__main_block_impl_0`结构体实例的变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blk</span> = &amp;<span class="title">temp</span>;</span><span class="comment">//将生成的实例变量赋值给结构体指针</span></span><br></pre></td></tr></table></figure></p>
<p>  上述代码对应的源码：<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)()=^&#123;</span><br><span class="line">       printf(<span class="string">"hello"</span>);</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将block语法生成的block赋给block类型的变量block，等同于将<code>__main_block_impl_0</code>结构体实例的指针赋给变量blk.该源码中的Block就是<code>__main_block_impl_0</code>结构体类型的自动变量blk.</p>
</blockquote>
<h3 id="深入-main-block-impl-0构造函数"><a href="#深入-main-block-impl-0构造函数" class="headerlink" title="深入__main_block_impl_0构造函数"></a>深入<code>__main_block_impl_0</code>构造函数</h3><p>  构造函数：<br>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是由Block语法转换成Ｃ语言函数指针。第二个参数是作为静态全局变量初始化的<code>__main_block_desc_0</code>结构体实例指针。<br>以下为<code>__main_block_desc_0</code>结构体实例化部分代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>   __<span class="title">main_block_desc_0_DATA</span> = &#123;</span></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(struct __main_block_impl_0)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该源码中使用Block,即__main_block_impl_0结构体实例的大小进行初始化。</p>
<h3 id="展开后的-main-block-impl-0"><a href="#展开后的-main-block-impl-0" class="headerlink" title="展开后的__main_block_impl_0"></a>展开后的<code>__main_block_impl_0</code></h3><p>我们来看下栈上的<code>__main_block_impl_0</code>结构体实例如何根据参数进行初始化。将结构体中的<code>__block_impl</code>展开，会是如下形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> * <span class="title">Desc</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该构造函数会像下面一样进行初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isa= &amp; _NSConcreteStackBlock;</span><br><span class="line">Flags= <span class="number">0</span>;</span><br><span class="line">Reserved= <span class="number">0</span>;</span><br><span class="line">FuncPtr= __main_block_func_0;</span><br><span class="line">Desc= &amp; __main_block_desc_0_DATA;</span><br></pre></td></tr></table></figure></p>
<h3 id="block的调用"><a href="#block的调用" class="headerlink" title="block的调用"></a>block的调用</h3><p>说了这么久，还没有看到block的调用，接下来我们分析下block的调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure></p>
<p>转换后的源码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> ( * )(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure></p>
<p>转换部分太多太杂，去掉他：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（*block-&gt;impl.FuncPtr）(block);</span><br></pre></td></tr></table></figure></p>
<p>这就是简单的使用函数指针调用函数。正如我们所确认的,由Block语法转换的<code>__main_block_func_0</code>函数的指针被赋值给成员变量<code>FuncPtr</code>.另外，<code>__main_block_func_0</code>的参数<code>__cself</code>指向<code>Block</code>。在调用该函数的源代码中可以看出block正是作为以数进行了传递。</p>
<h3 id="解密isa"><a href="#解密isa" class="headerlink" title="解密isa"></a>解密<code>isa</code></h3><p>在刚才我们看到这样的一句代码：<br> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa= &amp;_NSConcreteStackBlock;</span><br></pre></td></tr></table></figure></p>
<p> 将Block指针赋给Block的结构体成员变量<code>isa</code>.要理解<code>isa</code>是何方神圣，我们需要先了解下OC的类和对象的实质。Block就是OC对象。<br> 我们将一个简单person类，clang下它的源码：<br> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a ;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p> clang后的代码，我将分散的代码集中到一块了：<br> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#ifndef _REWRITER_typedef_Person</span></span><br><span class="line"><span class="meta">#define _REWRITER_typedef_Person</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Person;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;&#125; _objc_exc_Person;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa __attribute__((deprecated));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是在runtime.h文件中找到的</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>“id”类型变量主要用于存放OC对象。我们可以像使用 <code>void *</code> 那样使用id.由上述clang中的代码我们发现id的声明如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>id</code>是<code>objc_object</code>结构体的一个指针类型变量，<code>objc_object</code>其声明如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa __attribute__((deprecated));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构体中只有一个<code>isa</code>成员变量，<code>Class</code>又是什么呢？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<p><code>Class</code>是<code>objc_class</code>的指针类型变量，<code>objc_class</code>又是什么东西，在runtime.h文件中，我找到了如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是在runtime.h文件中找到的</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>与<code>objc_object</code>结构体相对比，我们发现，它们的结构体成员都是一样的。<code>objc_object</code>和<code>objc_class</code>结构体都是各个对象和类的实现中使用的最基本的结构体。</p>
<p>我们回过头来看下，刚才声明<code>Person</code>类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a ;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>clang转换后的结构体为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将结构体中使用到的<code>NSObject_IMPL</code>结构体：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>展开后，得到：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">  Class isa;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类中的a ,age实例变量被直接转换成结构体的成员。<br>“OC中由类生成的对象”意味着，像该结构体“生成由该类生成的对象的结构体实例”。生成的各个对象（生成由该类生成的对象的结构体实例）通过成员变量isa保持该类的结构体实例指针。</p>
<blockquote>
<p>各类的结构体是基于<code>objc_class</code>结构体的<code>class_t</code>结构体。<code>class_t</code>结构体在objc4运行库中的声明如下：<a href="https://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.h" target="_blank" rel="noopener">runtime</a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> class_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> class_t *isa;</span><br><span class="line">    <span class="keyword">struct</span> class_t *superclass;</span><br><span class="line">    Cache cache;</span><br><span class="line">    IMP *vtable;</span><br><span class="line">    class_rw_t *data;</span><br><span class="line">&#125; class_t;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在ＯＣ中，如NSMutableArray的class_t实例和NSObject的class_t实例，均生成并保持各个类的class_t结构体实例，该实例持有声明的成员变量，方法的名称，方法的实现（函数指针），属性及父类的指针，并被OC 运行时库使用。</p>
<p>回到__main_block_impl_0结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span>&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> * <span class="title">Desc</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该__main_block_impl_0结构体相当于基于objc_object结构体的OC类对象的结构体。对成员变量isa的初始化如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa =&amp;_NSConcreteStackBlock;</span><br></pre></td></tr></table></figure></p>
<p><code>_NSConcreteStackBlock</code>相当于class_t结构体实例。在将Block作为OC对象处理里，关于该类的信息放_NSConcreteStackBlock中。</p>
<blockquote>
<p>Block 实质就是OC对象。</p>
</blockquote>
<h2 id="截获自动变量值-1"><a href="#截获自动变量值-1" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><h2 id="block说明符-1"><a href="#block说明符-1" class="headerlink" title="__block说明符"></a><code>__block</code>说明符</h2><h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><h2 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a><code>__block</code>变量存储域</h2><h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><h2 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a><code>__block</code>变量和对象</h2><h2 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h2><h2 id="copy-release"><a href="#copy-release" class="headerlink" title="copy/release"></a>copy/release</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="../../23/iOS-synthesize和-dynamic/" rel="next" title="iOS @property、 @synthesize和@dynamic">
                <i class="fa fa-chevron-left"></i> iOS @property、 @synthesize和@dynamic
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="../../../09/01/ARC环境下内存问题/" rel="prev" title="ARC环境下内存问题">
                ARC环境下内存问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">志鹏</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="../../../../archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="../../../../atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Blocks概要"><span class="nav-number">1.</span> <span class="nav-text">Blocks概要</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Blocks"><span class="nav-number">1.1.</span> <span class="nav-text">什么是Blocks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Blocks模式"><span class="nav-number">2.</span> <span class="nav-text">Blocks模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Block语法"><span class="nav-number">2.1.</span> <span class="nav-text">Block语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block类型变量"><span class="nav-number">2.2.</span> <span class="nav-text">Block类型变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#截获自动变量值"><span class="nav-number">2.3.</span> <span class="nav-text">截获自动变量值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block说明符"><span class="nav-number">2.4.</span> <span class="nav-text">__block说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#截获的自动变量"><span class="nav-number">2.5.</span> <span class="nav-text">截获的自动变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Blocks实现"><span class="nav-number">3.</span> <span class="nav-text">Blocks实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Block的实质"><span class="nav-number">3.1.</span> <span class="nav-text">Block的实质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解clang源码中的结构体"><span class="nav-number">3.1.1.</span> <span class="nav-text">了解clang源码中的结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用结构体构造函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">调用结构体构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入-main-block-impl-0构造函数"><span class="nav-number">3.1.3.</span> <span class="nav-text">深入__main_block_impl_0构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#展开后的-main-block-impl-0"><span class="nav-number">3.1.4.</span> <span class="nav-text">展开后的__main_block_impl_0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#block的调用"><span class="nav-number">3.1.5.</span> <span class="nav-text">block的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解密isa"><span class="nav-number">3.1.6.</span> <span class="nav-text">解密isa</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#截获自动变量值-1"><span class="nav-number">3.2.</span> <span class="nav-text">截获自动变量值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block说明符-1"><span class="nav-number">3.3.</span> <span class="nav-text">__block说明符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block存储域"><span class="nav-number">3.4.</span> <span class="nav-text">Block存储域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block变量存储域"><span class="nav-number">3.5.</span> <span class="nav-text">__block变量存储域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#截获对象"><span class="nav-number">3.6.</span> <span class="nav-text">截获对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block变量和对象"><span class="nav-number">3.7.</span> <span class="nav-text">__block变量和对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block循环引用"><span class="nav-number">3.8.</span> <span class="nav-text">Block循环引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy-release"><span class="nav-number">3.9.</span> <span class="nav-text">copy/release</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">志鹏</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="../../../../lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="../../../../lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="../../../../js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="../../../../js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="../../../../js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="../../../../js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="../../../../js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="../../../../js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="../../../../js/src/bootstrap.js?v=5.1.3"></script>



  


  








  












  





  

  

  

  
  

  

  

  

</body>
</html>
