<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS中的Hit-Testing</title>
      <link href="/2019/12/01/iOS%E4%B8%AD%E7%9A%84Hit-Testing/"/>
      <url>/2019/12/01/iOS%E4%B8%AD%E7%9A%84Hit-Testing/</url>
      
        <content type="html"><![CDATA[<p>转载至<a href="http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/" target="_blank" rel="noopener">iOS中的Hit-Testing</a><br><code>Hit-Testing</code>是判定与一个点（<code>touch-point</code>）相交互的绘制在屏幕上的图像对象（<code>UIView</code>）的过程。iOS使用<code>Hit-Testing</code>来决定那个<code>UIView</code>是位于手指下面最前面的视图，该视图应该来接收触摸事件。<code>Hit-Testing</code>是通过反向的深度优先搜索算法实现的。</p><p>在解释<code>Hit-Testing</code>是如何工作之前，理解<code>Hit-Testing</code>何时执行是很重要的。下面的图片解释了一个简单的触摸事件的过程，从手指触摸到屏幕的一刻起到手指离开屏幕。<br><img src="http://smnh.me/images/hit-test-touch-event-flow.png" alt="touch-event-flow"><br>正如上图解释的一样，Hit-Testing是在每次手指触摸时执行的。并且是在任何视图或者手势收到UIEvent（代表触摸属于的事件）之前。</p><blockquote><p>注意：不知道什么原因，Hit-Testing会执行多次，但是确定的<code>hit-test</code>视图是一样的<br>在<code>Hit-Testing</code>完成和在触摸点下最前端的视图确认下来之后，<code>hit-test</code>会被关联所有触摸事件各个阶段（<code>begin</code>,<code>moved</code>,<code>ended</code>,<code>canceled</code>）的<code>UITouch</code>对象。除了<code>hit-test</code>视图，绑定到该视图的任何手势识别器和他的祖先视图都会关联到UITouch对象。然后，hit-test视图开始接收触摸事件的序列。</p></blockquote><p>一个需要注意的重要的事情是即使手指移动出了hit-test视图的边界到了另外一个视图,hit-test视图任然继续接收所有的触摸事件直到触摸事件结束。</p><blockquote><p>“触摸对象在整个生命周期内都关联他的hit-test视图，即使触摸移动到了这个视图的外面” <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4" target="_blank" rel="noopener">Event Handling Guide for iOS, iOS Developer Library</a></p></blockquote><p>正如前面提到的<code>Hit-Testing</code>采用<strong>深度优先</strong>的<strong>反序访问迭代算法</strong>（先访问根节点然后从高到低访问低节点）。这种遍历方法可以减少遍历迭代的次数，一旦找到最深的包含触摸点的后裔视图就停止遍历。这是可能的因为子视图总是渲染在父视图的前面和兄弟节点中在数组中靠后的视图渲染在靠前的视图前面。所以当多个视图包含指定的点的时候，最右边子树的最深视图就是最前面的视图。</p><blockquote><p>可见的是子视图的内容模糊了所有父视图的内容。每一个父视图存储他的子视图于一个有序的数组中，在数组中的顺序会影响子视图的显示。如果两个兄弟视图相互覆盖，后加入的视图（存储在子视图数组的后面）出现在另一个的上面。 <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24" target="_blank" rel="noopener">View Programming Guide for iOS, iOS Developer Library</a></p></blockquote><p>下图显示了一个视图层次树的例子和对应的绘制在屏幕上的UI。树的叶节点从左到右反映出子视图数组的排序。<br><img src="http://smnh.me/images/hit-test-view-hierarchy.png" alt="视图层次数"></p><p>正如看到的，“View A”和“View B”和他们的子视图，“View A.2”和“View B.1”是重叠的。由于“View B”比“View A”有一个较高的子视图索引，所以“View B”和他的子视图被渲染在“View A”和他的子视图上面。因此，“View B.1”应该被<code>hit-testing</code>返回当用户的手指触摸在”View B.1”和“View A.2”的重叠区域。</p><p>通过深度优先的反向遍历允许一旦找到第一个最深的后裔包含触摸点的视图就停止遍历：<br><img src="http://smnh.me/images/hit-test-depth-first-traversal.png" alt="视图查找"></p><p>遍历算法以向<code>UIWindow</code>（视图层次结构的根视图）发送<code>hitTest:withEvent:</code>消息开始。这个方法返回的值就是包含触摸点的最前面的视图。</p><p>下面流程图说明了hit-test逻辑。</p><p><img src="http://smnh.me/images/hit-test-flowchart.png" alt="hist-test"></p><p>下面的代码显示了原生的hitTest:withEvent:方法的可能实现方式：</p><pre><code class="objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) {        return nil;    }    if ([self pointInside:point withEvent:event]) {        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {            CGPoint convertedPoint = [subview convertPoint:point fromView:self];            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];            if (hitTestView) {                return hitTestView;            }        }        return self;    }    return nil;}</code></pre><p><code>hitTest:withEvent:</code>方法首先检查视图是否允许接收触摸事件。视图允许接收触摸事件的条件是：</p><ul><li>视图不是隐藏的: <code>self.hidden == NO</code></li><li>视图是允许交互的:<code>self.userInteractionEnabled == YES</code></li><li>视图透明度大于0.01: <code>self.alpha &gt; 0.01</code></li><li>视图包含这个点: <code>pointInside:withEvent: == YES</code></li></ul><p>然后，如果视图允许接收触摸事件，这个方法通过从后往前发送<code>hitTest:withEvent:</code>消息给每一个子视图来穿过接收者的子树，直到子视图中的一个返回<code>nil</code>。这些子视图中的第一个返回的非<code>nil</code>就是在触摸点下面的最前面的视图，被接收者返回。如果所有的子视图都返回<code>nil</code>或者接收者没有子视图返回接收者自己。</p><p>否则，如果视图不允许接收触摸事件，这个方法返回nil而根本不会传递到接收者的子树。因此，<code>hit-test</code>可能不会访问所有的视图体系结构中的视图。</p><h2 id="覆盖hitTest-withEvent-的一些用途"><a href="#覆盖hitTest-withEvent-的一些用途" class="headerlink" title="覆盖hitTest:withEvent:的一些用途"></a>覆盖<code>hitTest:withEvent:</code>的一些用途</h2><p><code>hitTest:withEvent:</code>可以被覆盖，当所有触摸事件阶段的所有阶段的触摸事件想要被一个视图处理重定向到另外一个视图。</p><blockquote><p>因为<code>hit-test</code>仅仅在触摸事件顺序的第一次触摸事件发送给他的接收者之前（有<code>UITouchPhaseBegan</code>阶段的触摸事件），覆盖<code>hitTest:withEvent:</code>来重定向事件将要重定向所有的触摸事件。</p></blockquote><h3 id="1-增加视图的触摸区域"><a href="#1-增加视图的触摸区域" class="headerlink" title="1. 增加视图的触摸区域"></a>1. 增加视图的触摸区域</h3><p>覆盖<code>hitTest:withEvent:</code>方法的一个用途就是，当一个视图的触摸区域应该大于他的边界的时候。例如下面的插图显示了一个大小为20*20的视图。这个大小对于处理附近的触摸来说太小了。因此，他的触摸区域可以通过覆盖<code>hitTest:withEvent:</code>在每个方向增加10。<br><img src="http://smnh.me/images/hit-test-increase-touch-area.png" alt="extend"></p><pre><code class="objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt;= 0.01) {        return nil;    }    CGRect touchRect = CGRectInset(self.bounds, -10, -10);    if (CGRectContainsPoint(touchRect, point)) {        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {            CGPoint convertedPoint = [subview convertPoint:point fromView:self];            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];            if (hitTestView) {                return hitTestView;            }        }        return self;    }    return nil;}</code></pre><blockquote><p>注意：为了能够正确的调用<code>hit-test</code>，父视图的边界应该包含子视图希望触摸的区域，或者他的<code>hitTest:withEvent:</code>方法也应该被覆盖来包含期望的触摸区域。</p></blockquote><h3 id="2-传递触摸事件给下面的视图"><a href="#2-传递触摸事件给下面的视图" class="headerlink" title="2. 传递触摸事件给下面的视图"></a>2. 传递触摸事件给下面的视图</h3><p>有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖hitTest:withEvent:方法来返回包含触摸点的子视图中的一个，然后其他情况返回nil，包括覆盖层包含触摸点的情况：</p><pre><code class="objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    UIView *hitTestView = [super hitTest:point withEvent:event];    if (hitTestView == self) {        hitTestView = nil;    }    return hitTestView;}</code></pre><h3 id="3-传递触摸事件给子视图"><a href="#3-传递触摸事件给子视图" class="headerlink" title="3.传递触摸事件给子视图"></a>3.传递触摸事件给子视图</h3><p>一个不同的使用场景可能需要父视图重定向所有的触摸事件给他唯一的子视图。这个行为是有必要的当子视图部分占据他的父视图，但是子视图应该响应所有的触摸事件包括发生在父视图上的。例如，假设一个由一个父视图和一个<code>pagingEnabled</code>设置为<code>YES</code>和<code>clipsToBounds</code>设置为<code>NO</code>（为了实现传动带的效果）的UIScrollView组成的图片浏览器：<br><img src="http://smnh.me/images/hit-test-pass-touches-to-subviews.png" alt="nextresponser"></p><p>为了使<code>UIScrollView</code>响应不发生在自己边界内但是在父视图的边界内的触摸事件，父视图的<code>hitTest:withEvent:</code>方法应该像下面这样重写：</p><pre><code class="objc">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    UIView *hitTestView = [super hitTest:point withEvent:event];    if (hitTestView) {        hitTestView = self.scrollView;    }    return hitTestView;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> UIKit </tag>
            
            <tag> 事件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell字符串</title>
      <link href="/2019/09/15/shell-string/"/>
      <url>/2019/09/15/shell-string/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell字符串"><a href="#Shell字符串" class="headerlink" title="Shell字符串"></a>Shell字符串</h1><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号</p><h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><pre><code class="sh">str=&#39;this is a string&#39;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</li></ul><h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><pre><code class="sh">your_name=&#39;pinghua&#39;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;</code></pre><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><pre><code class="sh">your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, ${your_name} !&quot;echo $greeting $greeting_1</code></pre><h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><pre><code class="sh">string=&quot;abcd&quot;echo ${#string} #输出 4</code></pre><h2 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h2><pre><code class="sh">string=&quot;alibaba is a great company&quot;echo ${string:1:4} #输出liba</code></pre><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><pre><code class="sh">string=&quot;alibaba is a great company&quot;echo `expr index &quot;$string&quot; is`#这个index 命令在mac上是无效的`</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell_command</title>
      <link href="/2019/09/14/shell-command/"/>
      <url>/2019/09/14/shell-command/</url>
      
        <content type="html"><![CDATA[<p>将文件内容复制到剪贴板</p><pre><code class="sh">cat xxx.txt | pbcopycat xxxxx | pbcopy</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等</title>
      <link href="/2019/09/14/shell_operator/"/>
      <url>/2019/09/14/shell_operator/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等"><a href="#Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等" class="headerlink" title="Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等"></a>Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等</h1><p>Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。</p><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><pre><code class="sh">#!/bin/bashval=`expr 2 + 2`echo &quot;Total value : $val&quot;</code></pre><blockquote><p>两点注意：</p><ul><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 <code></code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul></blockquote><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符列表<br>|运算符|    说明|    举例|<br>|—|—|—|<br>|+|    加法|    <code>expr $a + $b</code> 结果为 30。|<br>|-|    减法|    <code>expr $a - $b</code> 结果为 10。|<br>|<em>|    乘法|    `expr $a \</em> $b<code>结果为  200。||/|    除法|</code>expr $b / $a<code>结果为 2。||%|    取余|</code>expr $b % $a` 结果为 0。|<br>|=    |赋值|    a=$b 将把变量 b 的值赋给 a。|<br>|==|    相等。用于比较两个数字，相同则返回 true。|    [ $a == $b ] 返回 false。|<br>|!=|    不相等。用于比较两个数字，不相同则返回 true。|    [ $a != $b ] 返回 true。|</p><blockquote><p>注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</p></blockquote><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br>关系运算符列表<br>|运算符|    说明|    举例|<br>|—|—|—|<br>|-eq|检测两个数是否相等，相等返回 true。|    [ $a -eq $b ] 返回 true。|<br>|-ne|检测两个数是否相等，不相等返回 true。|    [ $a -ne $b ] 返回 true。|<br>|-gt|检测左边的数是否大于右边的，如果是，则返回 true。|    [ $a -gt $b ] 返回 false。|<br>|-lt|检测左边的数是否小于右边的，如果是，则返回 true。    |[ $a -lt $b ] 返回 true。|<br>|-ge|检测左边的数是否大等于右边的，如果是，则返回 true。    |[ $a -ge $b ] 返回 false。|<br>|-le|检测左边的数是否小于等于右边的，如果是，则返回 true。|    [ $a -le $b ] 返回 true。|</p><pre><code class="sh">#!/bin/basha=10b=20if [ $a -eq $b ]then     echo &quot;$a -eq $b :$a is equal to $b&quot;else    echo &quot;$a -eq $b: $a is not equal to $b&quot;fiif [ $a -ne $b ]then    echo &quot;$a -ne $b: $a is not equal to $b&quot;else    echo &quot;$a -ne $b: $a is equal to $b&quot;fiif [ $a -gt $b ]then    echo &quot;$a -gt $b: $a is greater than $b&quot;else    echo &quot;$a -gt $b: $a is not greater than $b&quot;fiif [ $a -lt $b ]then    echo &quot;$a -lt $b: $a is less than $b&quot;else    echo &quot;$a -lt $b: $a is not less than $b&quot;fiif [ $a -ge $b ]then    echo &quot;$a -ge $b: $a is greater or equal to $b&quot;else     echo &quot;$a -ge $b: $a is not greater or equal to $b&quot;fiif [ $a -le $b ]then     echo &quot;$a -le $b: $a is less or equal to $b&quot;else    echo &quot;$a -le $b: $a is not less or equal to $b&quot;fi</code></pre><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符列表<br>|运算符|    说明|    举例|<br>|—|—|—|<br>|!    |非运算，表达式为 true 则返回 false，否则返回 true。|    [ ! false ] 返回 true。|<br>|-o    |或运算，有一个表达式为 true 则返回 true。|    [ $a -lt 20 -o $b -gt 100 ] 返回 true。|<br>|-a |与运算，两个表达式都为 true 才返回 true。|    [ $a -lt 20 -a $b -gt 100 ] 返回 false。|</p><pre><code class="sh">#!/bin/basha=10b=20if [ $a != $b ]then     echo &quot;$a != $b: $a is not equal to $b&quot;else    echo &quot;$a != $b: $a is equal to $b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then    echo &quot;$a -lt 100 -a $b -gt 15: true&quot;else    echo &quot;$a -lt 100 - a $b -gt 15: false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then    echo &quot;$a -lt 100 -o $b -gt 100: true&quot;else    echo &quot;$a -lt 100 -o $b -gt 100: false&quot;fi </code></pre><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>字符串运算符列表<br>|运算符|    说明|    举例|<br>|—|—|—|<br>|=|     检测两个字符串是否相等，相等返回 true。|    [ $a = $b ] 返回 false。|<br>|!=| 检测两个字符串是否相等，不相等返回 true。|    [ $a != $b ] 返回 true。|<br>|-z| 检测字符串长度是否为0，为0返回 true。    |[ -z $a ] 返回 false。|<br>|-n    |检测字符串长度是否为0，不为0返回 true。|    [ -z $a ] 返回 true。|<br>|str|检测字符串是否为空，不为空返回 true。    |[ $a ] 返回 true。|</p><pre><code class="sh">#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then    echo &quot;$a = $b: $a is equal to $b&quot;else    echo &quot;$a = $b: $a is not equal to $b&quot;fiif [ $a != $b ]then     echo &quot;$a != $b: $a is not equal to $b&quot;else    echo &quot;$a != $b: $a is equal to $b&quot;fiif [ -z $a ]then    echo &quot;-z $a: string length is zero&quot;else    echo &quot;-z $a: string length is not zero&quot;fi if [ -n $a ]then    echo &quot;-n $a: string length is not zero&quot;else    echo &quot;-n $a: string length is zero&quot;fi if [ $a ]then     echo &quot;$a: string is not empty&quot;else    echo &quot;$a: string is empty&quot;fi </code></pre><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。<br>文件测试运算符列表<br>|操作符|    说明|    举例|<br>|—|—|—|<br>|-b file|    检测文件是否是块设备文件，如果是，则返回 true。|    [ -b $file ] 返回 false。|<br>|-c |file|    检测文件是否是字符设备文件，如果是，则返回 true。    |[ -b $file ] 返回 false。|<br>|-d| file|    检测文件是否是目录，如果是，则返回 true。|    [ -d $file ] 返回 false。|<br>|-f file|    检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    |[ -f $file ] 返回 true。|<br>|-g file    |检测文件是否设置了 SGID 位，如果是，则返回 true。    |[ -g $file ] 返回 false。|<br>|-k file|    检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|    [ -k $file ] 返回 false。|<br>|-p file    |检测文件是否是具名管道，如果是，则返回 true。|    [ -p $file ] 返回 false。|<br>|-u file    |检测文件是否设置了 SUID 位，如果是，则返回 true。    |[ -u $file ] 返回 false。|<br>|-r file    |检测文件是否可读，如果是，则返回 true。|    [ -r $file ] 返回 true。|<br>|-w file    |检测文件是否可写，如果是，则返回 true。|    [ -w $file ] 返回 true。|<br>|-x file    |检测文件是否可执行，如果是，则返回 true。    |[ -x $file ] 返回 true。|<br>|-s file    |检测文件是否为空（文件大小是否大于0），不为空返回 true。    |[ -s $file ] 返回 true。|<br>|-e file    |检测文件（包括目录）是否存在，如果是，则返回 true。|    [ -e $file ] 返回 true。|</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell替换：Shell变量替换，命令替换，转义字符</title>
      <link href="/2019/09/14/shell_var3/"/>
      <url>/2019/09/14/shell_var3/</url>
      
        <content type="html"><![CDATA[<h2 id="转义替换"><a href="#转义替换" class="headerlink" title="转义替换"></a>转义替换</h2><p>如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。</p><pre><code class="sh">a=10echo -e &quot;Value of a is $a \n&quot;</code></pre><p>这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出.<br>下面的转义字符都可以用在 echo 中：</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>反斜杠</td></tr><tr><td>\a</td><td>警报，响铃</td></tr><tr><td>\b\    退格（删除键）</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平制表符（tab键）</td></tr><tr><td>\v</td><td>垂直制表符</td></tr></tbody></table><blockquote><p>可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。</p></blockquote><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。</p><p>命令替换的语法：</p><pre><code class="sh">`command`</code></pre><p>注意是反引号，不是单引号，这个键位于 Esc 键下方。</p><h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><p>变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值</p><p>可以使用的变量替换形式：<br>|形式|    说明|<br>|—|—|<br>|${var}|    变量本来的值|<br>|${var:-word}|    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。|<br>|${var:=word}|    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。|<br>|${var:?message}|    如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br>若此替换出现在Shell脚本中，那么脚本将停止运行。|<br>|${var:+word}|    如果变量 var 被定义，那么返回 word，但不改变 var 的值。|</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数</title>
      <link href="/2019/09/14/shell_var2/"/>
      <url>/2019/09/14/shell_var2/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell特殊变量：Shell-0-和命令行参数"><a href="#Shell特殊变量：Shell-0-和命令行参数" class="headerlink" title="Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数"></a>Shell特殊变量：Shell $0, $#, $*, $@, $?, $$和命令行参数</h1><p>变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。</p><h2 id="特殊变量列表"><a href="#特殊变量列表" class="headerlink" title="特殊变量列表"></a>特殊变量列表</h2><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td></tr></tbody></table><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a>$* 和 $@ 的区别</h2><p><code>$*</code> 和 <code>$@</code> 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以<code>&quot;$1&quot;`</code> “$2”<code>…</code>“$n”` 的形式输出所有参数。</p><p>但是当它们被双引号<code>(&quot; &quot;)</code>包含时，<code>&quot;$*&quot;</code> 会将所有的参数作为一个整体，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数；<code>&quot;$@&quot;</code> 会将各个参数分开，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code>的形式输出所有参数</p><h2 id="退出状态"><a href="#退出状态" class="headerlink" title="退出状态"></a>退出状态</h2><p><code>$?</code> 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p><p>退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。<br><code>$?</code> 也可以表示函数的返回值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell变量：Shell变量的定义、删除变量、只读变量、变量类型</title>
      <link href="/2019/09/13/shell_var/"/>
      <url>/2019/09/13/shell_var/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell变量：Shell变量的定义、删除变量、只读变量、变量类型"><a href="#Shell变量：Shell变量的定义、删除变量、只读变量、变量类型" class="headerlink" title="Shell变量：Shell变量的定义、删除变量、只读变量、变量类型"></a>Shell变量：Shell变量的定义、删除变量、只读变量、变量类型</h1><p>变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell 变量也遵循这个规则。</p><p>在 Bash shell 中，每一个变量的值都是<code>字符串</code>，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p><p>这意味着，Bash shell 在默认情况下<code>不会区分变量类型</code>，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。</p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Shell 支持以下三种定义变量的方式：</p><pre><code class="shell">variable=valuevariable=&#39;value&#39;variable=&quot;value&quot;</code></pre><p><code>variable</code> 是变量名，<code>value</code> 是赋给变量的值。如果 <code>value</code> 不包含任何空白符（例如空格、Tab缩进等），那么可以不使用引号；如果 <code>value</code> 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的.</p><blockquote><p>注意，赋值号的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。</p></blockquote><p>Shell 变量的命名规范和大部分编程语言都一样：</p><ul><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号$即可，如：</p><pre><code class="sh">author=&quot;pinghua&quot;echo $authorecho ${author}</code></pre><p>变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界.</p><blockquote><p>推荐给所有变量加上花括号{ }，这是个良好的编程习惯.</p></blockquote><h2 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h2><p>已定义的变量，可以被重新赋值，如：</p><pre><code class="sh">author=pinghuaechor ${author}author=yuanecho ${author}</code></pre><p><strong>第二次对变量赋值时不能在变量名前加<code>$</code>，只有在使用变量时才能加<code>$</code>.</strong></p><h2 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h2><blockquote><p>定义变量时，变量的值可以由单引号’ ‘包围，也可以由双引号” “包围，它们到底有什么区别呢？</p></blockquote><pre><code class="sh">url=&quot;http://www.baidu.com&quot;website1=&#39;百度1:${url}&#39;website2=&quot;百度2:${url}&quot;echo $website1echo $website2</code></pre><p>运行结果：</p><pre><code class="sh">百度1:${url}百度2:http://www.baidu.com</code></pre><ul><li>以单引号<code>&#39;&#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使用里面有变量或命令，也会把它们原样输出。这种方式比较适合输出纯字符串的情况，即不希望解析变量或命令</li><li>以双引号<code>&quot;&quot;</code>包含围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号里的内容原样输出。这种方式比较适合字符串中包含变量或命令，并且希望将其解析后再输出的变量定义<blockquote><p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景</p></blockquote></li></ul><h2 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h2><p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p><pre><code class="sh">variable=`command`variable=$(command)</code></pre><ul><li>第一种方式把命令用<code></code>反引号包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；</li><li>第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</li></ul><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 命令可以删除变量。语法：</p><pre><code class="sh">unset variable_name</code></pre><p>变量被删除后不能再次使用；<code>unset</code> 命令不能删除只读变量</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>运行shell时，会同时存在三种变量：<br>1) 局部变量<br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<br>2) 环境变量<br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。<br>3) shell变量<br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本学习笔记</title>
      <link href="/2019/09/13/shell_basic/"/>
      <url>/2019/09/13/shell_basic/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是shell"><a href="#什么是shell" class="headerlink" title="什么是shell"></a>什么是shell</h1><p>Shell 是一种脚本语言<br>任何代码最终都要被“翻译”成二进制的形式才能在计算机中执行。</p><p>有的编程语言，如 C/C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。</p><p>这个过程叫做<code>编译（Compile）</code>，这样的编程语言叫做<code>编译型语言</code>，完成编译过程的软件叫做<code>编译器（Compiler）</code>。</p><p>而有的编程语言，如 Shell、JavaScript、Python、PHP等，需要一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。</p><p>这个过程叫做<code>解释</code>，这样的编程语言叫做<code>解释型语言</code>或者<code>脚本语言（Script</code>），完成解释过程的软件叫做<code>解释器</code>。</p><p>编译型语言的优点是<code>执行速度快</code>、<code>对硬件要求低</code>、<code>保密性好</code>，适合开发操作系统、大型应用程序、数据库等。</p><p>脚本语言的优点是使用<code>灵活</code>、<code>部署容易</code>、<code>跨平台性好</code>，<code>非常适合Web开发以及小工具的制作</code>。</p><p>Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。</p><h1 id="shell-提示符"><a href="#shell-提示符" class="headerlink" title="shell 提示符"></a>shell 提示符</h1><p>对于普通用户，Base shell 默认的提示符是美元符号<code>$</code>；对于超级用户（root 用户），Bash Shell 默认的提示符是井号<code>#</code>。该符号表示 Shell 等待输入命令</p><p><code>echo</code> 是一个输出命令，可以用来输出数字、变量、字符串等；本例中，我们使用 <code>echo</code> 来输出字符串。<br>字符串是一组由” “包围起来的字符序列，<code>echo</code> 将第一个”作为字符串的开端，将第二个”作为字符串的结尾。此处的字符串就可以看做 <code>echo</code> 命令的附加信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表达式求值</title>
      <link href="/2019/09/13/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2019/09/13/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><p>任何一个表达式都由操作数（operand）、运算符(operator)和界限符（delimiter）组成。其中操作数可以是常数，也可以是被说明为变量或常量的标识符。运算符可以分为算述运算符、关系运算符、逻辑运算符三类。基本界限符有左右括弧和表达式结束符。为叙述方便简洁，在此仅限讨论只含二元运算的算述表达式。可以将这种表达式定为义：</p><pre><code>* 表达式 ::= 操作数 运算符 操作数* 操作数 ::= 简单变量 | 表达式* 简单变量 ::= 标识符 | 无符号整数</code></pre><p>在计算机中，表达式可以有三种不同的标识方法<br>假设 Exp(表达式) = <u>S1(第一操作数)</u> OP(运算符)<u>S2(第二操作数)</u><br>则称：<br>    OP S1 S2 为表达式的前缀表示方法<br>    S1 OP S2 为表达式的中缀表示方法<br>    S1 S2 OP 为表达式的后缀表示方法</p><blockquote><p>例： 已知表达式 Exp = <u>a <em> b</em></u> + <u>(c - d/ e) f</u>则：<br>    前缀表达式为： + <u> <em>ab</em></u> <u> -c/def</u><br>    中缀表达式为： <u>a <em>b</em></u> +<u>c - d/e f</u><br>    后缀表达式为： <u>ab<em></em></u> <u>cde/-f</u>+</p></blockquote><p>在不同的表示方法中，操作数之间的相对顺序不变，但运算符之间的相对次序是不同。其中，中缀表达式丢失了原表达式的括弧信息致运算的次序不确定没有用外，前缀和后缀表达式中都包含了确定的运算顺序。<br>它们的运算规则如下：</p><ul><li>前缀表达式：连续出现的两个操作数和在它们之前且紧靠它们的运算符构成最小表达式</li><li>后缀表达式：每个运算符和在它之前出现且紧靠它的两个操作数构成一个最小表达式，且运算符在后缀表达式中出现的顺序恰为表达式的运算顺序。</li></ul><h2 id="后缀表达式求值算法"><a href="#后缀表达式求值算法" class="headerlink" title="后缀表达式求值算法"></a>后缀表达式求值算法</h2><p>因此从后缀表达式很容易求得表达式的值，只要“从左至右”顺序扫描后缀表达式，在扫描过程中，凡遇到运算符即做运算，与它对应的操作数应该是在它之前“刚刚”扫描的两个操作数。</p><p>为识别“刚刚”扫描过的操作数，自然需要一个栈，以实现操作数“后出现先运算”的规则。因此后缀表达式的求值算法如下：<br><em>算法中以字符串表示算述表过式，表达式尾添加#字符作为结束标识。为简单起见，限定操作数以单个字符作为变量名。从左至右依次识别字符串中的字符，若“字母”则“入栈”，否则从栈中退出第二操作数和第一操作数并作相应运算，operator(S1,OP,S2)返回S1和S2进行OP运算的结果。opMember(char ch)为自定义的，返回bool值的函数，若ch为运算符则返回true,否则返回false</em></p><pre><code class="c++">#include &lt;stack&gt;double operate(double S1,char op ,double S2){    double value = 0;    switch (op) {        case &#39;+&#39;:            value = S1 + S2;            break;        case &#39;-&#39;:            value = S1 - S2;            break;        case &#39;*&#39;:            value =  S1 * S2;            break;        case &#39;/&#39;:            value =  S1 / S2;            break;    }    return value;}bool OpMember(char ch){    if (ch == &#39;+&#39; || ch == &#39;-&#39; || ch == &#39;*&#39; || ch ==&#39;/&#39; || ch == &#39;(&#39; || ch == &#39;)&#39; || ch == &#39;#&#39;) {        return true;    }    return false;}double evaluation(char suffix[]){    using namespace std;    ///取表达式中第一个字符    char ch  = *suffix++;    ///初始空栈    stack&lt;double&gt; suffixStack;    while (ch != &#39;#&#39;) {        if (!OpMember(ch)) {            ///非操作符则入栈            suffixStack.push(ch);        }else{            ///退出两栈顶操作数            double b = suffixStack.top();            suffixStack.pop();            double a  = suffixStack.top();            suffixStack.pop();            ///作相应的运算            double rs = operate(a, ch , b);            ///操作结果入栈            suffixStack.push(rs);        }        ch = *suffix++;///继续取下一个字符    }    if (!suffixStack.empty()) {        double rs  = suffixStack.top();        suffixStack.pop();        return rs;    }    return 0;}</code></pre><h2 id="原表达式转后缀表达式"><a href="#原表达式转后缀表达式" class="headerlink" title="原表达式转后缀表达式"></a>原表达式转后缀表达式</h2><blockquote><p>如何从原表达式求得后缀表达式呢？</p></blockquote><p>分析“原表达式”和“后缀表达式”中相应的运算符所在的不同位置可见，原表达式中的运算符在后缀表达式中出现的位置取决于它本身和后一个运算符的优先关系。按照运算符的运算规则：</p><ol><li>先乘除、后加减速</li><li>从左算到右</li><li>先括弧内、后括弧外</li></ol><table><thead><tr><th>运算符</th><th>#</th><th>(</th><th>+</th><th>-</th><th>)</th><th>*</th><th>/</th><th>^乘幂</th></tr></thead><tbody><tr><td>优先数</td><td>-1</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td></tr></tbody></table><p>若当前运算符的优先级小于在它后面的运算符，则暂不送往后缀表达式，否则它在后缀表达式中领先于在它后面的运算符。换句话说。在后缀表达式中，优先级高的运算符领先于优先级低的运算符。因此从原表达式求得后缀表达式的规则为：</p><ul><li>设立运算符栈</li><li>设表达式的结束符为“#”，预设运算符栈的栈底为“#”</li><li>若当前字符中操作数，则直接发后缀表达式</li><li>若当前字符为运算符且优先级大于栈顶运算符，则进栈；否则退出栈顶运算符发送给后缀表达式</li><li>若当前是结束符，则自栈顶至栈底依次将栈中所有运算符发送给后缀表达式</li><li>“(”对它之前后的运算符起隔离作用，若当前运算符为“(”时进栈</li><li>“)”可视为自相应左括弧开始的表达式的结束符，则栈顶起依次退出栈顶运算符发送给后缀表达式，直至栈顶运算符为“(”为止</li></ul><pre><code class="c++">bool precedOperator(char op1, char op2){    using namespace std;    map&lt;char, int&gt; operatormap;    operatormap.insert(pair&lt;char, int&gt;(&#39;#&#39;,-1));    operatormap.insert(pair&lt;char, int&gt;(&#39;(&#39;,0));    operatormap.insert(pair&lt;char, int&gt;(&#39;+&#39;,1));    operatormap.insert(pair&lt;char, int&gt;(&#39;-&#39;,1));    operatormap.insert(pair&lt;char, int&gt;(&#39;)&#39;,2));    operatormap.insert(pair&lt;char, int&gt;(&#39;*&#39;,2));    operatormap.insert(pair&lt;char, int&gt;(&#39;/&#39;,2));    operatormap.insert(pair&lt;char, int&gt;(&#39;^&#39;,3));    map&lt;char, int&gt;::iterator iter;    iter =  operatormap.find(op1);    int op1value = iter-&gt;second ;    iter =  operatormap.find(op2);    int op2Value =iter-&gt;second;    if (op1value &gt;= op2Value) {        return true;    }    return false;}</code></pre><pre><code class="c++">void transformExp(char suffix[], char exp[]){    ///从合法的表达木式字符串exp求得其相应的后缀表达式字符串suffix    using namespace std;    stack&lt;char&gt; suffixStack;    stack&lt;char&gt; operatorStack;    char *p  = exp;    char ch = *p;    operatorStack.push(&#39;#&#39;);///预设运算符栈底元素为#    while (!operatorStack.empty()) {        if (!OpMember(ch)) {            suffixStack.push(ch);///操作数直接发给后缀表达式栈        }else{            switch (ch) {                case &#39;(&#39;:                    operatorStack.push(ch);///左括弧进栈                    break;                case &#39;)&#39;:{                    char op = operatorStack.top();                    while (op != &#39;(&#39;) {///自栈顶大至左括弧之前的运算符发送给后缀栈                        suffixStack.push(op);                        operatorStack.pop();                        op = operatorStack.top();                    }                    if (op  == &#39;(&#39;) {                        operatorStack.pop();                    }                }                    break;                default:                    char op  = operatorStack.top();                    bool value =  precedOperator(op, ch);                    while (op &amp;&amp; value) {                        suffixStack.push(op);                        operatorStack.pop();                        if (!operatorStack.empty()) {                            op = operatorStack.top();                            value =  precedOperator(op, ch);                        }else{                            value = false;                        }                    }                    //将栈中所有优先级不小于当前运算符优先级的运算符发给后缀表达式                    if (ch != &#39;#&#39;) {                        operatorStack.push(ch);//优先级大于栈顶元素的运算符入栈                    }                    break;            }        }        ch = *++p;///下一个字符处理        if (ch == &#39;#&#39;) {            break;        }    }    while (!operatorStack.empty()) {//将运算符栈的剩余操作符发给后缀表达式        suffixStack.push(operatorStack.top());        operatorStack.pop();    }    stack&lt;char&gt; op;       while (!suffixStack.empty()) {        ///将表达式栈逆转过来        op.push(suffixStack.top());        std::cout&lt;&lt;suffixStack.top()&lt;&lt;&quot; &quot;;        suffixStack.pop();    }    std::cout &lt;&lt;endl;    char *rs  = suffix;    while (!op.empty()) {        *rs++ = op.top();        std::cout&lt;&lt;op.top()&lt;&lt;&quot; &quot;;        op.pop();    }    std::cout &lt;&lt;endl;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runtime消息转发基础</title>
      <link href="/2019/09/09/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/09/09/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Runtime-的定义"><a href="#Runtime-的定义" class="headerlink" title="Runtime 的定义"></a>Runtime 的定义</h1><blockquote><p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work</p></blockquote><h1 id="runtime的常见应用场景"><a href="#runtime的常见应用场景" class="headerlink" title="runtime的常见应用场景"></a>runtime的常见应用场景</h1><ul><li>面向切面编程AOP</li><li>方法调配method swizzing (默魔法)</li><li>消息转发</li><li>给分类添加关联属性（关联对象）</li><li>动态获取class和selector,属性</li><li>KVC/KVO，修改私有属性的值</li></ul><p>在很多文章中都能看到 IMP、SEL、selector 以及 Method 等关键字，相信大家随着对 RunTime 的逐步了解，慢慢会逐渐熟悉它们的。</p><blockquote><p>思考题： runtime 如何通过 selector 找到对应的 IMP 地址?</p></blockquote><p>接下来分别说一下 IMP、SEL、selector 以及 Method.</p><h2 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h2><p>IMP保存的是method的地址，本质是一个函数指针，由编译器生成。</p><pre><code class="objc">/// A pointer to the function of a method implementation.#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ );#elsetypedef id (*IMP)(id, SEL, ...);#endif</code></pre><p>向对象发送消息后，是由这个函数指针IMP执行的，即IMP函数指针指向了方法的实现。</p><p>IMP函数指针最少包含了id和SEL类型的两个参数，后面其他的参数是对应方法需要的参数。其中id代表执行该方法的target（对象），SEL代表对应的方法，通过id和SEL参数就能确定唯一的方法实现地址。</p><h3 id="如何获取方法的IMP"><a href="#如何获取方法的IMP" class="headerlink" title="如何获取方法的IMP"></a>如何获取方法的IMP</h3><p>NSObject提供了如下两方法：</p><pre><code class="objc">- (IMP)methodForSelector:(SEL)aSelector;+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code></pre><p>对应的实现源码：</p><pre><code class="objc">+ (IMP)instanceMethodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return class_getMethodImplementation(self, sel);}+ (IMP)methodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return object_getMethodImplementation((id)self, sel);}- (IMP)methodForSelector:(SEL)sel {    if (!sel) [self doesNotRecognizeSelector:sel];    return object_getMethodImplementation(self, sel);}</code></pre><p>上述实现中<code>methodForSelector</code>即有实例方法和类方法，而<code>instanceMethodForSelector</code>只有类方法<br>在使用<code>methodForSelector</code>方法时，向类发送消息，则<code>SEL</code>应该是类方法，若向实例对象发消息，则<code>SEL</code>应该为实例对象方法。<code>instanceMethodForSelector</code>仅仅允许类发送该消息，从而获取实例方法的IMP,该方法无法获取类方法的<code>IMP</code>,如果想获取类方法的<code>IMP</code>可以使用<code>methodForSelector</code>来获取。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>在源码<code>runtime.h</code>中定义method,其本质是一个结构体</p><pre><code class="objc">struct objc_method {    SEL method_name     OBJC2_UNAVAILABLE;///函数名    char *method_types  OBJC2_UNAVAILABLE;///方法类型    IMP method_imp      OBJC2_UNAVAILABLE;///函数指针}</code></pre><ul><li>方法名<code>method_name</code>类型为<code>SEL</code>;</li><li>方法类型<code>method_types</code>是一个char指针，存储着方法的参数类型和返回值类型；</li><li>方法实现<code>method_imp</code>的类型为<code>IMP</code>;</li></ul><h3 id="获取method的方法"><a href="#获取method的方法" class="headerlink" title="获取method的方法"></a>获取method的方法</h3><p><code>runtime.h</code> 中有两个方法，可以根据 <code>SEL</code>直接获取实例方法和类方法的 <code>Method</code>，如下:</p><pre><code class="objc">Method class_getInstanceMethod(Class cls, SEL name);///获取实例方法Method class_getClassMethod(Class cls, SEL name);///获取类方法</code></pre><h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><p>selector称之为方法选择器，SEL是selector的表示类型，也是方法编号，是类成员方法的指针。</p><pre><code class="objc">typedef struct objc_selector *SEL;</code></pre><h3 id="获取SEL有方法"><a href="#获取SEL有方法" class="headerlink" title="获取SEL有方法"></a>获取SEL有方法</h3><pre><code class="objc">SEL sel = @selector(play:);SEL sel = sel_registerName(&quot;play:&quot;); SEL sel = NSSelectorFromString(@&quot;play&quot;);</code></pre><p>SEL表示一个selector的指针，无论什么类里，只要方法名相同，SEL就相同，SEL实际是根据方法名hash化了的字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，所以速度上非常快，SEL的存在加快了查询方法的速度</p><blockquote><p>Q：为什么在同一个OC类中，不能存在同名的函数，即使用参数类型不同也不行？（OC为什么没有重载）<br>A：SEL表示一个selector的指针，无论在什么类型里，只要方法名相同，SEL就相同，相同的函数名，编译器无法编译通过。</p></blockquote><p><code>dispatch table</code> 存放<code>SEL</code>和<code>IMP</code>的对应关系，<code>SEL</code>最终会通过<code>dispatch table</code>寻找到对应的<code>IMP</code>.</p><p><strong>Selector,Method,IMP三者的关系</strong><br>在类的（实例和类方法）调度表(dispatch table)中每一个实体代表一个方法的Method，其名叫选择器SEL，并对应着一种方法实现称之为IMP，有了Method就可以使用SEL找到对应的IMP,SEL就是为了查找方法的最终实现IMP</p><h2 id="class-addMethod"><a href="#class-addMethod" class="headerlink" title="class_addMethod"></a>class_addMethod</h2><pre><code class="objc">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types){    if (!cls) return NO;    rwlock_writer_t lock(runtimeLock);    return ! addMethod(cls, name, imp, types ?: &quot;&quot;, NO);}</code></pre><blockquote><p>Adds a new method to a class with a given name and implementation.<br>class_addMethod will add an override of a superclass’s implementation,<br>but will not replace an existing implementation in this class.<br>To change an existing implementation, use method_setImplementation.</p></blockquote><p>方法参数解析：</p><ul><li>返回值: 返回 YES 表示方法添加成功, 否则添加失败</li><li>参数 Class cls: 将要给添加方法的类, 即［类名 class］</li><li>参数 SEL name: 将要添加的方法 SEL, 即 @selector(方法名)，如果已经存在，该方法返回失败，不存在就添加成功。</li><li>参数 IMP imp：实现这个方法的函数. 有两种写法即 C 和 OC 的写法. 一个 IMP 最少包括两个参数, 上面已经说过。</li><li>参数 const char *types: 实现方法的函数的返回和参数编码类型. 如 “v@:” 表示返回值为 void, 没有参数的一个函数, 其中 @和:分别代表 IMP 的默认两个参数即 id 和 sel.</li></ul><blockquote><p><strong>思考题解答</strong><br><code>runtime 如何通过 selector 找到对应的 IMP 地址?</code><br>A:类对象中有类方法和实例方法的分发表，表中记录着方法的名字、参数和实现，selector本质就是方法名，runtime通过这个方法名称可以在分发表中找到方法的对应实现。<br>系统为我们提供了获取IMP指针的函数，无论是类方法和实例方法都可以获取对应的IMP。而Method将selector和IMP联系起来，IMP是函数指针，由编译器编译生成，当发一个消息时，它会找到那段代码执行，IMP指向了这个方法的具体实现，得到这个函数的指针就可以运行了。<br>IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址，反之为亦然。当发送消息给一个对象时，runtime会在对象的类对象方法列表里找，当我们发送一个消息给一个类时，这条消息会在类的metaClass对象的方法列表里查找，直到在NSObject为止。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String and Characters</title>
      <link href="/2019/09/09/SwiftStringAndCharacters/"/>
      <url>/2019/09/09/SwiftStringAndCharacters/</url>
      
        <content type="html"><![CDATA[<p>A string is a series of characters, such as “hello, world” or “albatross”. Swift strings are represented by the String type. The contents of a String can be accessed in various ways, including as a collection of Character values.</p><h2 id="String-Literals"><a href="#String-Literals" class="headerlink" title="String Literals"></a>String Literals</h2><p>You can include predefined String values within your code as string literals. A string literal is a sequence of characters surrounded by double quotation marks (“).<br>Use a string literal as an initial value for a constant or variable:</p><pre><code class="swift">let someString = &quot;Some string literal value&quot;</code></pre><h2 id="Multiline-String-Literals"><a href="#Multiline-String-Literals" class="headerlink" title="Multiline String Literals"></a>Multiline String Literals</h2><p>If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:</p><pre><code class="swift">let quotation = &quot;&quot;&quot;The White Rabbit put on his spectacles.  &quot;Where shall I begin,please your Majesty?&quot; he asked.&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go ontill you come to the end; then stop.&quot;&quot;&quot;&quot;</code></pre><p>A multiline string literal includes all of the lines between its opening and closing quotation marks. The string begins on the first line after the opening quotation marks (“””) and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:</p><pre><code class="swift">let singleLineString = &quot;These are the same.&quot;let multilineString = &quot;&quot;&quot;These are the same.&quot;&quot;&quot;</code></pre><h2 id="Special-Characters-in-String-Literals"><a href="#Special-Characters-in-String-Literals" class="headerlink" title="Special Characters in String Literals"></a>Special Characters in String Literals</h2><p>String literals can include the following special characters:</p><ul><li>The escaped special characters \0 (null character), \ (backslash), \t (horizontal tab), \n (line feed), \r (carriage return), \” (double quotation mark) and \’ (single quotation mark)</li><li>An arbitrary Unicode scalar value, written as \u{n}, where n is a 1–8 digit hexadecimal number (Unicode is discussed in Unicode below)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2019/09/08/Stack/"/>
      <url>/2019/09/08/Stack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>栈和队列是在程序设计中被广泛使用的的两种线性数据结构，它们的特点在于基本操作的特殊性，栈必须按“后进先出”的规则进行操作，而队列必须按“先进先出”的规则进行操作。和线性表相比，它们的插入和删除操作受更多的约束和限制，故又称限定性的线性表结构</p></blockquote><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>“洗干净的盘子总是逐个往上叠在已洗好的盘子上面，而用的时候从上往下逐个取用，即后洗好的盘子比先洗好的盘子先被使用”，栈的操作特点正是上述的实际抽象。</p><p>栈(stack)是限定只能在表的一端进行插入和删除操作的线性表。在表中允许插入删除的一端称为“栈顶（top）”，不允许插入删除的另一端称为“栈底（bottom）”。 如下图所示的栈中，a1是栈底元素，an是栈顶元素。栈中元素以a1,a2,a3,…,an的顺序进栈，则出栈的第一个元素是an,即栈的修改是按后进先出的原则进行的。因此栈又称LIFIO（last in first out）表。</p><h2 id="栈的表示和操作实现"><a href="#栈的表示和操作实现" class="headerlink" title="栈的表示和操作实现"></a>栈的表示和操作实现</h2><p>和线性表类似，栈也有两种存储表示方式：顺序栈和链栈</p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><p>顺序栈指的是利用顺序存储分配实现的栈。即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。类似于顺序表，用一维数组描述顺序栈中数据元素的存储区域，并预设一个数组的最大空间。通常做法以<em>top=0</em>表示“空栈”</p><pre><code class="C++">typedef struct YStack {    int *elem;    int top;    int size;}YStack;void initStack(YStack &amp;stack, int maxSize = 20){    //构造一个空栈stack,初始分配的最大空间为maxSize    //1.为顺序栈分配一个最大容量为maxSize的数组空间    stack.elem = new int[maxSize];    stack.top = -1;//当前顺序栈中所含的元素个数为0    stack.size = maxSize;///该顺序栈最多可容纳maxSize个元素}bool popElement(YStack &amp;stack, int &amp;elem){    //若栈不为空，则用elem返回stack的栈顶元素，并返回true,否则返回false    if (stack.top == -1) {        return false;    }    elem = stack.elem[stack.top];    return true;}void push(YStack &amp;stack, int elem){    //插入元素elem为新的栈顶元素    if (stack.top &lt; stack.size){        stack.elem[++stack.top] = elem;    }else{        //TODO::当前元素个数已达最大值，需要进行扩容        printf(&quot;当前元素个数已达最大值，需要进行扩容&quot;);    }}bool pop(YStack &amp;stack, int &amp;elem){    //若栈不之为空，则返回stack的栈顶元素，用elem返回其值，并返回true    if (stack.top == -1) {        return false;    }    elem = stack.elem[stack.top--];    return true;}</code></pre><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><p>链栈指的是利用链式分配实现的栈。链栈的结点结构和链表的结点的结构相同，值得注意的是，<strong>链栈中指针的方向是从栈顶指向栈底。</strong></p><pre><code class="c++">typedef struct YStackNode{    int data;    struct YStackNode *next;}YStackNode,*YStackLink;void initStackLink( YStackLink  &amp;stack){    //构造一个空的栈链，即设栈顶指针为空    stack = NULL;}void push(YStackLink &amp;stack, int elem){//    在链栈的顶插入新的栈元素elem    YStackLink node  = new YStackNode;//为新的栈顶元素分配结点    node-&gt;data = elem;    node -&gt;next = stack;///插入新的栈顶元素    stack = node;///修得栈顶指针}bool pop(YStackLink  &amp;stack ,int &amp;elem){    //若栈不为空，删除栈顶元素，以elem返回其值，并返回true，否则返回false    if (stack) {        YStackLink p = stack;        stack = stack -&gt; next;        elem = p -&gt; data;        delete p;        return true;    }    return false;}</code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>数据结构“队列”与生活中的“排队”极为相似，也是按“先到先办”的原则办事，并且严格限定：<em>即不允许“加塞儿”，也不允许“中途离队”</em><br>队列（queue）是限定只能在表的一端进行插入，在表的另一端进行删除的线性表。表中允许插入的一端称为“队尾(rear)”，允许删除的一端称为“队头(font)”,如下图所示队列中，a1队头元素，an队尾元素，队列中的元素以a1,a2,a3,…,an的次序依次入队，则也只能依相同的次序退出队列。即a1是第一个出队的元素，只有在a2,a3,….,an-1都离开队后，an才能出队列。队列的修改是依“先进先出”的原则进行的，因此队列又称FIFO（first in first out ）表。</p><h2 id="队列的表示和操作实现"><a href="#队列的表示和操作实现" class="headerlink" title="队列的表示和操作实现"></a>队列的表示和操作实现</h2><p>和线性表类似，队列的存储方式有：链队列和循环队列</p><h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>用链表表示的队列简称为<em>链队列</em>。由队列的结构特性容易想到，一个链队列显示然需要两个分别指向队头和队尾的指针（分别称为头指针和尾指针）。为操作方便，为链队列添加一个“头结点”，并约定头指针始终指向这个附加的头结点，尾指针指向真正的队尾元素结点。一个“空”的链队列只包含一个头结点，并且队列的头指针和尾指针都指向这个头结点。</p><pre><code class="c++">typedef int ValueType;typedef struct QueueNodel {    ValueType data;    struct QueueNodel *next;///&lt;下一个指针}QueueNodel , *LinkQueueList,*QueurPtr;///&lt;链式队列typedef struct LinkQueue {    QueurPtr front;///&lt;队头指针    QueurPtr rear;///&lt;队尾指针}LinkQueue;void initLinkQueue(LinkQueue &amp;queue){    queue.front = queue.rear = new QueueNodel;    queue.front-&gt;next = nullptr;}void destroyLinkQueue(LinkQueue &amp; queue){    while (queue.front) {        queue.rear =queue.front-&gt;next;        delete queue.front;        queue.front = queue.rear;    }}void enLinkQueue(LinkQueue &amp;queue, ValueType value){    LinkQueueList node = new QueueNodel;    node-&gt;data = value;    node-&gt;next = nullptr;    queue.rear-&gt;next = node;    queue.rear = node;}bool deLinkQueue(LinkQueue &amp;queue, ValueType &amp;value){    if (queue.front == queue.rear) {        return false;    }    LinkQueueList node  = queue.front-&gt;next;    value = node-&gt;data;    queue.front-&gt;next = node-&gt;next;    if (queue.rear== node) {        queue.rear = queue.front;    }    delete node;    return true;}</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>和顺序栈相类似，在利用顺序分配存储结构实现队列时，除了用一维数组描述队列中数据元素的存储区域，并预设一个数组的最大空间之外，尚需要设置两个指针front和rear分别指向队头和队尾。<br>为叙述方便，约定：初始化建空队列时，令front= rear = 0;每当插入一个新元素后，队尾指针rear增加1，每当删除一个队头元素时，front增加1。因此在非空队列中，头指针指向队头元素，尾指针指向队尾元素的下一个位置。<br>为防止数组越界，一个较巧妙的方法是将顺序队列想像成一个首尾相接的环状空间。对于循环队列，不能以头、尾指针是否相同来判断队列的“满”或“空”。<br>可以有两种处理方式：</p><ol><li>附设一个标志位以区别队列空间“满”“空”</li><li>少用一个元素空间，约定”队尾指针在队头指针的前一个位置（指环状队列中的前一位置）”为队满。<br>循环队列中头、尾指针“依环状增1”的操作可用“模”来实现。通过取模，头指针和尾指针就可以在顺序空间内按头尾衔接的方式“循环”移动。<br><code>`</code>c++<br>const int  QUEUE_INIT_SIZE = 100;///循环队列默认初始分配最大空间<br>const int  QUEUEINCREMENT = 10;///增补空间</li></ol><p>typedef int QueueValueType;<br>typedef  struct YCircleQueue {<br>    QueueValueType *values;///存言储队列元素的数组<br>    int front;//头指针，若队列不为空，指向队头元素<br>    int rear;//尾指针，若队列不为空，指向队尾元素的下一个位置<br>    int queuesize;//队列当前的最大容量<br>    int incrementsize;//约定扩容增加<br>}YCircleQueue;</p><p>void initCircleQueue(YCircleQueue &amp;queue, int maxsize ,int incrementsize){<br>    ///构建一个空队列，<br>    ///为队列分配（比实际能用多一个元素的）空间<br>    queue.values = new QueueValueType[maxsize + 1];<br>    queue.queuesize = maxsize;<br>    queue.incrementsize = incrementsize;<br>    queue.front = queue.rear = 0;<br>}</p><p>int circlequeuelength(YCircleQueue &amp;queue){<br>    ///返回队列中的元素即队列当前长度<br>    return (queue.rear - queue.front + queue.queuesize ) %queue.queuesize;<br>}</p><p>bool deCircleQueue(YCircleQueue &amp;queue, QueueValueType &amp;value){<br>    ///若队列不为空，则删除队头元素，用value返回其值，并返回true<br>    if (queue.front == queue.rear) {<br>        return false;<br>    }<br>    value = queue.values[queue.front];<br>    queue.front = (queue.front +1)%queue.queuesize;<br>    return true;<br>}<br>void enCircleQueue(YCircleQueue &amp;queue, QueueValueType value){<br>    //队满了，扩容<br>    if ((queue.rear + 1 )%queue.queuesize == queue.front ) {<br>        incrementCircleQueueSize(queue);<br>    }<br>    //插入新元素value为新的队尾元素<br>    queue.values[queue.rear] = value;<br>    queue.rear = (queue.rear +1) %queue.queuesize;<br>}<br>void incrementCircleQueueSize(YCircleQueue &amp;queue){<br>    //为队列扩容<br>    QueueValueType *a  = new QueueValueType[queue.queuesize + queue.incrementsize];<br>    for (int k  = 0; k &lt; queue.queuesize-1; k++) {<br>        //挪原队列元素<br>        a[k] = queue.values[(queue.front +k)%queue.queuesize];<br>    }<br>    delete queue.values; ///释放原有数组空间<br>    queue.values = a;///为队列设置新的数组<br>    queue.front = 0;//重置头指针<br>    queue.rear = queue.queuesize - 1;//重置尾指针<br>    queue.queuesize += queue.incrementsize;<br>}<br><code>`</code></p><p>扩容操作比一次性申请空间要费时间，一般大多数的问题常常可以根据问题的性质/规模估计队列的大小，而在无法预先估计队列可能达到的容量时，最好还是采用链队列。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwiftBasicOperators</title>
      <link href="/2019/08/30/SwiftBasicOperators/"/>
      <url>/2019/08/30/SwiftBasicOperators/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-Operators"><a href="#Basic-Operators" class="headerlink" title="Basic Operators"></a>Basic Operators</h1><p>An operator is a special symbol or phrase that you use to check, change, or combine values.<br>Swift supports most standard C operators and improves several capabilities to eliminate common coding errors.</p><ul><li>The assignment operator (=) doesn’t return a value, to prevent it from being mistakenly used when the equal to operator (==) is intended.</li><li>Arithmetic operators (+, -, *, /, % and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them. </li></ul><p>Swift also provides range operators that aren’t found in C, such as <code>a..&lt;b</code> and <code>a...b</code>, as a shortcut for expressing a range of values.</p><h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><p>Operators are unary, binary, or ternary:</p><ul><li>Unary operators operate on a single target (such as -a). Unary prefix operators appear immediately before their target (such as !b), and unary postfix operators appear immediately after their target (such as c!</li><li>Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets</li><li>Ternary operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator <code>(a ? b : c)</code>.</li></ul><h2 id="Assignment-Operator"><a href="#Assignment-Operator" class="headerlink" title="Assignment Operator"></a>Assignment Operator</h2><p>The assignment operator (a = b) initializes or updates the value of a with the value of b:</p><pre><code class="swift">let b = 10var a = 5a = b// a is now equal to 10</code></pre><p>If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:</p><pre><code class="swift">let (x, y) = (1, 2)// x is equal to 1, and y is equal to 2</code></pre><p>Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value. The following statement is not valid:</p><pre><code class="swift">if x = y {    // This is not valid, because x = y does not return a value.}</code></pre><h2 id="Arithmetic-Operators"><a href="#Arithmetic-Operators" class="headerlink" title="Arithmetic Operators"></a>Arithmetic Operators</h2><p>Swift supports the four standard arithmetic operators for all number types:</p><ul><li>Addition (+)</li><li>Subtraction (-)</li><li>Multiplication (*)</li><li>Division (/)</li></ul><blockquote><p>Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default.<br>The addition operator is also supported for String concatenation:</p><pre><code class="swift">&quot;hello, &quot; + &quot;world&quot;  // equals &quot;hello, world&quot;</code></pre></blockquote><h3 id="Remainder-Operator"><a href="#Remainder-Operator" class="headerlink" title="Remainder Operator"></a>Remainder Operator</h3><p>The remainder operator (a % b) works out how many multiples of b will fit inside a and returns the value that is left over (known as the remainder)</p><blockquote><p>The remainder operator (%) is also known as a modulo operator in other languages. However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation.</p></blockquote><pre><code class="swift">a = (b x some multiplier) + remainder9 = (4 x 2) + 1</code></pre><blockquote><p>The sign of b is ignored for negative values of b. This means that a % b and a % -b always give the same answer.</p></blockquote><h3 id="Unary-Minus-Operator"><a href="#Unary-Minus-Operator" class="headerlink" title="Unary Minus Operator"></a>Unary Minus Operator</h3><p>The sign of a numeric value can be toggled using a prefixed -, known as the unary minus operator:</p><pre><code class="swift">let three = 3let minusThree = -three       // minusThree equals -3let plusThree = -minusThree   // plusThree equals 3, or &quot;minus minus three&quot;</code></pre><h3 id="Unary-Plus-Operator"><a href="#Unary-Plus-Operator" class="headerlink" title="Unary Plus Operator"></a>Unary Plus Operator</h3><p>The unary plus operator (+) simply returns the value it operates on, without any change:</p><pre><code class="swift">let minusSix = -6let alsoMinusSix = +minusSix  // alsoMinusSix equals -6</code></pre><h2 id="Compound-Assignment-Operators"><a href="#Compound-Assignment-Operators" class="headerlink" title="Compound Assignment Operators"></a>Compound Assignment Operators</h2><p>Like C, Swift provides compound assignment operators that combine assignment (=) with another operation.</p><blockquote><p>The compound assignment operators don’t return a value. For example, you can’t write let b = a += 2.</p></blockquote><h2 id="Comparison-Operators"><a href="#Comparison-Operators" class="headerlink" title="Comparison Operators"></a>Comparison Operators</h2><p>Swift supports all standard C comparison operators:</p><ul><li>Equal to (<code>a == b</code>)</li><li>Not Equal to (<code>a != b</code>)</li><li>Greater than (<code>a &gt; b</code>)</li><li>Less than (<code>a &lt; b</code>)</li><li>Greater than or equal to (<code>a &gt;= b</code>)</li><li>Less than or equal to (<code>a &lt;= b</code>)</li><li>two identity operators (<code>===</code> and <code>!==</code>)<blockquote><p>Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance</p></blockquote></li></ul><p>Each of the comparison operators returns a Bool value to indicate whether or not the statement is true.<br>Comparison operators are often used in conditional statements, such as the if statement.<br>You can compare two tuples if they have the same type and the same number of values. Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal.</p><blockquote><p>Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples. For example, as demonstrated in the code below, you can compare two tuples of type (String, Int) because both String and Int values can be compared using the &lt; operator. In contrast, two tuples of type (String, Bool) can’t be compared with the &lt; operator because the &lt; operator can’t be applied to Bool values.</p></blockquote><blockquote><p>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.</p></blockquote><h2 id="Ternary-Conditional-Operator"><a href="#Ternary-Conditional-Operator" class="headerlink" title="Ternary Conditional Operator"></a>Ternary Conditional Operator</h2><p>The ternary conditional operator is a special operator with three parts, which takes the form <code>question ? answer1 : answer2.</code> It’s a shortcut for evaluating one of two expressions based on whether <code>question</code>is true or false. If <code>question</code> is true, it evaluates <code>answer1</code> and returns its value; otherwise, it evaluates <code>answer2</code> and returns its value.</p><p>The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement</p><h2 id="Nil-Coalescing-Operator"><a href="#Nil-Coalescing-Operator" class="headerlink" title="Nil-Coalescing Operator"></a>Nil-Coalescing Operator</h2><p>The nil-coalescing operator (<code>a ?? b</code>) unwraps an optional <code>a</code> if it contains <code>a</code> value, or returns <code>a</code> default value <code>b</code> if <code>a</code> is nil. The expression <code>a</code> is always of an optional type. The expression <code>b</code> must match the type that is stored inside<code>a</code>.</p><p>The nil-coalescing operator is shorthand for the code below:</p><pre><code class="swift">a != nil ? a! : b</code></pre><h2 id="Range-Operators"><a href="#Range-Operators" class="headerlink" title="Range Operators"></a>Range Operators</h2><p>Swift includes several range operators, which are shortcuts for expressing a range of values.</p><h3 id="Closed-Range-Operator"><a href="#Closed-Range-Operator" class="headerlink" title="Closed Range Operator"></a>Closed Range Operator</h3><p>The closed range operator (a…b) defines a range that runs from a to b, and includes the values a and b. The value of a must not be greater than b.<br>The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a for-in loop:</p><pre><code class="swift">for index in 1...5 {    print(&quot;\(index) times 5 is \(index * 5)&quot;)}</code></pre><h3 id="Half-Open-Range-Operator"><a href="#Half-Open-Range-Operator" class="headerlink" title="Half-Open Range Operator"></a>Half-Open Range Operator</h3><p>The half-open range operator (<code>a..&lt;b</code>) defines a range that runs from a to b, but doesn’t include b. It’s said to be half-open because it contains its first value, but not its final value. As with the closed range operator, the value of a must not be greater than b. If the value of a is equal to b, then the resulting range will be empty。</p><pre><code class="swift">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]let count = names.countfor i in 0..&lt;count {    print(&quot;Person \(i + 1) is called \(names[i])&quot;)}</code></pre><h3 id="One-Sided-Ranges"><a href="#One-Sided-Ranges" class="headerlink" title="One-Sided Ranges"></a>One-Sided Ranges</h3><p>The closed range operator has an alternative form for ranges that continue as far as possible in one direction-—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a one-sided range because the operator has a value on only one side.</p><pre><code class="swift">for name in names[2...] {    print(name)}// Brian// Jackfor name in names[...2] {    print(name)}</code></pre><p>he half-open range operator also has a one-sided form that’s written with only its final value. </p><pre><code class="swift">for name in names[..&lt;2] {    print(name)}</code></pre><p>One-sided ranges can be used in other contexts, not just in subscripts. You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin. You can iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop. You can also check whether a one-sided range contains a particular value</p><pre><code class="swift">let range = ...5range.contains(7)   // falserange.contains(4)   // truerange.contains(-1)  // true</code></pre><h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><p>Logical operators modify or combine the Boolean logic values true and false. Swift supports the three standard logical operators found in C-based languages:</p><ul><li>Logical Not (<code>!a</code>)</li><li>Logical AND (<code>a || b</code>)</li><li>Logical OR (<code>a ||b</code>)</li></ul><h3 id="Logical-NOT-Operator"><a href="#Logical-NOT-Operator" class="headerlink" title="Logical NOT Operator"></a>Logical NOT Operator</h3><p>The logical NOT operator (!a) inverts a Boolean value so that true becomes false, and false becomes true.<br>The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. It can be read as “not a”, as seen in the following example:</p><pre><code class="swift">let allowedEntry = falseif !allowedEntry {    print(&quot;ACCESS DENIED&quot;)}</code></pre><h3 id="Logical-AND-Operator"><a href="#Logical-AND-Operator" class="headerlink" title="Logical AND Operator"></a>Logical AND Operator</h3><p>The logical AND operator (a &amp;&amp; b) creates logical expressions where both values must be true for the overall expression to also be true.<br>If either value is false, the overall expression will also be false. In fact, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true. This is known as short-circuit evaluation.</p><h3 id="Logical-OR-Operator"><a href="#Logical-OR-Operator" class="headerlink" title="Logical OR Operator"></a>Logical OR Operator</h3><p>The logical OR operator (a || b) is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only one of the two values has to be true for the overall expression to be true.</p>]]></content>
      
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变字典中setValue:forKey和setObject:forKey的区别</title>
      <link href="/2019/08/28/setValueAndObject/"/>
      <url>/2019/08/28/setValueAndObject/</url>
      
        <content type="html"><![CDATA[<h1 id="可变字典中setValue-forKey和setObject-forKey的区别"><a href="#可变字典中setValue-forKey和setObject-forKey的区别" class="headerlink" title="可变字典中setValue:forKey和setObject:forKey的区别"></a>可变字典中setValue:forKey和setObject:forKey的区别</h1><p>在开发过程中，使用字典的频率也是非常高的，也经常会遇到一个类似<br><code>-[__NSPlaceholderDictionary initWithObjects:forKeys:count:]: attempt to insert nil object from objects[1]</code><br>crash,那发生这种crash的真实原因又是什么呢？在开发过程中我们调用<code>setValue:forKey</code>和<code>setObject:forKey</code>频率也是非常多，但大多数情况，后者居多。我们先来看下这两个函数有定义</p><pre><code class="objc">@interface NSMutableDictionary&lt;KeyType, ObjectType&gt;(NSKeyValueCoding)/* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:*/- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;@end</code></pre><p>该方法内部分调用在<code>-setObject:forKey:</code>方法去给字典赋值，在<code>value</code>为空的情况下会调用<code>-removeObjectForKey:</code>移除已有key的值。这样在一定程度上避免了给字典赋空值crash的情况发生</p><pre><code class="objc">@interface NSMutableDictionary&lt;KeyType, ObjectType&gt; : NSDictionary&lt;KeyType, ObjectType&gt;- (void)removeObjectForKey:(KeyType)aKey;- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;@end</code></pre><p>在API上我们发现没有注释，但在文档中其代码注释非常详细：<br><code>- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</code></p><ul><li><code>anObject</code><br>The value for aKey. A strong reference to the object is maintained by the dictionary.</li></ul><blockquote><p>Important<br>Raises an NSInvalidArgumentException if anObject is nil. If you need to represent a nil value in the dictionary, use NSNull.<br>当anobject为空时会抛出NSInvalidArgumentException异常，如果需要保存一个空值，可以使用NSNull实例</p></blockquote><ul><li><code>aKey</code></li></ul><p>The key for value. The key is copied (<strong><em>using copyWithZone:; keys must conform to the NSCopying protocol</em></strong>). If aKey already exists in the dictionary, anObject takes its place.</p><blockquote><p>Important<br>Raises an NSInvalidArgumentException if aKey is nil.</p></blockquote><p>从上述API定义和文档注释中我们可以得出以下区别：</p><ul><li><code>setObject:forKey:</code>中<code>object</code>不能为空，若为空则会抛出异常，若要展示一个空值，需要使用NSNull实例代替</li><li><code>setValue:forKey:</code>中<code>value</code>可以为空，若<code>value</code>为空，内部会调用<code>removeObjectForKey：</code>方法，移除该key所对应的值<br><code>setValue:forKey:</code>可以认为是对<code>setObject:forKey:</code>再次封装，对异常情况做了处理。</li></ul><blockquote><p>我们开发过程中遇到的字典的crash，多数是因为在调用<code>setObject:forKey:</code>时，传入的object为空导致的！在使用过程要尽可以有object做判空处理，若不想这么做，可以使用<code>setValue:forKey:</code>方法替代</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIStackView</title>
      <link href="/2019/08/27/UIStackView/"/>
      <url>/2019/08/27/UIStackView/</url>
      
        <content type="html"><![CDATA[<p><a href="https://nshipster.com/uistackview/" target="_blank" rel="noopener">UIStackView</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Attributes</title>
      <link href="/2019/08/23/SwiftAttributes/"/>
      <url>/2019/08/23/SwiftAttributes/</url>
      
        <content type="html"><![CDATA[<h1 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h1><p>There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types. An attribute provides additional information about the declaration or type.</p><p>You specify an attribute by writing the @ symbol followed by the attribute’s name and any arguments that the attribute accepts:</p><pre><code class="swift">@attribute name@attribute name(attribute arguments)</code></pre><p>Some declaration attributes accept arguments that specify more information about the attribute and how it applies to a particular declaration. These attribute arguments are enclosed in parentheses, and their format is defined by the attribute they belong to.</p><h2 id="Declaration-Attributes"><a href="#Declaration-Attributes" class="headerlink" title="Declaration Attributes"></a>Declaration Attributes</h2><p>You can apply a declaration attribute to declarations only.</p><h3 id="available"><a href="#available" class="headerlink" title="available"></a>available</h3><p>Apply this attribute to indicate a declaration’s life cycle relative to certain Swift language versions or certain platforms and operating system versions.<br>The available attribute always appears with a list of two or more comma-separated attribute arguments. These arguments begin with one of the following platform or language names:</p><ul><li>iOS</li><li>iOSApplicationExtension</li><li>macOS</li><li>macOSApplicationExtension</li><li>watchOS</li><li>watchOSApplicationExtension</li><li>tvOS</li><li>tvOSApplicationExtension</li><li>swift</li></ul><p>The remaining arguments can appear in any order and specify additional information about the declaration’s life cycle, including important milestones</p><ul><li>The <code>unavailable</code> argument indicates that the declaration isn’t available on the specified platform. This argument can’t be used when specifying Swift version availability.</li><li>The <code>introduced</code> argument indicates the first version of the specified platform or language in which the declaration was introduced. It has the following form:</li></ul><pre><code class="swift">introduced: `version number`</code></pre><p>The version number consists of one to three positive integers, separated by periods.</p><ul><li><p>The <code>deprecated</code> argument indicates the first version of the specified platform or language in which the declaration was deprecated. It has the following form:</p><pre><code class="swift">deprecated: version number</code></pre></li><li><p>The <code>obsoleted</code> argument indicates the first version of the specified platform or language in which the declaration was obsoleted. When a declaration is obsoleted, it’s removed from the specified platform or language and can no longer be used. It has the following form:</p><pre><code class="swift">obsoleted: version number</code></pre></li><li><p>The <code>message</code> argument provides a textual message that the compiler displays when emitting a warning or error about the use of a deprecated or obsoleted declaration. It has the following form:<br><code>message: message</code><br>The message consists of a string literal.</p></li><li><p>The renamed argument provides a textual message that indicates the new name for a declaration that’s been renamed. The compiler displays the new name when emitting an error about the use of a renamed declaration. It has the following form:<br><code>renamed: new name</code><br>The new name consists of a string literal.</p></li></ul><h3 id="discardableResult"><a href="#discardableResult" class="headerlink" title="discardableResult"></a>discardableResult</h3><p>Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result.</p><h3 id="dynamicCallable"><a href="#dynamicCallable" class="headerlink" title="dynamicCallable"></a>dynamicCallable</h3><p>Apply this attribute to a class, structure, enumeration, or protocol to treat instances of the type as callable functions. The type must implement either a dynamicallyCall(withArguments:) method, a dynamicallyCall(withKeywordArguments:) method, or both.</p><h3 id="dynamicMemberLookup"><a href="#dynamicMemberLookup" class="headerlink" title="dynamicMemberLookup"></a>dynamicMemberLookup</h3><p>Apply this attribute to a class, structure, enumeration, or protocol to enable members to be looked up by name at runtime. The type must implement a <code>subscript(dynamicMemberLookup:)</code>subscript.</p><h3 id="GKInspectable"><a href="#GKInspectable" class="headerlink" title="GKInspectable"></a>GKInspectable</h3><p>Apply this attribute to expose a custom GameplayKit component property to the SpriteKit editor UI. Applying this attribute also implies the objc attribute.</p><h3 id="inlinable"><a href="#inlinable" class="headerlink" title="inlinable"></a>inlinable</h3><p>Apply this attribute to a function, method, computed property, subscript, convenience initializer, or deinitializer declaration to expose that declaration’s implementation as part of the module’s public interface. The compiler is allowed to replace calls to an inlinable symbol with a copy of the symbol’s implementation at the call site.</p><p>Inlinable code can interact with public symbols declared in any module, and it can interact with internal symbols declared in the same module that are marked with the usableFromInline attribute. Inlinable code can’t interact with private or fileprivate symbols.</p><h3 id="nonobjc"><a href="#nonobjc" class="headerlink" title="nonobjc"></a>nonobjc</h3><p>Apply this attribute to a method, property, subscript, or initializer declaration to suppress an implicit <code>objc</code> attribute. The <code>nonobjc</code> attribute tells the compiler to make the declaration unavailable in Objective-C code, even though it’s possible to represent it in Objective-C.</p><p>Applying this attribute to an extension has the same effect as applying it to every member of that extension that isn’t explicitly marked with the <code>objc</code> attribute.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Methods</title>
      <link href="/2019/08/23/SwiftMethods/"/>
      <url>/2019/08/23/SwiftMethods/</url>
      
        <content type="html"><![CDATA[<h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><p>Methods are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.</p><h2 id="Instance-Methods"><a href="#Instance-Methods" class="headerlink" title="Instance Methods"></a>Instance Methods</h2><p>Instance methods are functions that belong to instances of a particular class, structure, or enumeration. They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose. Instance methods have exactly the same syntax as functions, as described in Functions.<br>You call instance methods with the same dot syntax as properties.<br>Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function), as described in Function Argument Labels and Parameter Names. The same is true for method parameters, because methods are just functions that are associated with a type.</p><h2 id="The-self-Property"><a href="#The-self-Property" class="headerlink" title="The self Property"></a>The self Property</h2><p>Every instance of a type has an implicit property called self, which is exactly equivalent to the instance itself. You use the self property to refer to the current instance within its own instance methods.</p><blockquote><p>The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the self property to distinguish between the parameter name and the property name.</p></blockquote><h2 id="Modifying-Value-Types-from-Within-Instance-Methods"><a href="#Modifying-Value-Types-from-Within-Instance-Methods" class="headerlink" title="Modifying Value Types from Within Instance Methods"></a>Modifying Value Types from Within Instance Methods</h2><p>Structures and enumerations are value types. By default, the properties of a value type cannot be modified from within its instance methods.</p><p>However, if you need to modify the properties of your structure or enumeration within a particular method, you can opt in to <strong>mutating</strong> behavior for that method.</p><ul><li>The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends</li><li>The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends.</li></ul><blockquote><p>You can opt in to this behavior by placing the <strong>mutating</strong> keyword before the <strong>func</strong> keyword for that method</p></blockquote><pre><code class="swift">struct Point {    var x = 0.0, y = 0.0    mutating func moveBy(x deltaX: Double, y deltaY: Double) {        x += deltaX        y += deltaY    }}</code></pre><blockquote><p>Note that you <strong>cannot call a mutating method on a constant of structure type</strong>, <em>because its properties cannot be changed, even if they are variable properties</em>.</p></blockquote><h2 id="Assigning-to-self-Within-a-Mutating-Method"><a href="#Assigning-to-self-Within-a-Mutating-Method" class="headerlink" title="Assigning to self Within a Mutating Method"></a>Assigning to self Within a Mutating Method</h2><p>Mutating methods can assign an entirely new instance to the implicit self property.</p><pre><code class="swift">struct Point {    var x = 0.0, y = 0.0    mutating func moveBy(x deltaX: Double, y deltaY: Double) {        self = Point(x: x + deltaX, y: y + deltaY)    }}</code></pre><p>Mutating methods for enumerations can set the implicit self parameter to be a different case from the same enumeration:</p><pre><code class="swift">enum TriStateSwitch {    case off, low, high    mutating func next() {        switch self {        case .off:            self = .low        case .low:            self = .high        case .high:            self = .off        }    }}</code></pre><p>#Type Methods</p><p>Instance methods, as described above, are methods that you call on an instance of a particular type. You can also define methods that are called on the type itself. These kinds of methods are called <code>type methods</code>. You indicate type methods by writing the <code>static</code>keyword before the method’s <code>func</code> keyword. Classes can use the<code>class</code>keyword instead, to allow subclasses to override the superclass’s implementation of that method</p><blockquote><p>In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports.</p></blockquote><p>Type methods are called with dot syntax, like instance methods. However, you call type methods on the type, not on an instance of that type.</p><pre><code class="swift">class SomeClass {    class func someTypeMethod() {        // type method implementation goes here    }}SomeClass.someTypeMethod()</code></pre><p>Within the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type. This means that you can use self to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters</p><p>More generally, any unqualified method and property names that you use within the body of a type method will refer to other type-level methods and properties. A type method can call another type method with the other method’s name, without needing to prefix it with the type name. Similarly, type methods on structures and enumerations can access type properties by using the type property’s name without a type name prefix.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置tableview Section的圆角样式</title>
      <link href="/2019/08/21/SectionCorner/"/>
      <url>/2019/08/21/SectionCorner/</url>
      
        <content type="html"><![CDATA[<p>参考文档：<br><a href="https://www.meiwen.com.cn/subject/icruittx.html" target="_blank" rel="noopener">设置不同section中cell的圆角</a><br><a href="https://blog.csdn.net/wwww11519/article/details/81480863" target="_blank" rel="noopener">UITableView对每一组（section）设置圆角</a><br><a href="http://www.hangge.com/blog/cache/detail_2195.html" target="_blank" rel="noopener">Swift - 实现tableView中section分组圆角效果2（含有分区头、尾的情况</a></p><p><a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/CreatingCustomLayouts/CreatingCustomLayouts.html#//apple_ref/doc/uid/TP40012334-CH5-SW1" target="_blank" rel="noopener">自定义collectionLayout</a><br><a href="https://www.jianshu.com/p/b718c284ca7d" target="_blank" rel="noopener">横向排版的CollectionView</a></p><p><a href="https://blog.csdn.net/u011361385/article/details/80680170" target="_blank" rel="noopener">iOS之流布局UICollectionView全系列教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> TableView Section </tag>
            
            <tag> O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Properties</title>
      <link href="/2019/08/20/SwiftProperties/"/>
      <url>/2019/08/20/SwiftProperties/</url>
      
        <content type="html"><![CDATA[<p>Properties associate values with a particular class, structure, or enumeration.Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures</p><h2 id="Stored-Properties"><a href="#Stored-Properties" class="headerlink" title="Stored Properties"></a>Stored Properties</h2><p>a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword)</p><h3 id="Stored-Properties-of-Constant-Structure-Instances"><a href="#Stored-Properties-of-Constant-Structure-Instances" class="headerlink" title="Stored Properties of Constant Structure Instances"></a>Stored Properties of Constant Structure Instances</h3><p>If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties.</p><p>This behavior is due to structures being value types. When an instance of a value type is marked as a constant, so are all of its properties.</p><p>The same is not true for classes, which are reference types. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.</p><h3 id="Lazy-Stored-Properties"><a href="#Lazy-Stored-Properties" class="headerlink" title="Lazy Stored Properties"></a>Lazy Stored Properties</h3><p>A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the <code>lazy</code> modifier before its declaration.</p><blockquote><p>You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy.</p></blockquote><p>Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.</p><blockquote><p>If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there is no guarantee that the property will be initialized only once.</p></blockquote><h3 id="Stored-Properties-and-Instance-Variables"><a href="#Stored-Properties-and-Instance-Variables" class="headerlink" title="Stored Properties and Instance Variables"></a>Stored Properties and Instance Variables</h3><p>You may know that it provides two ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.</p><p>Swift unifies these concepts into a single property declaration. A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly.This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.</p><h2 id="Computed-Properties"><a href="#Computed-Properties" class="headerlink" title="Computed Properties"></a>Computed Properties</h2><p>In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p><h3 id="Shorthand-Setter-Declaration"><a href="#Shorthand-Setter-Declaration" class="headerlink" title="Shorthand Setter Declaration"></a>Shorthand Setter Declaration</h3><p>If a computed property’s setter doesn’t define a name for the new value to be set, a default name of <code>newValue</code> is used</p><h3 id="Shorthand-Getter-Declaration"><a href="#Shorthand-Getter-Declaration" class="headerlink" title="Shorthand Getter Declaration"></a>Shorthand Getter Declaration</h3><p>If the entire body of a getter is a single expression, the getter implicitly returns that expression. Omitting the return from a getter follows the same rules as omitting return from a function.</p><h3 id="Read-Only-Computed-Properties"><a href="#Read-Only-Computed-Properties" class="headerlink" title="Read-Only Computed Properties"></a>Read-Only Computed Properties</h3><p>A computed property with a getter but no setter is known as a read-only computed property. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.</p><blockquote><p><strong>You must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value is not fixed.</strong>  The let keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.</p></blockquote><h2 id="Property-Observers"><a href="#Property-Observers" class="headerlink" title="Property Observers"></a>Property Observers</h2><p>Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p><p>You can add property observers to any stored properties you define, <strong>except for lazy stored properties</strong>. You can also add property observers to any inherited property (whether stored or computed) by overriding the property within a subclass. You don’t need to define property observers for nonoverridden computed properties, because you can observe and respond to changes to their value in the computed property’s setter.</p><p>You have the option to define either or both of these observers on a property:</p><ul><li>willSet is called just before the value is stored.</li><li>didSet is called immediately after the new value is stored.</li></ul><blockquote><p>The willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.<br>If you pass a property that has observers to a function as an in-out parameter, the willSet and didSet observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function</p></blockquote><h2 id="Global-and-Local-Variables"><a href="#Global-and-Local-Variables" class="headerlink" title="Global and Local Variables"></a>Global and Local Variables</h2><p>Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comparing Structures and Classes</title>
      <link href="/2019/08/19/SwiftDefineClassesandStructs/"/>
      <url>/2019/08/19/SwiftDefineClassesandStructs/</url>
      
        <content type="html"><![CDATA[<h2 id="Comparing-Structures-and-Classes"><a href="#Comparing-Structures-and-Classes" class="headerlink" title="Comparing Structures and Classes"></a>Comparing Structures and Classes</h2><p>Structures and classes in Swift have many things in common. Both can:</p><ul><li>Define properties to store values</li><li>Define methods to provide functionality</li><li>Define subscripts to provide access to their values using subscript syntax</li><li>Define initializers to set up their initial state</li><li>Be extended to expand their functionality beyond a default implementation</li><li>Conform to protocols to provide standard functionality of a certain kind<br>For more information, see Properties, Methods, Subscripts, Initialization, Extensions, and Protocols.</li></ul><p>Classes have additional capabilities that structures don’t have:</p><ul><li>Inheritance enables one class to inherit the characteristics of another.</li><li>Type casting enables you to check and interpret the type of a class instance at runtime.</li><li>Deinitializers enable an instance of a class to free up any resources it has assigned.</li><li>Reference counting allows more than one reference to a class instance.<br>For more information, see Inheritance, Type Casting, Deinitialization, and Automatic Reference Counting.</li></ul><h2 id="Definition-Syntax"><a href="#Definition-Syntax" class="headerlink" title="Definition Syntax"></a>Definition Syntax</h2><p>Structures and classes have a similar definition syntax. You introduce structures with the struct keyword and classes with the class keyword. Both place their entire definition within a pair of braces:</p><pre><code class="swift">struct SomeStructure {    // structure definition goes here}class SomeClass {    // class definition goes here}</code></pre><blockquote><p>Whenever you define a new structure or class, you define a new Swift type.</p><ul><li>Give types <em>UpperCamelCase</em> names (such as SomeStructure and SomeClass here) to match the capitalization of standard Swift types (such as String, Int, and Bool).</li><li>Give properties and methods <em>lowerCamelCase</em> names (such as frameRate and incrementCount) to differentiate them from type names.</li></ul></blockquote><h2 id="Accessing-Properties"><a href="#Accessing-Properties" class="headerlink" title="Accessing Properties"></a>Accessing Properties</h2><p>You can access the properties of an instance using dot syntax. In dot syntax, you write the property name immediately after the instance name, separated by a period (.), without any spaces:</p><pre><code class="swift">print(&quot;The width of someResolution is \(someResolution.width)&quot;)</code></pre><h2 id="Memberwise-Initializers-for-Structure-Types"><a href="#Memberwise-Initializers-for-Structure-Types" class="headerlink" title="Memberwise Initializers for Structure Types"></a>Memberwise Initializers for Structure Types</h2><p>All structures have an automatically generated memberwise initializer, which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:</p><pre><code class="swift">let vga = Resolution(width: 640, height: 480)</code></pre><blockquote><p>Unlike structures, class instances don’t receive a default memberwise initializer.</p></blockquote><h2 id="Structures-and-Enumerations-Are-Value-Types"><a href="#Structures-and-Enumerations-Are-Value-Types" class="headerlink" title="Structures and Enumerations Are Value Types"></a>Structures and Enumerations Are Value Types</h2><p>A value type is a type whose value is copied when it’s assigned to a variable or constant, or when it’s passed to a function.<br><strong><em>In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</em></strong></p><p>All structures and enumerations are value types in Swift. <em>This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</em></p><blockquote><p>Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying. Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies. If one of the copies of the collection is modified, the elements are copied just before the modification. The behavior you see in your code is always as if a copy took place immediately.</p></blockquote><h2 id="Classes-Are-Reference-Types"><a href="#Classes-Are-Reference-Types" class="headerlink" title="Classes Are Reference Types"></a>Classes Are Reference Types</h2><p>Unlike value types, reference types are not copied when they are assigned to a variable or constant, or when they are passed to a function. Rather than a copy, a reference to the same existing instance is used.</p><h2 id="Identity-Operators"><a href="#Identity-Operators" class="headerlink" title="Identity Operators"></a>Identity Operators</h2><p>Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same isn’t true for structures and enumerations, because they are always copied when they are assigned to a constant or variable, or passed to a function.)</p><p>It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:</p><ul><li>Identical to (===)</li><li>Not identical to (!==)</li></ul><blockquote><p>Note that identical to (represented by three equals signs, or ===) doesn’t mean the same thing as equal to (represented by two equals signs, or ==). </p><ul><li>Identical to means that two constants or variables of class type refer to exactly the same class instance.</li><li>Equal to means that two instances are considered equal or equivalent in value, for some appropriate meaning of equal, as defined by the type’s designer.</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿语镜像处理</title>
      <link href="/2019/08/16/%E9%98%BF%E8%AF%AD%E9%95%9C%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2019/08/16/%E9%98%BF%E8%AF%AD%E9%95%9C%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ol><li><p>左右的相互调换，使用系统提供的镜像功能。</p><ul><li><p>针对全部的UIView 使用镜像功能<br><code>[UIView appearance].semanticContentAttribute ==UISemanticContentAttributeForceRightToLeft;</code></p></li><li><p>针对具体部分View使用<br><code>self.view.semanticContentAttribute = UISemanticContentAttributeForceRightToLeft;</code></p></li></ul></li></ol><p>以上方式只有在使用mas 或者系统的约束前提之下生效 。</p><p>附：之前使用mas 约束没有想过 left right  与leading  trailing 的区别，最近需要做阿拉伯语才明白只有使用 leading  trailing 的前提下 镜像功能才能生效， 使用 left right 或者 frame的情况下都是指定了具体的方向和坐标位置，因此无法调整。切记！！！</p><ol start="2"><li><p>针对阿拉伯地区的导航的跳转方向是相反的，从左往右跳转的解决方案</p><ul><li>push时</li><li><pre><code class="objc">CATransition* transition = [CATransition animation];transition.type = kCATransitionPush;//可更改为其他方式transition.subtype = kCATransitionFromLeft;//可更改为其他方式[self.navigationController.view.layer addAnimation:transition forKey:kCATransition];[self.navigationController pushViewController:target animated:YES];</code></pre></li><li><p>pop是与上述一样只需修改方向</p><pre><code class="objc">transition.subtype = kCATransitionFromLeft;//可更改为其他方式self.navigationController popViewControllerAnimated:YES];</code></pre></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tips</title>
      <link href="/2018/12/05/Tips/"/>
      <url>/2018/12/05/Tips/</url>
      
        <content type="html"><![CDATA[<p>给大家分享一个修改bug时遇到的情景和建议</p><p>UIImagePickerController的代理方法，</p><pre><code class="objc">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info</code></pre><p>不要通过picker push或者present一个新的controller</p><p>原因：<br>1：这个方法调用时picker 要执行dismiss操作（苹果官方文档建议）<br>2：如果，picker不dismiss操作，直接通过picker push或者present一个新的controller，会出现难以控制的异常情况</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编写高质量代码的有效方法(6)-理解“属性”</title>
      <link href="/2018/11/17/OC%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/17/OC%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在OC等面向对象语言编程时，“对象”就是“基本构造单元”，开发者可以通过对象来存储并传递数据。在对象之间传递数据并执行任务的过程就叫做“消息传递”。要编写出高效且易维护的代码。就一定要熟悉这两个特性的工作原理。<br>当应用程序运行起来以后，为其提供相关支持的代码叫“OC运行时环境”（objective-c runtime)。它提供了一些使得对象间能够传递消息的重要函数，并且包含创建实例所用的全部逻辑。在理解了运行环境中种个部分协同工作的原理后，开发水平会更上一层。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><blockquote><p>属性（property）是OC的一项特性，用于封装对象中的数据。</p></blockquote><p>属性（property）是OC的一项特性，用于封装对象中的数据。OC对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”来访问。其中“获取方法（getter）”用于读取变量值，而“设置方法(Setter)”用于写入值。OC2.0中“属性”成为OC的一种特性，开发者阿以令编译器自动编写与属性相关的存取方法。此特性引入了一种新的“点语法”，使用开发者可以更为容易地对类对象来访问存放于其中的数据。<br>我们来看下下面示例：<br><pre><code>@interface Person : NSObject{    @public    NSString *_firstName;    NSString *_lastName;    @private    NSString *_age;}@end</code></pre></p><p>这种写法是java或者C++中常用的写法。用<code>@public</code> 、<code>@private</code> 来给变量加上作用域。在OC中很少这么做。为什么呢？ 这种写法存在以下问题：对象布局在编译期就已固定了，只要碰到<code>_firstName</code>变量的代码，编译器就把其替换成偏移量（offset）。这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远。<br>那么在原有基础上再增加一个实例变量会有什么问题呢？<br><pre><code>@interface Person : NSObject{    @public    NSDate * _dateOfBirth;    NSString *_firstName;    NSString *_lastName;    @private    NSString *_age;}@end</code></pre></p><p>原来表示<code>_firstName</code>的偏移量现在指向了<code>_dateOfBirth</code>.把偏移量硬编码于其中的那些代码都会读取到错误的值。<br>如下布局表</p><table><thead><tr><th></th><th>Person</th><th></th><th></th><th>Person</th></tr></thead><tbody><tr><td>+0</td><td>_firstName</td><td></td><td>+0</td><td>_dateOfBirth</td></tr><tr><td>+4</td><td>_lastName</td><td></td><td>+4</td><td>_firstName</td></tr><tr><td>+8</td><td>_age</td><td></td><td>+8</td><td>_lastName</td></tr><tr><td></td><td></td><td></td><td>+12</td><td>_age</td></tr></tbody></table><p>若代码使用了编译时期计算出来的偏移量，那么在修改类定义之后必须要重新编译，否则就会出错。<br><strong>OC是如何处理这种问题的呢？</strong><br>OC的做法是，把实例变量当做一种存储偏移量所用的“特殊变量”，交由“类对象”保管。偏移量会在运行期查找，如果类的定义发生了改变，那么存储的偏移量也就变量。这样无论何时访问实例变量，总能使用正确的偏移量。甚至可以在运行时向类新增实例变量。这就是稳固的“应用程序二进制接口（Application Binary Interface,ABI）”.ABI 定义了许多内容，其中一项就是生成代码时所遵循的规范。有了这种ABI，我们就可以在分类或都实现文件中定义实例变量了。</p><p>最好的解决方法是使用OC的属性。。在对象接口的定义中，使用属性是一种标准的写法，能够访问封装在对象里的数据。因此，也可把属性当作一种简称。其意思是说：“编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。”<br>以下两种方式是等效的<br><pre><code>@interface Person : NSObject@property (nonatomic,copy) NSString *firstName;@property (nonatomic,copy) NSString *lastName;@end@interface Person : NSObject- (NSString*)firstName;- (void)setFirstName:(NSString*)firstName;- (NSString*)lastName;- (void)setLastName:(NSString*)lastName;@end</code></pre><br><strong><em>如何访问属性？</em></strong><br>要访问属性，可以使用“点语法”，在纯C中，要想访问分配在栈上的结构体里的成员，也需要使用点语法。编译器会把“点语法”转换为对存取方法的调用。使用点语法的效果与直接调用存取方法相同。<br>以下是点语法与直接调用存取方法的示例：<br><pre><code>Person * person = [[Person alloc] init];person.firstName = @&quot;pinghua&quot;;&#x2F;&#x2F;与下述方式效果一致[person setFirstName:@&quot;pinghua&quot;];NSString *firstName = person.firstName;&#x2F;&#x2F;与下述方式效果一致NSString *firstName2 = [person firstName];</code></pre></p><p><strong>使用属性的其他优势</strong></p><ol><li>在对象接口中使用属性，那么编译器就会自动编写访问这些属性所需的方法。此过程叫“自动合成”（autosynthesis）.<strong>这个过程由编译器在编译期执行，所以在编辑器中看不到这些合成方法的源码</strong></li><li>编译器还会自动向类中添适当类型的实例变量，并在属性名前加下划线，以此作为实例变量的名字。</li><li>可以在类的实现代码里通过<code>@synthesize</code>语法来指定实例变量的名字 <pre><code>@implementation Person&#x2F;&#x2F;使用@synthesize指定变量的名字@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end    </code></pre></li><li>在不想让编译器自动生成合成存取方法时，则可以自己来实现。或者使用<code>@dynamic</code>关键字。这个关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。这样在编译时访问属性的代码，即使编译器发生没有定义存取方法，也不会报错，因为他相信这些方法在运行时期会找到。<br> 那么在实现文件中我们需要实现类以下代码： <pre><code>@implementation Person{&#x2F;&#x2F;手动添加实例变量NSString *_fistName;NSString *_lastName;}&#x2F;&#x2F;使用 @dynamic 让编译器不自动生成存取方法和属性@dynamic firstName,lastName;&#x2F;&#x2F;&#x2F;我们手动添加存取方法-(void)setFirstName:(NSString *)firstName{    _fistName = firstName;}-(NSString *)firstName{    return _fistName;}- (void)setLastName:(NSString *)lastName{    _lastName = lastName;}-(NSString *)lastName{    return _lastName;}@end    </code></pre> 如果我们只添加了<code>@dynamic firstName,lastName;</code>这句代码，没用手动添加存取方法，那么在编译时，编译器是不会发出警告信息的。但是在运行时会因找不到存取方法而发生crash.</li></ol><h1 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h1><p>属性具有的特性分为四类：原子性、读/写权限、 内存管理语义、方法名</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具有<code>nonatomic</code>则不使用同步锁。<strong>在属性声明中如果没有明确指出<code>nonatomic</code>,那么其就是<code>atomic</code>,如果我们手动定义存取方法，那么就应该遵从与属性特性相符的原子性</strong> ps:原子性并不是线程安全的。</p><h2 id="读-写权限"><a href="#读-写权限" class="headerlink" title="读/写权限"></a>读/写权限</h2><ol><li><code>readwrite</code>读写权限 ，具备该特性的属性具有“获取方法(getter)”与“设置方法(setter)”,若该属性由<code>@synthesize</code>实现，则编译器会自动生成这两个方法</li><li><code>readonly</code>只读权限。具备该特性的属性具有“获取方法（getter）”,只有当该属性由<code>@synthesize</code>实现时，编译器才会为其合成获取方法。我们可以利用些特性，把某个属性对外公开为只读属性，然后在分类中将其重新定义为读写属性。</li></ol><h2 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h2><p>属性用于封装数据，而数据则要有“具体的所有权语义”，以下特性仅会影响“设置方法”。</p><ol><li><code>assign</code> “设置方法”只会执行针对“纯量类型”（数值型）的简单赋值操作</li><li><code>strong</code> 此特性表明该属性定义了一种“拥有关系”，为这种属性设置新值进，设置方法会先保留新值，并释放旧值，然后再把新值设置上去。</li><li><code>weak</code>此特性表时该属性定义了一种“非拥有关系不”，为这种属性设置新值时，设置方法既不保留新值，也不会释放旧值。同<code>assign</code>类似，但在属性所指对象销毁时，属性值也会清空（nil out）。</li><li><code>unsafe_unretained</code>，此特性的语义与<code>assign</code>相同，但它适用于“对象类型”，该特性表明一种“非拥有关系”，当目标对象销毁时，属性值不会自动清空。</li><li><code>copy</code>此特性表达的是所属关系，与<code>strong</code>类似，但设置方法并不保留新值，而是将其“拷贝”。当属性类型为<code>NSString*</code>时，经常使用些特性来保护其封装性，因为传递给设置方法的新值很有可以是一个指向“NSMutableString”类的实例。这个类是<code>NSString</code>的子类，表示一种可以修改其值的字符串，此时若不拷贝字符串，那么设置完属性后，字符串的值很有可能在对象不知情的情况下被修改。所以这时拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动，只要实现属性所用的对象是可变的，那就应在设置新值进拷贝一份。</li></ol><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>可以通过以下方法指定存取方法名：</p><ol><li><code>getter = &lt;name&gt;</code>指定<code>获取方法</code>的方法名。</li><li><code>setter = &lt;name&gt;</code>指定“设置方法”的方法名。不太常用<pre><code>@property (nonatomic,copy,getter=&lt;#method#&gt;,setter=&lt;#method#&gt;) NSString *firstName;</code></pre>通过以后方式可以微调编译器所合成的存取方法。<strong>注意：如果是我们自己来实现这些存取方法，那么应该保证其具备相关属性所声明的特性</strong></li></ol><p><strong><code>atomic</code>与<code>nonatomic</code>的区别是什么？</strong><br>具备atomic特性和获取方法会通过锁定机制来确保其操作的原子性。也就是说如何两个线程读写同一属性，那么无论何时总能看到有效的属性值。若不加锁，那么当其中一个线程正在改写某属性值时，另一个线程突然进入，把尚未修改好的属性值读取出来，这时，线程读取的值可能不对。在开发过程中会发现大部分属性都声明为’nonatomic’,为什么？因为在iOS中使用同步锁的开销很大，会带来性能问题。一般情况下并不要求属性必须是原子性，因为这并不能保证线程安全，若要实现线程安全，需要采用更为深层的锁定机制。</p><blockquote><p>总结</p><ol><li>采用@property语法来定义对象中所封装的数据</li><li>通过“特性”来指定存储数据所需要的正确语义</li><li>在设置必属性对应的实例变量时，一定要遵从该属性所声明的语义</li><li>在开发时应用nonatomic属性，因为atomic属性会严重影响性能</li></ol></blockquote><h1 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h1><p>在对象之外访问实例变量时，总是应该通过属性来做，那么在对象内部访问实例变量时，要怎么做呢？<br>我们来观察下列代码段：<br><pre><code>-(void)setFullName:(NSString *)fullName{    NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;];    self.firstName = [components firstObject];    self.lastName = [components lastObject];}-(NSString *)fullName{    return [NSString stringWithFormat:@&quot;%@ %@&quot;,self.firstName,self.lastName];}</code></pre><br><pre><code>-(void)setFullName:(NSString *)fullName{    NSArray *components = [fullName componentsSeparatedByString:@&quot; &quot;];    _firstName = [components firstObject];    _lastName = [components lastObject];}-(NSString *)fullName{    return [NSString stringWithFormat:@&quot;%@ %@&quot;,_firstName,_lastName];}</code></pre><br><strong>这两种写法有什么区别？</strong></p><ol><li>由于不经过OC的“消息派发”，所以直接访问实例变量的速度会比较快。这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。</li><li>直接访问实例变量时，不会调用其设置方法，这样绕过了相关属性所定义的内存管理语义。（在ARC下直接访问一个声明为Copy的属性，那么并不会拷贝该属性，，只会保留新值，释放旧值）</li><li>直接访问实例变量，不会触发“键值观察（KVO）”通知。</li><li>通过属性来访问有助于排查与之相关的错误。（可以在存取方法中添加断点，监控该属性值的调用及其访问时机）</li></ol><p><strong><em>有没有一种即能提高读写操作的速度，又能控制对属性的写入操作的方案：</em></strong><br>在写入实例变量时，通过其设置方法来做，而在读取实例变量时，直接访问实例变量。</p><blockquote><p>使用这种方法需要注意以下两点：</p><pre><code>1. 在初始方法中应该如何设置属性值。2. 在使用“懒加载初始化时”，需要通过属性的获取方法来访问属性，否则实例变量永远不会初始化</code></pre></blockquote><blockquote><p>小结</p><pre><code>1. 在对象内部读取数据时应该直接通过实例变量获取，而写入数据时，应通过属性来写。2. 在初始化及dealloc方法中，应直接通过实例变量来读写数据。3. 有时会使用懒加载初始化技术配置某份数据，这种情况下，需要通过属性来读取数据</code></pre></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类初始化关键字</title>
      <link href="/2018/11/16/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/11/16/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="『Apple-API』NS-UNAVAILABLE-与-NS-DESIGNATED-INITIALIZER"><a href="#『Apple-API』NS-UNAVAILABLE-与-NS-DESIGNATED-INITIALIZER" class="headerlink" title="『Apple API』NS_UNAVAILABLE 与 NS_DESIGNATED_INITIALIZER"></a>『Apple API』NS_UNAVAILABLE 与 NS_DESIGNATED_INITIALIZER</h1><p>当面对多个初始化方法时，外部调用者往往会手足无措，不知道哪一个才是正确的初始化方法，对此，苹果提供了两个关键字：<code>NS_UNAVAILABLE</code> 与 <code>NS_DESIGNATED_INITIALIZER</code> 来帮助我们约束定义方式，使得接口描述更加清晰。</p><h1 id="NS-DESIGNATED-INITIALIZER"><a href="#NS-DESIGNATED-INITIALIZER" class="headerlink" title="NS_DESIGNATED_INITIALIZER"></a>NS_DESIGNATED_INITIALIZER</h1><p>对于多个 init 方法，苹果给出了一个调用顺序，而我们也应该遵守这种调用顺序，以确保无论外部调用者从哪个入口进入，都能够正确的初始化：<br><img src="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Art/multiple_initializers_2x.png" alt="多个init方法的调用顺序"></p><p>上面这张方法调用顺序，很清晰的描述了正确的初始化逻辑。</p><p>可以看到真正在进行初始化参数的，是 <code>initWithTitle:date:</code>，如果调用者通过 <code>init</code> 或者 <code>initWithTitle:</code> 进入，都应该确保变量 <code>title</code> 和 <code>date</code> 能正确赋值，所以 <code>init</code> 与 <code>initWithTitle:</code> 都通过调用 <code>initWithTitle:date:</code> 来初始化。</p><p>最后 <code>initWithTitle:date:</code> 在通过父类的 <code>init</code> 初始化，并初始化两个变量。</p><p>对于这种能初始化全部必需变量的方法，一般可作为 <code>designed initializer</code>。所以，可以明确的告诉外部调用者，无论调用哪种初始化方法，最终，都会调用 <code>designed initializer</code>：</p><p><code>- (instancetype)initWithTitle:(NSString *)title date:(NSDate *)date NS_DESIGNATED_INITIALIZER;</code>一个子类如果有自己的 designed initializer，则必须要实现父类的 designed initializer。比如一个继承自 NSObject 的 Person 类，就必须要重写 init 方法，并在 init 方法中，调用自己的 designed initializer，而不是调用 super 的初始化方法。如果未实现，可以看到编译警告：</p><p><code>Method override for the designed initializer of the superclass ‘- init’ not found.</code><br>所以，对于 Person 来说，如果 initWithName: 被标记了 NS_DESIGNED_INITIALIZER，那么实现应该为：</p><pre><code class="objc">- (instancetype)init {    // 在外部调用不需要 name 变量时，应该给出默认值    return [self initWithName:@&quot;John doe&quot;];}- (instancetype)initWithName:(NSString *)name {    self = [super init];    if (self) {        self.name = name;    }    return self;}</code></pre><p>除此之外，子类的 designed initializer 方法，在调用 super 时，也应该调用 super 的 designed initializer。也就是说，如果 CustomView 是 UIView 的子类，那么应该写作：</p><pre><code class="objc">// 实现 UIView 的 designed initializer- (instancetype)initWithCoder:(NSCoder *)aDecoder {    return [self initWithVideoID:@0];}// 实现 UIView 的 designed initializer- (instancetype)initWithFrame:(CGRect)frame {    return [self initWithVideoID:@0];}// 实现自己的 designed initializer- (instancetype)initWithVideoID:(NSNumber *)videoID {    // 这里在调用 super 的初始化方法时，就不能调用 init，因为 init 不是 UIView 的 designed initializer    self = [super initWithFrame:CGRectZero];    if (self) {        self.videoID = videoID;        [self setupUI];    }    return self;}</code></pre><h1 id="NS-UNAVAILABLE"><a href="#NS-UNAVAILABLE" class="headerlink" title="NS_UNAVAILABLE"></a>NS_UNAVAILABLE</h1><p>在定义初始化方法时，除了能够用 <code>NS_DESIGNATED_INITIALIZER</code> 标记以外，还可以使用更为强势的 <code>NS_UNAVAILABLE</code>。和 <code>NS_DESIGNATED_INITIALIZER</code> 用于明确初始化方法方式不同，<code>NS_UNAVAILABLE</code> 的作用是，直接禁用其他初始化方法，简单粗暴。</p><p>假设，对于 User 类，如果没有 userID 就代表着用户无效，那么我们也没必要给 init 方法一个默认的 userID = 0，或者 userID = nil。此时，需要告诉调用者，就只能通过 userID 来初始化，那么可以写作：</p><pre><code class="objc">+ (instancetype)new NS_UNAVAILABLE;- (instancetype)init NS_UNAVAILABLE; ///&lt; 直接标记 init 方法不可用- (instancetype)initWithUserID:(NSNumber *)userID;</code></pre><p>方法一旦标记 <code>NS_UNAVAILABLE</code>，那么在 IDE 自动补全时，就不会索引到该方法，并且如果强制调用该方法，编译器会报错（但并不代表着方法不能被调用，runtime 依然可以做到）。</p><p>除了可以直接使用 NS_UNAVAILABLE 标记不可用以外，还有一些其他的方式：</p><pre><code class="objc">// 作用与 NS_UNAVAILABLE 类似- (id) init __unavailable;- (id) init __attribute__((unavailable));- (id) init UNAVAILABLE_ATTRIBUTE;</code></pre><p>// 在调用时给出提示<br><code>- (id) init __attribute__((unavailable(&quot;Must use initWithFoo: instead.&quot;)));</code>甚至是在调用时抛出异常等，比如 userID 不能小于 0：</p><pre><code class="objc">- (instancetype)initWithUserID:(NSNumber *)userID {    self = [super init];    if (self) {        if (userID.integerValue &lt;= 0) {              // raise: 原因            // format: 具体描述            [NSException raise:@&quot;error parameter&quot; format:@&quot;user id can not = %@&quot;, userID];        }        self.userID = userID;    }    return self;}</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>NS_DESIGNATED_INITIALIZER</code>与 <code>NS_UNAVAILABLE</code> 都能清晰的告知调用者应该如何调用方法。</p><p>如果是可以给出默认值初始化方法，那么使用<code>NS_DESIGNATED_INITIALIZER</code> 就可以。<br>如果是必须要用某参数来初始化的，可以使用 <code>NS_UNAVAILABLE</code>。<br>如果需要在内部验证参数是否合法，如果不合法就一定不能成功的，也可以在实现的时候，验证并抛出异常。<br>具体选择使用哪一种方式，可以根据具体的情况来看</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通知详解</title>
      <link href="/2018/11/15/%E9%80%9A%E7%9F%A5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/15/%E9%80%9A%E7%9F%A5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS通知详解-不同线程发出通知的处理"><a href="#iOS通知详解-不同线程发出通知的处理" class="headerlink" title="iOS通知详解 不同线程发出通知的处理"></a>iOS通知详解 不同线程发出通知的处理</h1><h2 id="通知的基础知识"><a href="#通知的基础知识" class="headerlink" title="通知的基础知识"></a>通知的基础知识</h2><p>每一个应用程序都有一个通知中心，专门负责协助不同 对象之间的消息通信。</p><p>任何一个对象都可以向通知中心发布通知，描述自己在做什么。其他感兴趣的对象可以申请在某个特定通知发布时（或在某个特定的对象发布通知时）收到这个通知。</p><pre><code class="objc">/****************    Notifications    ****************///一个通知一般包含三个属性：@property (readonly, copy) NSString *name;//通知名称@property (nullable, readonly, retain) id object;//通知发布者（是谁要发布通知）//一些额外的信息(通知发布者传递给通知接收者的信息内容)@property (nullable, readonly, copy) NSDictionary *userInfo;//初始化一个通知：(NSNotification)对象 - (instancetype)initWithName:(NSNotificationName)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo + (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject; + (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</code></pre><pre><code class="objc">/****************    Notification Center    ****************///发布通知方法(通知中心提供了相应的方法来帮助发布通知)//1.发布一个notification通知，可在notification对象中设置通知的名称，通知发布者、额外的信息等- (void)postNotification:(NSNotification *)notification; //2.发布一个名称为aName的通知，anObject为这个通知的发布者- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;//3.发布一个名称为aName的通知，anObject为这个通知的发布者，aUserInfo为额外信息(通知的内容)- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;/// 监听通知方法- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;///使用block处理通知回调用 // The return value is retained by the system, and should be held onto by the caller in// order to remove the observer with removeObserver: later, to stop observation.//Name: 通知的名称//object:谁发出的通知//queue: 队列,决定 block 在哪个线程中执行, nil  在发布通知的线程中执行//usingBlock: 只要监听到通知,就会执行这个 block- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));//移除观察者- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject;</code></pre><blockquote><p>在通知中心注册过的对象，需要在该对象释放前移除监听。否则，当相应的通知再次出现时，通知中心仍然会向该监听器发送消息。因为相应的监听器对象已经被释放了，所以可能会导致应用闪退.<br>执行顺序：一定要先向通知中心注册通知监听器，也就是谁要监听谁发布的消息，然后再执行发布消息，不然会导致消息发出来了没人接收的情况</p></blockquote><h2 id="同步或异步"><a href="#同步或异步" class="headerlink" title="同步或异步"></a>同步或异步</h2><p><code>[NotificationCenter defaultCenter] postNotification]</code>，这种方式是同步的，并且在哪个线程发，就在哪个线程收。<br>由于消息收和发都在同一个线程中。所以，尽量在主线程中post，不然会引起不必要的麻烦，ui刷新问题，崩溃问题等等<br>参考文档</p><h2 id="addObserver调用多次"><a href="#addObserver调用多次" class="headerlink" title="addObserver调用多次"></a>addObserver调用多次</h2><p>addObserver如果添加多次，当post的时候，也会收到多次。类似这种：</p><pre><code class="objc">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@&quot;TestNotification&quot; object:nil];</code></pre><p><a href="https://www.jianshu.com/p/617dfb533a34" target="_blank" rel="noopener">你可能不知道的Notification</a><br><a href="http://www.cnblogs.com/QianChia/p/5771055.html" target="_blank" rel="noopener">iOS - Notification    通知</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043i" target="_blank" rel="noopener">NSNotification</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> NSNotification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写高质量代码的有效方法之（1-5）---OC基础</title>
      <link href="/2018/11/09/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E7%9A%8452%E4%B8%AA%E6%96%B9%E6%B3%95part1/"/>
      <url>/2018/11/09/%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E7%9A%8452%E4%B8%AA%E6%96%B9%E6%B3%95part1/</url>
      
        <content type="html"><![CDATA[<p>本部分主要了解OC的基础，总结几个比较高效的编程窍门</p><h1 id="了解OC的起源"><a href="#了解OC的起源" class="headerlink" title="了解OC的起源"></a>了解OC的起源</h1><ul><li>OC为C语言添加了面向对象特性，是其超集。OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收消息后，究竟应执行何种代码，由运行环境而非编译器决定。</li><li>OC语言使用用“消息结构”而非“函数调用” <blockquote><p>消息与函数调用的区别：<br>使用消息结构的语言，其运行时所应执行的代码由运行环境决定；而使用函数调用的语言，则由编译器决定。如果代码中调用的函数是多态的，那么在运行时就要按照“虚方法表”来查找到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。实际上编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做“动态绑定(dynamic binding)”</p></blockquote></li></ul><h1 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h1><p>在头文件中尽量使用“向前声明”要引用的类<br><pre><code>@class XXXXclassName;</code></pre><br>将引入头文件的进机尽量延后，只在确有需要进再引入，这样可以减少类的使用者所需要引入的头文件数量。减少一定的编译时间。<br>向前声明也也解决了两个类相互引用的问题。</p><blockquote><p>最佳实践：</p><ol><li>除非确有必要，否则不要引入在头文件中引入其他头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合（coupling）</li><li>有时无法使用向前声明，比如要声明某个类要遵守一项协议。这种情况下。尽量把“该类遵守某协议”这条声明移至实现文件中的分类中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</li></ol></blockquote><h1 id="多用字面量语法-语法糖-以，少用与之等价的方法"><a href="#多用字面量语法-语法糖-以，少用与之等价的方法" class="headerlink" title="多用字面量语法(语法糖)以，少用与之等价的方法"></a>多用字面量语法(语法糖)以，少用与之等价的方法</h1><p><code>NSString</code> <code>NSNumber</code> <code>NSArray</code> <code>NSDictionary</code>这几个类是我们最常使用的。我们可以使用”字面量语法(literal systax)”更方便快捷的创建这些对象，缩减代码长度，使其更易读。</p><h2 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h2><p>在需要把整数，浮点数，布尔值转成OC对象时，我们可以使用NSNumber类，该类可以处理多种类型的数值。以下两种方式是等价的，但后一种方式更为推荐使用<br><pre><code>NSNumber *value = [NSNumber nubmerWithInt:1];</code></pre><br><pre><code>NSNumber *value = @1;</code></pre><br>以字面量来表示数值十分有用。这样做可以令NSNumber对象更为整洁，因为声明中只有包含数值，没有多余的语法成份</p><h2 id="字面量数组"><a href="#字面量数组" class="headerlink" title="字面量数组"></a>字面量数组</h2><p>数组为常用的数据结构。下面依次以数组的创建、取值来举例，以及注意事项为序来学习下<br><pre><code>NSArray * animals = [NSArray arrayWithObjects:@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;,@&quot;badger&quot;,nil];</code></pre><br><pre><code>NSArray *animas = @[@&quot;cat&quot;,@&quot;dog&quot;,@&quot;mouse&quot;,@&quot;badger&quot;];</code></pre></p><pre><code>NSString *dog =  [animas objectAtIndex:1];</code></pre><pre><code>NSString *dog = animas[1];</code></pre><p>“取下标”操作(subscripting)，与使用字面量语法的其他情况一样，这种方式更为简洁，更易理解。而且与其他语方依下标来访问数组元素时所用的语法类似。</p><p><strong>用字面量语法创建数组时要注意，若数组元素对象中有nil,则分抛出异常。因为字面语法实际上一种语法糖(synatactic sugar)，其效果等同于先创建一个数组，然后把方括号中的所有对象添加至数组中</strong> 会抛出的异常会是这样的：<br><pre><code>*** Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;*** -[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[1]&#39;</code></pre></p><p>我们来看以下代码：<br><pre><code>id object1 = @&quot;cat&quot;; id object2  = nil; id object3  = @&quot;dog&quot;;  NSArray *arrayA = [NSArray arrayWithObjects:object1,object2,object3, nil]; NSLog(@&quot;%@&quot;,arrayA); &#x2F;&#x2F; cat </code></pre><br><pre><code>id object1 = @&quot;cat&quot;;id object2  = nil;id object3  = @&quot;dog&quot;;NSArray *arrayB =@[object1,object2,object3];NSLog(@&quot;%@&quot;,arrayB);</code></pre><br>Q:如果object1 和object3都指向了有效的对象，object2是nil,那么会出现什么情况呢？<br>A：按字面量创建数组B会抛出异常，数组A虽然可以创建出对象，但其中只有一个元素。原因在于<code>arrayWithObjects:</code>方法会依次处理各个参数，直到发现nil为止，由于oject2是nil,所以该方法会提前结束。</p><blockquote><p>这个微妙的差别表明，使用字面量语法更为安全。抛出异常令程序终止执行，比创建数组之后才发现少了元素要好，向数组中插入nil,通常说明程序有错，而通过异常可以更快发现这个错误</p></blockquote><h2 id="字面量字典"><a href="#字面量字典" class="headerlink" title="字面量字典"></a>字面量字典</h2><p>字典（Dictionary）也是一种映射型数据结构，可向其添加键值对。在开发过程中使用字典的频率很高。<br><pre><code>NSDictionary *person = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Mat&quot;,@&quot;firstName&quot;,@&quot;Galloy&quot;,@&quot;lastName&quot;,[NSNumber numberWithInt:28],@&quot;age&quot;, nil];</code></pre><br><pre><code>NSDictionary *person2 = @{@&quot;firstName&quot;:@&quot;Mat&quot;,                             @&quot;lastName&quot;:@&quot;Galloy&quot;,                             @&quot;age&quot;:@(28)                             };</code></pre><br>第一种写法令人迷惑，因为其顺序是&lt;对象&gt;&lt;键&gt;&lt;对象&gt;&lt;键&gt;。这与通常理解的顺序相反，我们一般认为把“键”映射到“对象”。<br>第二种写法更简明，而且键出现在对象之前，理解更为顺畅。</p><blockquote><p>与数组一样，用字面量语法创建字典也有个问题，就是一旦有值为nil,便出抛出异常。</p></blockquote><h2 id="可变数组与字典"><a href="#可变数组与字典" class="headerlink" title="可变数组与字典"></a>可变数组与字典</h2><p>通过取下标操作，可以访问数组中某个下标或字典中某个键值所对应的元素。如果数组与字典对象是可变的，那么也可以通过下标修改其中的元素值。<br><pre><code>[mutableArray replaceObjectAtIndex:1 withOject:@&quot;dog2&quot;];[mutableDictionar  setObject:@&quot;huahua&quot; forKey:@&quot;lastName&quot;];</code></pre><br><pre><code>mutableArray[1] = @&quot;dog2&quot;;mutableDictionary[@&quot;lastName&quot;] = @&quot;huahua&quot;;</code></pre></p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>字面面语法有个小小的限制，就是除了字符串外，所创建出来的对象必须属于Foundation框架才行。如果自定义这些类的子类，则无法使用字面量语法创建其对象。</p><blockquote><p>总结<br>应该使用字面量来创建字符串、数值、数组、字典。与常规方法相比，这么做更为简明扼要。<br>应该通过取下标操作访问数组下标或字典中的键所对应的元素<br>用字面量创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值不为nil。</p></blockquote><h1 id="多用类型常量，少用-define预处理指令"><a href="#多用类型常量，少用-define预处理指令" class="headerlink" title="多用类型常量，少用#define预处理指令"></a>多用类型常量，少用#define预处理指令</h1><p>编写代码时经常要定义常量，这时你会怎么做？会是像下面一样？<br><pre><code>#define ANIMATION_DURATION 0.3</code></pre><br>这可能是你想要的效果。但是这样定义出来的常量没有类型信息。另外，预编译过程会把所有<code>ANIMATION_DURATION</code>替换成<code>0.3</code>,这样一来，假设指令声明在头文件中，那么所有引入这个头文件的代码，其<code>ANIMATION_DURATION</code>都会被替换。<br>要解决此类问题，我们需要利用编译器的某些特性，如下面这种方式<br><pre><code>static const NSTimeInterval kAnimationDuration = 0.3;</code></pre><br>这种方式定义的常量包含类型信息，其好处是清楚地描述了常量的含义。有助于为其编写开发文档。如果要定义许多常量，那么这种方式能为后面阅读代码的人更容易理解其意图。</p><blockquote><p>命名注意事项</p><ol><li>若常量局限于“某编译单元”（即实现文件类）则在其前面加上字母<code>k</code>;</li><li>若常量在类之外可见，则通常以类名为前缀</li></ol></blockquote><p>在开发过程中我们都有喜欢在头文件中声明预处理指令的习惯，这并不是一个好的习惯。当常量名有可能相互冲突时更是如此。如<code>ANIMATION_DURATION</code>这个常量就不应该放在头文件中，当所有引入该文件的其他文件都会出现这个名字，就连<code>static const</code>定义的常量也不应该放在头文件中。在OC里没有命名空间这一说，这样做就等同于声明一个<code>kAnimationDuration</code>的全局变量。<br>在不打算公开某个常量时，应将其放在实现文件中。</p><p><strong>Q：变量为何一定要同时用static和const来声明？</strong><br>A：</p><ol><li>如果试图修改由const修饰符所声明的变量，那么编译器会报错。</li><li>static修饰符则意味着该变量仅在定义此变量的编译单元可见。</li><li>如果一个变量同时声明为static、const,那么编译器根本不会创建符号，而会像#define预处理命令一样，把所有遇到的变量都替换成常量值。<strong>这种方式定义的常量带有类型信息</strong></li></ol><p><strong>Q：如何定义一个对外公开的常量</strong><br>如在代码中调用<code>NSNotificationCenter</code>以通知他们。用一个对象来派发通知，令其他欲接收通知的对象向该对象注册。这样就能实现此功能了。派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的常值变量（constant variable）,这样注册者无须知道实际字符串的值，只需以常值变量来注册自己想接收的通知即可。<br>此类变量需要入在“全局符号表(global symbol table)”中，以便可以在定义该常量的编译单元之外使用<br><pre><code>&#x2F;&#x2F;&#x2F;In the header fileextern NSString *const QMPlayerDidStopNotification;&#x2F;&#x2F;&#x2F;In the implement fileNSString *const QMPlayerDidStopNotification = @&quot;PlayerDidStop&quot;;</code></pre><br>这种常量在头文件中<code>声明</code>，在实现文件中<code>定义</code>. 注意<code>const</code>修饰符在常量类型中的位置。常量定义应从右至左解读。</p><blockquote><p>QMPlayerDidStopNotification是一个常量，而这个常量是一个指针，指向NSString对象</p></blockquote><p>编译器看到头文件中的<code>extern</code>关键字，就能明白如可在引入该头件的代码中处理该常量了。<code>extern</code>关键字千诉编译器，在全局符号表中将有一个 <code>QMPlayerDidStopNotification</code>符号。 这类常量必须要定义，而且只能定义一次。通常将其定义在与声明该常量的头文件相关的实现文件里。由实现文件生成目标文件时，编译器会在“数据段(data section)”为字符串分配存储空间。链接器会把此目标文件与其他目标文件相链接，以生成最终的二进制文件。</p><blockquote><p>命名注意事项<br>因符号在全局符号表中，所以命名要格外小心。为避免冲突，最好是用与之相关的类名做前缀。</p></blockquote><blockquote><p>总结</p><ol><li>不要使用预处理指令定义常量<br>   这样定义出来的常量不含类型信息，编译器只是会在编译前据引执行查找和替换操作。即使有人重新定义了常量值，编译器也不会产生警告。这将导致各序的常量值不一致</li><li>在实现文件中使用static const 来定义“只在编译单元可见的常量（translation-unit-specific constant)”.由于此类常量不在全局符号表中，所有无须为其添加前缀</li><li>在头文件中使用extern来声明全局常量，并在相关的实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称要加以区分，通常使用与之相关的类名做前缀</li></ol></blockquote><h1 id="用枚举表示状态、选项、状态码"><a href="#用枚举表示状态、选项、状态码" class="headerlink" title="用枚举表示状态、选项、状态码"></a>用枚举表示状态、选项、状态码</h1><p>由于OC基于C语言，所以C语言有的功能它都有，其中之一就是枚举类型：<code>enum</code>,系统框架中使频繁使用到此类型，然而我们容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。<br>枚举只是一种常量的命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集（enumeration set）<br><pre><code>typedef NS_ENUM(NSInteger, AVPlayerStatus) {AVPlayerStatusUnknown,AVPlayerStatusReadyToPlay,AVPlayerStatusFailed};</code></pre><br>由于每个状态都用一个便于理解的值表示，所以这样写出来的代码更易懂。编译器会为枚举分配一个独有的编号，从0开始，每个枚举递增1。实现枚举所用的数据类型取决于编译器，不过其二进制位的个数必须完全表示下枚举编号才行。在上述例子中由于最大编号是2，所以使用1个字节的char类型就行（<em>一个字节含8个二进制位，所以最多可以表示256种枚举的枚举变量</em>）<em>我们也可以手动设置枚举的值</em></p><p>还有另外一种情况我们应该使用枚举，就是定义选项的进候。若这些选项可以彼此组合，则更应如此。只要枚举定义的对，各选项间就可以通过“按位或操作符”来组合。如：<br><pre><code>typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {    UIViewAutoresizingNone                 = 0,    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5};</code></pre><br>每个选项均可启用或禁用，使用上述方式定义的枚举值即可保证这一点，因为每个枚举值所对应的二进制位中只有一个二进制位的值是1。用“按位或操作符”可以组合多个选项。用“按位与操作符”即可判断出是否已启用某个选项。<br><pre><code>UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; if (resizing&amp;UIViewAutoresizingFlexibleWidth) {     &#x2F;&#x2F;&#x2F;是否启用UIViewAutoresizingFlexibleWidth }</code></pre></p><blockquote><p>凡是需要以按位或操作来组合的枚举都应使用<code>NS_OPTIONS</code>定义。若枚举不需要进行组合，则应用<code>NS_ENUM</code>来定义。</p></blockquote><p>枚举在switch中的使用。<br>我们习惯在switch语句中加上default分支。然而使用枚举来定义状态机，则最好不要使用default分支，这样如果稍后增加一种状态，那么编译器就会发出警告，提示新加入的状态未在switch分支中处理。若使用了default分支，那么这就会处理这个新的状态，从而编译器不会发出警告信息。</p><blockquote><p>总结</p><ol><li>应用枚举来表示状态机的状态，传递给方法的选项以及状态码等值，给这个值取个易懂的名字</li><li>如果把传递给某个方法的选项表示为枚举，而多个选项又可同时使用，那么将各选项的值定义为2的幂，以便通过按位或操作将其进行组合</li><li>用<code>NS_ENUM</code>与<code>NS_OPTIONS</code>宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。</li><li>在处理枚举类型的switch语句中不要实现default分支。这样在加入新的枚举后，编译器会提示开发者：switch语句中有未处理的枚举选项。 </li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> OC2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TaggedPoint</title>
      <link href="/2018/11/08/TaggedPoint/"/>
      <url>/2018/11/08/TaggedPoint/</url>
      
        <content type="html"><![CDATA[<p>Tagged Pointer 详细的内容可以看这里 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></p><ul><li>Tagged Pointer 是一个能够提升性能、节省内存的有趣的技术。</li><li>Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate（后来可以存储小字符串）</li><li>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。</li><li>它的内存并不存储在堆中，也不需要 malloc 和 free，所以拥有极快的读取和创建速度。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton单例</title>
      <link href="/2018/10/08/Singleton%E5%8D%95%E4%BE%8B/"/>
      <url>/2018/10/08/Singleton%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例类总是返回自己的同一个实例，它提供了对类的对象所提供资源的全局访问点。<br>单例模式的意图：<br>使得类的一个对象成为系统中的唯一实例。</p></blockquote><p>单例版本1：</p><pre><code class="objc">NS_ASSUME_NONNULL_BEGIN@interface TestManager : NSObject@property (nonatomic,copy) NSString * name;+ (instancetype)shareInstance;@endNS_ASSUME_NONNULL_END@implementation TestManagerstatic TestManager * manager = nil;+ (instancetype)shareInstance{    if (manager== nil) {        manager = [[TestManager alloc] init];    }    return manager;}@end</code></pre><p>这不是一个“严格”意义上的单例，要想在实际中使用，需要面对以下两个主要的障碍：</p><ul><li>发起调用的对象不能以其他分配方式实例化单例对象。否则，就有可以创建单例类的多个实例</li><li>对单例对象实例化的限制应该与引用计数内存模型共存</li></ul><p>以下测试代码对TestManager生成了多个不同的实例</p><pre><code class="objc">    TestManager * test1 = [TestManager shareInstance];    test1.name = @&quot;1&quot;;    TestManager * test2 = [[TestManager  alloc] init];    test2.name = @&quot;rewq&quot;;    NSLog(@&quot;%@:%@&quot;,test1.name,test2.name); // 1:rewq</code></pre><p>此模式下，调用test1的copy方法会crash ，<code>-[TestManager copyWithZone:]: unrecognized selector sent to instance 0x6000003b05f0</code> TestManager类未实现<code>NSCopying</code>协议 </p><p>版本2</p><pre><code class="objc">@implementation TestManagerstatic TestManager * manager = nil;+ (instancetype)shareInstance{    static TestManager * manager = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        manager = [[TestManager alloc] init];    });    return manager;}@end</code></pre><p>此版本依然是一个非“严格“意义上的单例，但这个是线程安全的。</p><p>下面我们来实现一个严格意上的单例：<br>版本3：</p><pre><code class="objc">NS_ASSUME_NONNULL_BEGIN@interface TestManager : NSObject&lt;NSCopying,NSMutableCopying&gt;@property (nonatomic,copy) NSString * name;+(instancetype)shareInstance;@endNS_ASSUME_NONNULL_END@implementation TestManager+(instancetype)shareInstance{    static TestManager * manager = nil;    if (manager== nil) {        manager = [[super allocWithZone:NULL] init];    }    return manager;}+(instancetype)allocWithZone:(struct _NSZone *)zone{    return [self shareInstance];}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)copyWithZone:(NSZone *)zone{    return self;}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)mutableCopyWithZone:(NSZone *)zone{    return self;}@end</code></pre><p>和前两个版本一样，首先检查类的唯一实例是否已创建，如果没有，就创建一个新的实例并将其返回。但是，这里没有使用alloc这样的方法，而是调用<code>[[super allocWithZone:NULL] init]</code>来生成新的实例。为什么是super而不是self？因为已经在self中重载了基本的对象分配方法，所以需要“借用”其父类的功能来帮助处理底层内存分配的杂务。<br>Ps:这里没有考虑到多线程问题，如果在多线程中使用的话需要考虑到线程安全<br>版本4（线程安全）</p><pre><code class="objc">@implementation TestManager+(instancetype)shareInstance{    static TestManager * manager = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        //以下代码有crash的机率        //manager = [[TestManager alloc] init];         manager = [[ super allocWithZone:NULL] init];    });    return manager;}+(instancetype)allocWithZone:(struct _NSZone *)zone{    return [self shareInstance];}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)copyWithZone:(NSZone *)zone{    return self;}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)mutableCopyWithZone:(NSZone *)zone{    return self;}@end</code></pre><p>版本5（线程安全):</p><pre><code class="objc">+(instancetype)shareInstance{    return [[[self class] alloc]init];}+(instancetype)allocWithZone:(struct _NSZone *)zone{    static TestManager * manager = nil;    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        //不能这样添加，否则会crash        // manager = [[TestManager alloc] init];         manager = [[ super allocWithZone:zone] init];    });    return manager;}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)copyWithZone:(NSZone *)zone{    return self;}//保证不返回实例的副本，通过返回self,返回同一个实例-(id)mutableCopyWithZone:(NSZone *)zone{    return self;}@end</code></pre><h2 id="一劳永逸，单例模式的优化"><a href="#一劳永逸，单例模式的优化" class="headerlink" title="一劳永逸，单例模式的优化"></a>一劳永逸，单例模式的优化</h2><p>如果想要一劳永逸，我们将面临两个问题</p><ol><li>如何写一份单例代码在ARC和MRC环境下都适用？</li><li>如何使一份单例代码可以多个类共同使用  </li></ol><p>为了解决这两个问题，我们可以在PCH文件使用代参数的宏和条件编译<br>利用条件编译来判断是ARC还是MRC环境</p><pre><code class="objc">#if __has_feature(objc_arc)//如果是ARC，那么就执行这里的代码1#else//如果不是ARC，那么就执行代理的代码2#endif</code></pre><p>将单例方法写成宏定义：</p><pre><code class="objc">#define singleH(name) +(instancetype)shareInstance;#if __has_feature(objc_arc)#define singleM(name) static id _instance;\+ (instancetype)allocWithZone:(struct _NSZone *)zone\{\static dispatch_once_t onceToken;\dispatch_once(&amp;onceToken, ^{\_instance = [super allocWithZone:zone];\});\return _instance;\}\\+ (instancetype)shareInstance\{\return [[self alloc]init];\}\- (id)copyWithZone:(NSZone *)zone\{\return _instance;\}\\- (id)mutableCopyWithZone:(NSZone *)zone\{\return _instance;\}#else#define singleM static id _instance;\+ (instancetype)allocWithZone:(struct _NSZone *)zone\{\static dispatch_once_t onceToken;\dispatch_once(&amp;onceToken, ^{\_instance = [super allocWithZone:zone];\});\return _instance;\}\\+ (instancetype)shareInstance\{\return [[self alloc]init];\}\- (id)copyWithZone:(NSZone *)zone\{\return _instance;\}\\- (id)mutableCopyWithZone:(NSZone *)zone\{\return _instance;\}\- (oneway void)release\{\}\\- (instancetype)retain\{\return _instance;\}\\- (NSUInteger)retainCount\{\return MAXFLOAT;\}#endif</code></pre><p>在.h文件中调用singleH(类名)<br>在.m文件中调用singleM(类名)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UIView显示层初级动画</title>
      <link href="/2018/09/24/UIView%E6%98%BE%E7%A4%BA%E5%B1%82%E5%88%9D%E7%BA%A7%E5%8A%A8%E7%94%BB/"/>
      <url>/2018/09/24/UIView%E6%98%BE%E7%A4%BA%E5%B1%82%E5%88%9D%E7%BA%A7%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="显示层初级动画属性预览"><a href="#显示层初级动画属性预览" class="headerlink" title="显示层初级动画属性预览"></a>显示层初级动画属性预览</h2><pre><code class="swift">extension UIView {    open var frame: CGRect    open var bounds: CGRect    open var center: CGPoint    open var transform: CGAffineTransform    @NSCopying open var backgroundColor: UIColor?    open var alpha: CGFloat}</code></pre><pre><code class="objective-c">@property(nullable, nonatomic,copy)  UIColor *backgroundColor UI_APPEARANCE_SELECTOR; @property(nonatomic)CGFloat alpha;  // animatable. default is 1.0// use bounds/center and not frame if non-identity transform. if bounds dimension is odd, center may be have fractional part@property(nonatomic) CGRect bounds;// default bounds is zero origin, frame size. animatable@property(nonatomic) CGPoint center; // center is center of frame. animatable@property(nonatomic) CGAffineTransform transform;   // default is CGAffineTransformIdentity. animatable</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIView常见动画的属性分析</title>
      <link href="/2018/09/16/UIView%E5%B8%B8%E8%A7%81%E5%8A%A8%E7%94%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/16/UIView%E5%B8%B8%E8%A7%81%E5%8A%A8%E7%94%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="实现动画的三步曲"><a href="#实现动画的三步曲" class="headerlink" title="实现动画的三步曲"></a>实现动画的三步曲</h1><ul><li>设置视图的动画初始状态</li><li>添加视图的动画相应属性</li><li>设置视图的动画最终状态</li></ul><h1 id="UIView常见动画的属性分析"><a href="#UIView常见动画的属性分析" class="headerlink" title="UIView常见动画的属性分析"></a>UIView常见动画的属性分析</h1><p>UIView常见的属性有哪些？</p><h2 id="位置属性-frame-bounds-center"><a href="#位置属性-frame-bounds-center" class="headerlink" title="位置属性 frame bounds center"></a>位置属性 <code>frame</code> <code>bounds</code> <code>center</code></h2><p><code>frame</code> <code>bounds</code> <code>center</code>都是描述<code>UIView</code>的位置属性，不同的是<code>frame</code>可以对<code>x</code> <code>y</code> <code>width</code> <code>height</code>四个属性进行操作，<code>frame</code>的<code>x</code> <code>y</code>是相对于父控件的原点来计算的，而<code>bounds</code>一般只能对<code>width</code> <code>height</code>进行操作，它的<code>x</code> <code>y</code> 坐标只相对于自身而言，<code>center</code>描述的是<code>x</code> <code>y</code>信息，即<code>UIView</code>的中心位置。</p><ul><li>swift版</li></ul><pre><code class="swift">public struct CGRect {    public var origin: CGPoint    public var size: CGSize    public init()    public init(origin: CGPoint, size: CGSize)}</code></pre><ul><li>OC版</li></ul><pre><code class="Objective-c">/* Rectangles. */struct CGRect {    CGPoint origin;    CGSize size;};typedef struct CG_BOXABLE CGRect CGRect;</code></pre><p>再来看三者的数据类型。<code>frame</code>是<code>CGRect</code>类型，它是一个结构体，在结构体中包含<code>origin</code>,<code>size</code>两个属性，其中<code>origin</code>描述UIView的<code>x</code>,<code>y</code>坐标起点位置信息。<code>size</code>描述UIView的<code>width</code>、<code>height</code>宽高信息，我们再来看看<code>origin</code>的<code>CGPoint</code>和<code>size</code>的<code>CGSize</code> 又是什么？</p><ul><li>swift版</li></ul><pre><code class="swift">/* Points. */public struct CGPoint {    public var x: CGFloat    public var y: CGFloat    public init()    public init(x: CGFloat, y: CGFloat)}</code></pre><pre><code class="swift">/* Sizes. */public struct CGSize {    public var width: CGFloat    public var height: CGFloat    public init()    public init(width: CGFloat, height: CGFloat)}</code></pre><ul><li>OC版</li></ul><pre><code class="objective-c">/* Points. */structCGPoint {    CGFloat x;    CGFloat y;};typedef struct CG_BOXABLE CGPoint CGPoint;</code></pre><pre><code class="objective-c">/* Sizes. */struct CGSize {    CGFloat width;    CGFloat height;};typedef struct CG_BOXABLE CGSize CGSize;</code></pre><p><code>CGPoint</code>中包含了<code>UIView</code>的<code>x</code>,<code>y</code>坐标，而<code>CGSize</code>中包含了<code>UIView</code>的<code>widt</code>,<code>height</code>信息。通过对<code>frame</code>中的数据类型进行追本溯源，可以得到以下结论：</p><blockquote><p><code>CGRecct</code>分别对应<code>x</code>坐标，<code>y</code>坐标、<code>width</code>、<code>height</code>四个属性，这四个属性表明当前UI在它的父视图上的位置<br>可能通过<code>x</code>,<code>y</code>坐标修改<code>UIView</code>的移动位置，还可以修改<code>width</code>,<code>height</code>来修改<code>UIView</code>的拉伸、收缩效果，对于<code>bounds</code>属性使用最多的还是<code>width</code>,<code>height</code>属必，<code>center</code>则经常使用<code>x</code>,<code>y</code>坐标属性。</p></blockquote><h2 id="透明属性-alpha-透明属性，范围0-1-浮点型"><a href="#透明属性-alpha-透明属性，范围0-1-浮点型" class="headerlink" title="透明属性:alpha (透明属性，范围0-1,浮点型)"></a>透明属性:alpha (透明属性，范围0-1,浮点型)</h2><p><code>UIView</code>的<code>alpha</code>属性也可以作动画效果，当<code>alpha</code>值为0时，表明视图已经隐藏，当<code>alpha</code>值为1时，视图显示。结合这一属性可以通过修改<code>alpha</code>值在动画开始、结束时的值可以实现淡入淡出效果。</p><h2 id="Layer属性：圆角渐变，边框颜色，阴影，3D等高级动画效果"><a href="#Layer属性：圆角渐变，边框颜色，阴影，3D等高级动画效果" class="headerlink" title="Layer属性：圆角渐变，边框颜色，阴影，3D等高级动画效果"></a>Layer属性：圆角渐变，边框颜色，阴影，3D等高级动画效果</h2><p>UIView是视图显示的容器，负责内容显示和事件响应。每个视图都有一个layer图层，在这个图层中承栽的是视图的内容。所以结合layer可以实现很多高级效果。当然除了这些之外，视图还有其他属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类图</title>
      <link href="/2018/08/26/%E7%B1%BB%E5%9B%BE/"/>
      <url>/2018/08/26/%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在系统中每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类一般只有一种职责。在定义类的时候，将类的职责分解成类的属性和操作（方法）。类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。</p><p>在软件系统运行时，类将被实例化成为对象（Object）,对象对应于某个具体的事物，是类的实例（Instance）.<br>类图使用出现在系统中的不同类来描述系统的静态结构，它用于描述不同的类以及它们之间的关系。<br>在系统分析与设计阶段，类通常可以分为三种：实体类（Entity Class）、控制类（Control Class）、边界类（Boundary Class）</p><ul><li><p>实体类<br>实体类对应系统需求中每个实体，它们通常需要保存在永久的存储体中，一般使用数据库表或文件来记录。实体类包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求中的名词，如学生、商品等。</p></li><li><p>控制类<br>控制类用于体现应用程序的执行逻辑。提供相应的业务操作，将控制类抽角出来可以降低界面与数据库之间的耦合度。控制类一般由动宾结构的短语（动词+名词）转化来的名词。如增加商品对应有一个商品增加类，注册对应一个注册类等</p></li><li><p>边界类<br>边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等</p></li></ul><p>在面向对象分析与设计的初级阶段，通常首先识别出实体类，绘制出初始类图，此时的类图也可称为领域模型，包括实体类及它们之间的相互关系。</p><h1 id="类的UML图示"><a href="#类的UML图示" class="headerlink" title="类的UML图示"></a>类的UML图示</h1><p>在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示：如定义一个Person类，它包含属性<code>name</code>,<code>age</code>,<code>phone</code>以及操作<code>walk()</code>,<code>speak()</code>,<code>eat()</code>在UML类图中该类如下图所示：<br><img src="" alt=""><br>在<code>UML</code>类图中，类一般由三部臾组成：</p><ul><li>类名： 每个类都必须有一个名字，类名是一个字符串</li><li><p>类的属性（Attributes）：属性指类的性质，即类的成员变量。 一个可以有任意多个属性，也可以没有属性。<br>UML中规定属性的表示方式为：<br><code>可见性 名称 : 类型 [=缺省值]</code></p><ul><li>“可见性”表示该属性对于类外的元素是否可见。包括：公有<code>+</code>(Public)、私有<code>-</code>(Private)、和受保护<code>#</code>(protected),三种，在类图中分别用符号<code>+</code>,<code>-</code>,<code>#</code>表示</li><li>“名称”表示属性名，用一个字符串表示</li><li>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型</li><li>“缺省值”是一个可选项，即属性的初始值</li></ul></li><li><p>类的操作（Operations）:操作是类的任意一个实例对象都可以使用的行为，即类的成员方法。UML规定操作的表示方式为：<br><code>可见性 名称(参数列表):[:返回类型]</code></p><ul><li>“可见性”的定义与属性的可见性定义相同</li><li>“名称”即方法名，且一个字符串表示</li><li>“参数列表”表示方法的参数，其语法与属性的定义类似，参数的个数可以任意，多个参数之间用逗号隔“,”开</li><li>“返回类型”是一个可选项，表示方法的返回值，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是void类型</li></ul></li></ul><h1 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h1><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车与轮胎，师傅与徒弟，班级与学生。在UML类图中，使用实线连接有关联关系的对象所对应的类，通常将一个类的对象作为别一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般敷衍表示两都之间关系的动名或名词表示角色名，关系的两端代表不同的角色。因此在一个关联关系中可以包含两个角色名，角色名不是必须的，可以根据需求增加，使类之间的关系更加明确<br>关联关系通常用包含以下几种形式：</p><ul><li>双向关联<br>默认情况下，关联是双向的。如顾客购买商品并拥有商品，反之，卖出去的商品总有某个顾客与之关联。因此顾客与商品之间具有双向关联关系<br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt="双向关联实例"></li><li>单向关联<br>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。如顾客拥有地址，则顾客类与地址类具有单向关联关系<br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt="单向关联实例"></li><li>自关联<br>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象，如图4所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt="自关联实例"></li><li>多重性关联<br>多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。<br>对象之间可以存在多种多重性关联关系，常见的多重性表示方式如表1所示：<br>表1 多重性表示方式列表</li></ul><table><thead><tr><th>表示方式</th><th>多重性说明</th></tr></thead><tbody><tr><td>1..1</td><td>表示另一个类的一个对象只与该类的一个对象有关系</td></tr><tr><td>0..*</td><td>表示另一个类的一个对象与该类的零个或多个对象有关系</td></tr><tr><td>1..*</td><td>表示另一个类的一个对象与该类的一个或多个对象有关系</td></tr><tr><td>0..1</td><td>表示另一个类的一个对象没有或只与该类的一个对象有关系</td></tr><tr><td>m..n</td><td>表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</td></tr></tbody></table><p>例如：一个界面(Form)可以拥有零个或多个按钮(Button)，但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，如图5所示：<br><img src="" alt="多重性关联实例"></p><ul><li>聚合关系<br>聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如：汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图6所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt="聚合关系实例"></li><li>组合关系<br>组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如：人的头(Head)与嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图7所示：<br><img src="http://www.uml.org.cn/oobject/images/20121123110.jpg" alt="组合关系实例"></li></ul><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>依赖(Dependency)关系是一种使用关系，特定事物的改变可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下依赖关系体现在某人类的方法使用了另外一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如：驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为一个参数传递，以便在drive()方法中能够调用car的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此类Driver依赖类Car，如图1所示：<br><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt="依赖关系实例"></p><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>泛化(Generalization)关系也是继承关系，用于描父类与子类的关系。父类又称基类或超类，子类又称派生类。在UML中，泛化关系用带空心的三角形直线表示。</p><h2 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h2><p>在很多面向对象语言中都引入了接口的概念，如Java、C#等，在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口。<br>接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示</p>]]></content>
      
      
      
        <tags>
            
            <tag> 类图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runloop</title>
      <link href="/2018/07/12/Runloop/"/>
      <url>/2018/07/12/Runloop/</url>
      
        <content type="html"><![CDATA[<p>转载来源： <a href="https://www.zybuluo.com/qidiandasheng/note/346387" target="_blank" rel="noopener">https://www.zybuluo.com/qidiandasheng/note/346387</a></p><h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><p>什么是Runloop</p><blockquote><p>简单点说就是一个do while的运行循环。主要的作用就是保持程序的持续运行。比如主线程的runloop从程序打开就一直在运行。一个线程对应着一个runloop。RunLoop在第一次获取时创建，在线程结束时销毁。</p></blockquote><p><img src="runloop.png" alt="runloop"></p><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><ul><li><p>为什么使用Runloop</p><ul><li>使程序一直运行并接受用户输入</li><li>决定程序在何时应该处理哪些Event</li><li>调节解耦（Message Queue）<br>  也就是主调方把消息放入一个队列，被调方只要去这个队列里取就行了。</li><li>节省CPU时间<br>  Runloop在没有事的时候会进入一个休眠状态，不会让CPU一直在运行程序。</li></ul></li><li><p>CFRunLoopSource<br>  Source是RunLoop的数据源抽象类,类似IOS中的protocol<br>  RunLoop定义两个Version的Source</p><p>  Source0:处理App内部事件,App自己负责管理(触发),如UIEvent,CFSocket<br>  Source1:由RunLoop和内核管理,Mach port驱动 如CFMach、CFMessage</p></li><li><p>CFRunLoopObserver<br>  向内部报告RunLoop当前状态的更改 CAAnimation</p></li><li><p>RunLoopObserver 与 Autorelease Pool<br>  UIKit通过RunLoopObserver在RunLoop两次Sleep间对AutoreleasePool进行pop和push,将这次Loop中产生的Autorelease对象释放。</p></li><li><p>RunLoop的挂起与唤醒</p><blockquote><p>制定用于唤醒的mach_port端口<br>  调用mach_msg监听唤醒端口,被唤醒前,系统内核将这个线程挂起,停留在mach_msg_trap<br>  由另外一个线程(或另一个进程中的某个线程)向内核发送这个端口的msg后,trap状态被唤醒,RunLoop继续开始干活</p></blockquote></li></ul><ul><li><p>CFRunLoopMode</p><blockquote><p>RunLoop在同一时段只能且必须在一种特定Mode下Run<br>更换Mode时, 需要暂停当前的Loop,然后重启新的Loop</p><pre><code>      NSDefalutRunLoopMode      默认状态.空闲状态       UITrackingRunLoopMode     滑动ScrollView       UIInitializationRunLoopMode    私有,App启动时       NSRunLoopCommonModes     默认包括上面第一和第二</code></pre></blockquote></li><li><p>UITrackingRunLoopMode 与 NSTimer</p><blockquote><p>默认情况下NSTimer被加入NSDefalutRunLoopMode </p><pre><code>如果不想NSTimer受到组件或者动画影响 添加到NSRunLoopCommonModes</code></pre></blockquote></li><li><p>RunLoopMode在滑动时切换</p><blockquote><p>NSDefaultRunLoopMode-&gt;UITrackingRunLoopMode-&gt;NSDefalutRunLoopMode</p></blockquote></li><li><p>Runloop跟GCD的关系</p><blockquote><p>GCD中dispatch到main queue的block被分发到main Runloop中执行。dispatch_after同理。</p></blockquote></li><li><p>Runloop内部结构<br>NSRunloop其实是对CFRunloop的一层封装。CFRunloop是开源的，开源地址CF Source。<br><img src="runloopstruct.png" alt="runloop struce"></p></li></ul><p>下面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><p>CFRunLoopSourceRef</p><p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p><p>CFRunLoopTimerRef</p><p>CFRunLoopTimerRef是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><p>CFRunLoopObserverRef</p><p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p><pre><code>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop};</code></pre><p>主线程几乎所有的函数都是从以下几个函数调起，这些很长的函数我们能在程序运行时打断点在左侧的调用栈中看到：</p><pre><code>{    /// 1. 通知Observers，即将进入RunLoop    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);    do {        /// 2. 通知 Observers: 即将触发 Timer 回调。        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);        /// 4. 触发 Source0 (非基于port的) 回调。        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);        /// 6. 通知Observers，即将进入休眠        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);        /// 7. sleep to wait msg.        mach_msg() -&gt; mach_msg_trap();        /// 8. 通知Observers，线程被唤醒        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);        /// 9. 如果是被Timer唤醒的，回调Timer        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);    } while (...);    /// 10. 通知Observers，即将退出RunLoop    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);}</code></pre><p>Runloop的实际使用<br>Runloop常用的场景有以下几种：NSTimer，PerformSelector，常驻线程。</p><p>常驻线程<br>常驻线程的应用场景:经常在后台进行耗时操作,如:监控联网状态，扫描沙盒等 不希望线程处理完事件就销毁，保持常驻状态比如AFNetworking 2.0等。</p><p>Runloop常驻线程等待block回调成功</p><pre><code>__block NSString* result = nil;__block BOOL isExecuted = NO;[(WKWebView*)self.realWebView evaluateJavaScript:javaScriptString completionHandler:^(id obj, NSError* error) {    result = obj;    isExecuted = YES;}];while (isExecuted == NO) {    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];}return result;__block NSString* result = nil;[(WKWebView*)self.realWebView evaluateJavaScript:javaScriptString completionHandler:^(id obj, NSError* error) {    result = obj;    CFRunLoopStop(CFRunLoopGetMain());}];CFRunLoopRun();return result;</code></pre><p>保持子线程线程常驻例子</p><p>1.设置成全局的，如果是线程对象是局部的就会死掉</p><p>@property (nonatomic,strong) NSThread *thread;<br>2.初始化线程并启动</p><p>self.thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];<br>[self.thread start];<br>3.启动RunLoop，子线程的RunLoop默认是停止的</p><p>在线程的入口处我们需要创建一个Autorelease Pool，当线程退出的时候释放这个Autorelease Pool。这样在线程中创建的autorelease对象就可以在线程结束的时候释放，避免过多的延迟释放造成程序占用过多的内存。如果是一个长寿命的线程的话，应该创建更多的Autorelease Pool来达到这个目的。</p><pre><code>//只要往RunLoop中添加了  timer、source或者observer就会继续执行，一个Run Loop通常必须包含一个输入源或者定时器来监听事件，如果一个都没有，Run Loop启动后立即退出。- (void)run{    @autoreleasepool {        //添加一个input source        [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];        [[NSRunLoop currentRunLoop] run];        //或者添加一个定时器        //NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];        //[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];        //[[NSRunLoop currentRunLoop] run];    }}</code></pre><p>4.利用常驻线程处理事情</p><p>这样thread这个线程就会一直存在，当需要使用此线程处理一些事情的时候就这么调用</p><pre><code>[self performSelector:@selector(action) onThread:self.thread withObject:nil waitUntilDone:NO ];</code></pre><p>NSTimer<br>NSTimer也是在面试中提及Runloop的时候会被问到的问题。<br>详情可以看我的另一篇文章：NSTimer需要注意的地方</p><p>PerformSelecter<br>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>Table View延迟加载图片<br>这个问题是有的TableView有大量图片（比如头像）加载，在滑动的时候，请求网络，下载完图片之后设置的时候会卡，往常的解决方案一般是添加delegate之类的，检测什么时候滑动结束什么时候去设置图片</p><p>在知道RunLoop之后，可以采用下面的方案，在DefaultMode去做，这样滑动的时候就不会调用设置图片方法.</p><pre><code>UIImage *downLoadImage = ...;  [self.avatarImageView performSelector:@selector(setImage:)                         withObject:downloadImage                          afterDelay:0                          inModes:@[NSDefaultRunLoopMode]];</code></pre><p>让Crash的APP回光返照<br>我这里有个Demo就是写Signal信号崩溃时，使用手动重启Runloop不使程序崩溃，并弹出Alert。DSSignalHandlerDemo。</p><p>主要代码就是以下这段：</p><pre><code>CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);while (!dismissed){    for (NSString *mode in (__bridge NSArray *)allModes)    {        //为阻止线程退出，使用 CFRunLoopRunInMode(model, 0.001, false)等待系统消息，false表示RunLoop没有超时时间        CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);    }}CFRelease(allModes);</code></pre><p>Async Test Case<br>原来在写Test Case 的时候不支持异步。然后这里有个方法就是使用runloop的CFRunLoopObserver来监听runloop快要sleep的时候，去验证这个异步。</p><p>如何查看Runloop的调试栈信息<br>你直接打开xcode，运行一下程序，然后打个断点暂停一下，我们就能看到从main函数后面马上调起了唤起了Runloop。这个Runloop是跟随着程序一直存在的，是主线程的runloop。我们看一下截图：</p><p>Autorelease对象什么时候释放<br>Runloop是一个运行循环，但是它不可能一直运行着，所以它会有一个休眠期。Runloop维护着一个AutoreleasePool，当它进入休眠前它会把这个释放池里的对象进行释放。</p><p>UIKit通过RunLoopObserver在RunLoop两次Sleep间对AutoreleasePool进行pop和push,将这次Loop中产生的Autorelease对象释放。</p><p>所以说以下这样的例子会对性能是有影响的：</p><pre><code>//这里大量的循环，Runloop又还没进入休眠状态，所以就会产生大量的Autorelease对象。for (int i = 0; i &lt; 100000000; i++){    NSString* string = @&quot;ab c&quot;;    NSArray* array = [string componentsSeparatedByString:string];}//我们可以手动的给它加@autoreleasepool{}，在每次循环后都进行一次释放。for (int i = 0; i &lt; 100000000; i++){    @autoreleasepool    {        NSString* string = @&quot;ab c&quot;;        NSArray* array = [string componentsSeparatedByString:string];    }}</code></pre><p>那一般什么时候Runloop会进入休眠呢?</p><p>我们这里看一个简单的例子，就是主线程的Runloop在刚进入一个ViewController的时候什么时期进入休眠。</p><p>先看下面一段代码：</p><pre><code>- (void)viewDidLoad{    [super viewDidLoad];    NSString *string = [NSString stringWithFormat:@&quot;齐滇大圣&quot;];}</code></pre><p>这里[NSString stringWithFormat:@”齐滇大圣”];创建对象时这个对象的引用计数为 1 。当使用局部变量 string 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而当 viewDidLoad 方法返回时，局部变量 string 被回收，指向了 nil 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p><p>然后我们的这个对象是一个autorelease的实例，是被系统自动添加到了当前的 autoreleasepool 中的。所以会当Runloop一次迭代结束即将进入休眠的时候autoreleasepool drain对象引用计数 -1，对象释放。</p><p>下面我们配合着堆栈信息看一下这个Runloop什么时候结束一次迭代。</p><p>这里我们加入一个<strong>weak的全局变量reference来指向我们的对象。因为</strong>weak引用不持有我们的对象，不会影响所指向对象的生命周期，所以我们用它来输出以判断我们的对象什么时候释放。</p><p>我们能看到reference在viewDidLoad和viewWillAppear的时候有输出，而在viewDidAppear的时候为null，说明被释放了。那我们来猜测一下runloop的迭代周期。</p><p>viewWillAppear很容易理解是即将进入页面嘛，那runloop肯定是还有事要做的嘛，当viewDidAppear的时候表示已经进入页面了。那就表示没事做了，进入睡眠，等待用户动作的时候再次唤醒。你可能会觉得我口说无凭不靠谱，好那我就拿出证据来，我们来看下面两张图。</p><p>断点1和断点2：</p><p>断点3</p><p>我们能看到断点1和断点2 runloop还是在执行的，断点3表示runloop一个迭代已经结束了，即将进入睡眠。</p><pre><code>//触发 Source0 (非基于port的) 回调。__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);//out_to_block表示从block跳出，block执行完毕，即将进入睡眠。__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</code></pre><p>参考文章<br><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">iOS线下分享《RunLoop》</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SMShareModel</title>
      <link href="/2018/04/03/SMShareModel/"/>
      <url>/2018/04/03/SMShareModel/</url>
      
        <content type="html"><![CDATA[<h1 id="SMShareModel-简介"><a href="#SMShareModel-简介" class="headerlink" title="SMShareModel 简介"></a>SMShareModel 简介</h1><p>该分享模块是一个相对独立的功能模块，主要负责内容分享. 目前可分享的平台如下：</p><ul><li><code>whatsapp</code>、<code>facebook</code>、<code>Instagram</code>、<code>Messenager</code>、<code>Twitter</code></li><li><code>Message(短信)</code>、<code>Email</code>、<code>CopyLink</code>、<code>More</code>、</li><li><code>StartMarker</code>、<code>Friends</code>   </li></ul><p>分享类型：</p><ol><li>普通分享</li><li>强分享</li><li>h5分享</li></ol><h2 id="代码目录结构"><a href="#代码目录结构" class="headerlink" title="代码目录结构"></a>代码目录结构</h2><pre><code class="c">.├── SMH5UploadShare(web分享)│   ├── SMH5GuideShareScollerView │   ├── SMH5GuideShareViewController │   ├── SMH5UploadShareScollerView │   ├── SMH5UploadViewController │   ├── SMWebGuideTopShareView │   ├── SMWebShareDataSource │   └── SMWebShareItemModel ├── SMShare│   ├── SMCustomShareView │   ├── SMShareCompetitionActivitiesInfoModel │   ├── SMShareDynamicConfigurationModel │   ├── SMShareFriendsModel │   ├── SMShareFriendsViewController │   ├── SMShareFriensDataSource │   ├── SMShareFriensTableViewCell │   ├── SMShareItemModel │   ├── SMShareItemSucessState │   ├── SMShareList.plist│   ├── SMShareManager │   ├── SMShareScrollView │   ├── SMShareVideoDownloadProgressView │   ├── SMShareVideoDownloadTransitionAnimator │   ├── SMShareVideoDownloadViewController │   └── SMShareWebService ├── SMShareAPIUI│   ├── SMShareActivityGuideView │   ├── SMShareActivityGuideViewController │   ├── SMShareInstrumentLikesView │   ├── SMShareItemButton │   ├── SMShareOrdinaryContentView │   ├── SMShareOrdinaryView │   ├── SMShareOrdinaryViewController │   ├── SMShareToChannelModel │   ├── SMShareViewController │   ├── SMStrongShareCell+Rate │   ├── SMStrongShareCell+ad │   ├── SMStrongShareCell+winIpad │   ├── SMStrongShareCell │   ├── SMStrongShareHeaderView │   ├── SMStrongShareViewController │   └── SMStrongShareWinIpadView ├── SMShareBounced│   ├── SMShareBouncedView │   └── SMShareBouncedViewController├── SMShareManager(核心)│   ├── SMMFMessageViewController │   ├── SMShareAPIContent │   ├── SMShareAPIManager │   ├── SMShareHelper│   │   ├── SMShareAppContentManager │   │   ├── SMShareContentHelper │   │   └── SMShareHelper │   └── SMShareTypeDefine ├── SMShareModel│   ├── SMShareFromContent │   ├── SMShareTrackModel │   ├── SMStrongShareDataSource │   └── SMStrongShareModel ├── SMSharePublishSuccess（发布成功后的分享视图）│   ├── SMActivityPublishView │   ├── SMSharePublishErrorView │   ├── SMSharePublishFailureView │   ├── SMSharePublishSuccessView │   └── SMSharePublishView └── SMStrongShare(强分享)    ├── Controller    │   ├── SMStrongChorusViewController     │   └── SMStrongSoloViewController     ├── Model    │   ├── SMShareStrongSoloItemModel     │   └── SMStrongChorusDataSource    └── View        ├── SMStrongChorusHeadView         ├── SMStrongChorusNaverView         ├── SMStrongScollerView         ├── SMStrongSoloExcellentShareView         └── SMStrongSoloOrdinaryShareView</code></pre><p>主要使用对象类：</p><ol><li>公共分享控件<ul><li>SMShareOrdinaryViewController （目前使用该接口）</li><li>SMShareViewController（未来将使用这个入口）</li><li>SMShareFriendsViewController（好友私信分享）</li><li>SMStrongSoloViewController/SMStrongChorusViewController(独唱/合唱分享入口)</li></ul></li><li>分享管理<ul><li>SMShareAPIManager</li></ul></li><li>SMShareTypeDefine 类型定义<br> 该类中主要定义了一些公共的枚举数据类型：<ol><li>分享平台（SMSharePlatformType）</li><li>分享内容类型（SMShareContentType）</li><li>分享状态（SMShareResponseState）</li></ol></li><li>数据模型<ul><li>SMShareAPIContent</li><li>SMShareItemModel（要分享的数据内容对象）</li></ul></li></ol><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="分享控件接口"><a href="#分享控件接口" class="headerlink" title="分享控件接口"></a>分享控件接口</h3><h4 id="普通分享"><a href="#普通分享" class="headerlink" title="普通分享"></a>普通分享</h4><ol><li><p>SMShareOrdinaryViewController</p><pre><code class="objc">     - (instancetype)initWithShareItme:(SMShareItemModel *)aItemModel                             returnBack:(ReturnBack)returnBack; /**  SMShareModuleTypeVipInvite 这种类型才需要外部赋值 */ - (instancetype)initWithShareItem:(SMShareItemModel *)aItemModel                     inviteAPIContent:(SMShareAPIContent *)apiContent                         returnBack:(ReturnBack)returnBack;  </code></pre></li><li><p>SMShareViewController</p><pre><code class="objc">  /**     自定义分享     目前只支持已知的分享平台类型,之后会增加自定义分享平台的逻辑     @param shareItems     分享按钮的item     例如:     {     shareTitle:@&quot;Copy Link&quot;,     shareImage:@&quot;CopylinkImage&quot;,     shareHighlightedImage:@&quot;CopylinkImage&quot;,     }     @param shareContent 分享的内容     @param returnBack     @return     */     - (instancetype)initWithShareItems:(NSMutableArray &lt;NSDictionary *&gt;*)shareItems                         shareContent:(SMShareAPIContent *)shareContent                             returnBack:(ReturnBack)returnBack;</code></pre><h4 id="强分享"><a href="#强分享" class="headerlink" title="强分享"></a>强分享</h4></li><li><p>SMStrongSoloViewController（独唱分享）</p><pre><code class="objc"> @interface SMStrongSoloViewController : SMSNSBaseViewController //视频是否可以分享的状态 @property (assign, nonatomic) BOOL isShareVideoState; - (instancetype)initWithShareStrongSoloItemModel:(SMShareStrongSoloItemModel *)itemModel                                     returnBlock:(ReturnBlock)returnBlock; @end</code></pre></li><li><p>SMStrongChorusViewController（合唱分享） </p><pre><code class="objc"> @interface SMStrongChorusViewController : SMSNSBaseViewController //视频是否可以分享的状态 @property (assign, nonatomic) BOOL isShareVideoState; - (instancetype)initWithShareStrongSoloItemModel:(SMShareStrongSoloItemModel *)itemModel                         returnBlock:(ReturnBlock)returnBlock; @end</code></pre><h3 id="SMShareAPIManager"><a href="#SMShareAPIManager" class="headerlink" title="SMShareAPIManager"></a>SMShareAPIManager</h3><p> 该分享管理器提供了各平台单独的分享内容接口，在使用过程中调用相应的方法并传入正确的参数即可。</p></li></ol><pre><code class="objc">    /**    分享 (目前这个是支持的旧的分享 随时可能废弃 如果要调用分享建议使用下面的方法)    @required aContent 分享的内容    @param aContentType 分享内容的类型 (目前只有Instagram 需要区分分享图片或者视频 其他分享平台暂时未用到可以使用SMShareContentTypeAuto)    @param aPlatformType 分享平台类型    @required fromViewController 当前控制器    @param aStateChangedHandler 返回结果    */    - (void)initWithShareContent:(SMShareAPIContent *)aContent                shareItemModel:(SMShareItemModel *)aShareItemModel            fromViewController:(UIViewController *)aFromViewController        popPresenterSourceView:(UIView *)aSourceView                    platformType:(SMSharePlatformType)aPlatformType                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    分享    @required aContent 分享的内容    @required aFromViewController 当前的viewController    @required aSourceView 当前的来源视图    @param aPlatformType 分享平台类型    @param aStateChangedHandler 返回结果    */    - (void)initWithShareContent:(SMShareAPIContent *)aContent            fromViewController:(UIViewController *)aFromViewController        popPresenterSourceView:(UIView *)aSourceView                    platformType:(SMSharePlatformType)aPlatformType                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    whatsApp分享    @required message 分享内容 需要用到shareTitle + shareLink    */    - (void)shareWhatsAppWithShareContent:(SMShareAPIContent *)aContent                        onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    Facebook分享    @required aContent  shareLink + shareHashtag (link 为必需的 hastag 可选)    @required fromViewController 当前控制器    @param aStateChangedHandler    */    - (void)shareFacebookWithOpenGraphContent:(SMShareAPIContent *)aContent                        fromViewController:(UIViewController *)fromViewController                            onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    Messenger分享    @required aContent shareLink    @param aStateChangedHandler    */    - (void)shareMessengerWithOpenGraphContent:(SMShareAPIContent *)aContent                                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    Instagram分享    @required aContent 图片地址 shareVieoURL 或者 视频    @param aStateChangedHandler    */    - (void)shareInstagramWithContent:(SMShareAPIContent *)aContent                    onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    分享到 Twitter    @required aContent shareTitle +  shareLink +  shareImageURL (必须保证至少一个不是空的)    @param aStateChangedHandler     */    - (void)shareTwitterContent:(SMShareAPIContent *)aContent                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    分享到短信    @required aContent shareTitle + shareLink    @required fromViewController    @param aStateChangedHandler    */    - (void)shareTextWithContent:(SMShareAPIContent *)aContent            fromViewController:(UIViewController *)fromViewController                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    /**    分享到邮件    @required aContent shareTitle + shareLink + shareDescription    @required fromViewController    @param state    */    - (void)shareEMailWithContent:(SMShareAPIContent *)aContent            fromViewController:(UIViewController *)fromViewController                onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    // 自动发布facebook    - (void)automaticShareFacebookWithOpenGraphContent:(SMShareAPIContent *)aContent                                        onStateChanged:(SMShareCallApiStateChangedHandler)aStateChangedHandler;    // 当前的FB自动发布权限是否可用    + (BOOL)isFacebookShareHasGranted;    // 获取当前的FB自动发布权限    + (void)facebookShareHasGrantedWithViewController:(UIViewController *)aFromViewController                                    onStateChanged:(SMFacebookSyncToState)aStateChangedHandler;    // 删除facebook上传权限 (PM 要求内部控制删除权限 不走facebook的删除权限接口 但是已经实现 如果需要可以把注释掉的内容打开)    + (void)facebookDeletePublishactionOnStateChanged:(SMFacebookSyncToState)aStateChangedHandler;    // 判断Twitter是否登陆    + (void)isTwitterLogin:(SMShareTwitterState)state;</code></pre><h3 id="SMShareAPIContent-（分享内容模型）"><a href="#SMShareAPIContent-（分享内容模型）" class="headerlink" title="SMShareAPIContent （分享内容模型）"></a>SMShareAPIContent （分享内容模型）</h3><ol><li>属性<br> <code>`</code>objc<br> @property (copy, nonatomic) NSString <em>shareRecordingId; //分享的唯一标识  不要重复<br> @property (assign, nonatomic) SMShareContentType shareContentSourceType; //之后会废弃这个字段<br> @property (copy,  nonatomic) NSString </em>shareTitle; //分享标题<br> @property (copy,  nonatomic) NSString <em>shareDescription; // 分享内容<br> @property (copy,  nonatomic) NSString </em>shareType; //分享类型 invite ，打点使用<br> @property (assign, nonatomic) SMShareContentType shareContentType; //分享内容类型<br> @property (copy,  nonatomic) NSString <em>shareLink; //分享链接<br> @property (copy,  nonatomic) NSString </em>shareImageURL;//分享图片<br> @property (copy,  nonatomic) NSString <em>shareVieoURL;//分享视频下载地址<br> @property (copy,  nonatomic) NSString </em>shareVideoPath;//分享视频本地地址<br> @property (copy,  nonatomic) NSString <em>shareHashtag; //分享Hashtag<br> @property (assign, nonatomic) BOOL isShareVideoType; // 是否是分享视频<br> @property (assign, nonatomic) NSInteger shareIspublic;//是否是私密状态<br> @property (copy, nonatomic) NSString </em>isContested;//是否是参赛作品 1，参赛 0，未参赛</li></ol><pre><code>/***************************************** 以下为IM分享携带信息* 如果可以取到信息请尽量传入避免之后请求*****************************************/@property (strong,  nonatomic) SMShareFromContent *fromContent; //分享发送方信息@property (copy, nonatomic) NSString *shareSingID;//分享作品歌手id@property (copy, nonatomic) NSString *shareSingName;//分享作品歌手名字@property (copy, nonatomic) NSString *shareSingCover;//分享作品歌手头像url@property (assign, nonatomic) BOOL isVerified;//分享作品歌手是否是认证歌手@property (nonatomic,assign) NSInteger  isRecordingPublic;//是否是我创建的作品```</code></pre><p>便捷方法：</p><pre><code class="objc">- (instancetype)initWithShareContentTitle:(NSString *) aTitle                              description:(NSString *) aDescription                              recordingId:(NSString *) aRecordingId                                     link:(NSString *) aLink                                 imageURl:(NSString *) aImageUrl                                 videoURL:(NSString *) aVideoUrl                                  hashtag:(NSString *) ahashtag                              contentType:(SMShareContentType) aContentType;</code></pre><h3 id="SMShareHelper"><a href="#SMShareHelper" class="headerlink" title="SMShareHelper"></a>SMShareHelper</h3><p>   根据title获取分享平台类型 、获取全部分享平台类型 、分享私信好友状态是否可用等功能接口</p><pre><code>    /**    根据返回传入item的title，获取分享平台类型    @param title 分享的title    @return 分享平台类型    */    + (SMSharePlatformType)getShareTypeForTitle:(NSString *)title;    /**    根据分享平台类型返回分享平台名字    @param aPlatformType 分享平台类型    @return 平台名字    */    + (NSString *)channelWithPlatformType:(SMSharePlatformType)aPlatformType;    /**    根据分享平台类型配置link 规则：link + shareType + appName    @param link 分享的链接    @param shareType 分享类型    @return 返回配置后的分享URL    */    + (NSString *)shareTitleInfoCombinationLink:(NSString *)link shareType:(SMSharePlatformType)shareType;    /**    获取可分享平台的Items    @param songId 判断当前分享歌曲是否在在白名单内，如果不在会默认不显示Instagram分享平台 （如果不要做这个判断直接传空）    @param imageName 是否需要替换不同的More图片 （因为项目中多个地方使用了不同的moreIcon图片，所以特别加这个接口.如果不需要替换可以不传会显示默认icon）    @return 返回生产的分享平台的Items信息    */    + (NSMutableArray *)shareItemArrayIsCanShareSongID:(NSString *)songId                                    andMoreImageName:(NSString *)imageName                                        hideInstagram:(BOOL)hideInstagram;    + (NSMutableArray *)shareItemKtvAndLiveArrayMoreImageName:(NSString *)imageName;    /**    增加点击分享平台数量    @param aPlatformType 平台    */    + (void)writeToFile:(SMSharePlatformType)aPlatformType;    /**    根据分享返回结果返回分享结果    @param responseState 分享返回的结果    @return 结果的描述    */    + (NSString *)resultWithResponseState:(SMShareResponseState)responseState;    /**    分享私信是否可用    @return    */    - (BOOL)isShareThroughChat;    /**    获取分享应用下载link    starmaker 和 the voice 使用旧的链接不进行修改    印度和印尼以及以后的app链接 遵守（ https://m.singit.vip/download + apptype） 规则 具体参考：T23035    @return    */    + (NSString *)getShareAppDownloadLink;/**    根据返回传入item的title，获取分享平台类型    @param title 分享的title    @return 分享平台类型    */    + (SMSharePlatformType)getShareTypeForTitle:(NSString *)title;    /**    根据分享平台类型返回分享平台名字    @param aPlatformType 分享平台类型    @return 平台名字    */    + (NSString *)channelWithPlatformType:(SMSharePlatformType)aPlatformType;    /**    根据分享平台类型配置link 规则：link + shareType + appName    @param link 分享的链接    @param shareType 分享类型    @return 返回配置后的分享URL    */    + (NSString *)shareTitleInfoCombinationLink:(NSString *)link shareType:(SMSharePlatformType)shareType;    /**    获取可分享平台的Items    @param songId 判断当前分享歌曲是否在在白名单内，如果不在会默认不显示Instagram分享平台 （如果不要做这个判断直接传空）    @param imageName 是否需要替换不同的More图片 （因为项目中多个地方使用了不同的moreIcon图片，所以特别加这个接口.如果不需要替换可以不传会显示默认icon）    @return 返回生产的分享平台的Items信息    */    + (NSMutableArray *)shareItemArrayIsCanShareSongID:(NSString *)songId                                    andMoreImageName:(NSString *)imageName                                        hideInstagram:(BOOL)hideInstagram;    + (NSMutableArray *)shareItemKtvAndLiveArrayMoreImageName:(NSString *)imageName;    /**    增加点击分享平台数量    @param aPlatformType 平台    */    + (void)writeToFile:(SMSharePlatformType)aPlatformType;    /**    根据分享返回结果返回分享结果    @param responseState 分享返回的结果    @return 结果的描述    */    + (NSString *)resultWithResponseState:(SMShareResponseState)responseState;    /**    分享私信是否可用    @return    */    - (BOOL)isShareThroughChat;    /**    获取分享应用下载link    starmaker 和 the voice 使用旧的链接不进行修改    印度和印尼以及以后的app链接 遵守（ https://m.singit.vip/download + apptype） 规则 具体参考：T23035    @return    */    + (NSString *)getShareAppDownloadLink;</code></pre><p>目录结构存在的问题(<strong>已修复</strong>)：</p><ol><li>SMSharePublisthSuccess 代码存放目录不对</li><li>SMStrongShare 存放目录不对  </li><li>SMShare 代码存放目录不对</li></ol><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol><li><a href="https://phabricator.ushow.media/T22065" target="_blank" rel="noopener">https://phabricator.ushow.media/T22065</a></li><li>单个文件目录下的文件太多，按不同类型的功能类分成不同的子文件夹</li><li>SMSNSManager 与SMShareAPIManager在功能上有相似的地方 ,该模块可以去除SMSNSManager相关方法的使用，改用SMShareAPIManager</li><li>独/合唱 使用的是旧接口，可以考虑使用新的分享接口替换</li><li>存在循环引用问题，dealloc方法一直没有走</li></ol><p>疑问：<br>该模块引入的SNS模块和SSMLoginManager，主要意图是啥？ </p><p>Q： 我们项目中很多视图控制器都重写了init方法，如果我们的视图控制器由xib/sb加载，则这个方法是不会走的。 </p><p>补充：</p><ol><li>在项目中隐藏系统的导航栏<pre><code> - (void)viewWillAppear:(BOOL)animated {     [super viewWillAppear:animated];     [self.navigationController setNavigationBarHidden:YES animated:NO]; }   </code></pre> 这样在push页面过程中导航栏会出黑色<br> 建议把这个动画打开<pre><code> - (void)viewWillAppear:(BOOL)animated {     [super viewWillAppear:animated];     [self.navigationController setNavigationBarHidden:YES animated:YES]; }  </code></pre><h2 id="改进的地方"><a href="#改进的地方" class="headerlink" title="改进的地方"></a>改进的地方</h2></li><li>项目中代码的逻辑目录需要有对应的物理文件夹</li><li>将代码按不同的功能模块归纳到相应的目录下</li><li>重复使用的代码可以考虑提取成一个方法，供使用</li><li>一个代码文件里的代码可以按不同的方法类型 使用 <code>#pragma mark  -</code>进行归纳区分，方便阅读</li><li>项目中的注释有点少，.h文件里的接口加上相应的注释，有利于自己和他们阅读与理解</li></ol><p>参考文档：<br><a href="https://phabricator.ushow.media/w/starmaker/ios/ios_sharesdk%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener">ShareSDK</a><br><!-- # h5活动(web) --><br><!-- <img src="/2018/04/03/SMShareModel/publishsuccess1.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/publishsuccess2.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMStrongShare1.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMStrongShare2.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMStrongShare3.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMShare1.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMShare2.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMShare3.png" title="代码实际位置"><br>    <img src="/2018/04/03/SMShareModel/SMShare4.png" title="代码实际位置">  –&gt;</p>--></p>]]></content>
      
      
      
        <tags>
            
            <tag> ushow </tag>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/31/hello-world/"/>
      <url>/2018/03/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English－UINIT1</title>
      <link href="/2018/03/31/English-Level2-UINIT1/"/>
      <url>/2018/03/31/English-Level2-UINIT1/</url>
      
        <content type="html"><![CDATA[<h2 id="动名词和不定式"><a href="#动名词和不定式" class="headerlink" title="动名词和不定式"></a>动名词和不定式</h2><p>动名词和不定式用于谈论复杂的观点。动名词由 -ing 构成，不定式由 to 加动词构成。有些动词后面既可用动名词，也能用不定式。</p><a id="more"></a><p><strong>动名词（动词 + -ing）：</strong></p><pre><code>Oscar enjoys cooking dinner for Frank.    Oscar 喜欢为 Frank 做饭。</code></pre><p><strong>不定式（to + 动词）：</strong></p><pre><code>Frank plans to eat out.    Frank 打算外出吃饭。</code></pre><p>有的动词后面只能接动名词，有的动词则只能接不定式。有的动词既可以接动名词，也可以接不定式。</p><p>这些动词只能后接不定式：</p><pre><code>plan        打算，计划               We&#39;re planning to go to the soccer game.    我们计划去看足球赛。want    想要We want to see the play in the park this week.    我们本周想去公园看戏。                                  need    需要I need to get some money for the concert.    我需要为音乐会准备一点钱。</code></pre><p>这些动词只能后接动名词：</p><pre><code>enjoy            享受，喜爱                                                                                               I enjoy listening to music.      我喜欢听音乐。keep    继续Martin kept playing his guitar until midnight.    马丁一直不停地弹吉他，直至午夜。think about     思考，考虑We&#39;re thinking about going to a concert.    我们在考虑去听音乐会。</code></pre><p>这些动词可后接动名词或不定式：</p><pre><code>like    喜欢I like going to musicals.    我喜欢听音乐剧。I like to go to musicals.    我喜欢听音乐剧。love    非常喜欢，热爱Joan loves eating in restaurants.    Joan 喜欢在餐馆吃饭。Joan loves to eat in restaurants.    Joan 喜欢在餐馆吃饭。begin    开始It began to snow.    开始下雪了。It began snowing.    开始下雪了。</code></pre><h2 id="表达能力"><a href="#表达能力" class="headerlink" title="表达能力"></a>表达能力</h2><p>使用单词 can 搭配动词描述能力。</p><pre><code>John can drive.         John 会开车。</code></pre><p>Can 有两种否定形式：can’t 和 cannot，它们意思相同。  </p><pre><code>I can&#39;t speak Spanish.         我不会讲西班牙语。I cannot speak Spanish.            我不会讲西班牙语。</code></pre><p>Can 在句中通常不重读，Can’t 通常重读。聆听句中两个单词的发音。注意 Can 说得很快。</p><pre><code>I can play tennis.         我会打网球。I can&#39;t play tennis.            我不会打网球。</code></pre><p>短语 know how to 表示你具有做某事的知识或能力。添加 not 表示否定意义。</p><pre><code>I know how to drive.    我知道怎么开车。I don&#39;t know how to swim.        我不知道怎么游泳。</code></pre><p>你也可以使用短语 good at 和 bad at 描述能力程度。这些短语常常与 really、very 和 pretty 等副词搭配使用。   </p><pre><code>Carol is really good at chess.    Carol 非常擅长下棋。James is pretty bad at computer games.    James 玩电脑游戏很差劲。</code></pre><p>你可以使用短语 terrible at 描述非常差的能力。</p><pre><code>I&#39;m terrible at driving.    我开车很差劲。</code></pre><blockquote><p>语言点：单词 pretty 有两层意思，它既表示某人外表迷人，做副词使用时，则修饰强调后接的形容词。</p></blockquote><h2 id="请求帮助"><a href="#请求帮助" class="headerlink" title="请求帮助"></a>请求帮助</h2><p>用下列带有 Could you 的问句请求帮助。</p><pre><code> ```</code></pre><p>  Could you do me a favor?     您能帮我一个忙吗？<br>     Could you help me?    您能帮我吗？</p><pre><code> ```</code></pre><p>你可以使用这些表达对他人的帮助请求表示同意。</p><pre><code>Sure.     当然。No problem.          没问题。OK.         好的。</code></pre><p>如果你帮不了忙，你可以说 I’m sorry, but 来表示道歉，然后说明原因。</p><pre><code>I&#39;m sorry, but I&#39;m really busy right now.     对不起，可我现在真的很忙。I&#39;m really sorry, but I can&#39;t help you.       真对不起，可我帮不了你。</code></pre><h2 id="阅读演出信息"><a href="#阅读演出信息" class="headerlink" title="阅读演出信息"></a>阅读演出信息</h2><p>阅读演出描述时，你可以试着快速浏览信息，寻找关键词。不要在不懂的单词上花费大量时间，关注你知道意思的单词。</p><p>下为关键词的一些分类：</p><p><strong>演出名称：</strong></p><pre><code>concert, picnic, lecture, play, musical</code></pre><p><strong>演出地点：</strong></p><pre><code>auditorium, theater, aquarium, concert hall</code></pre><p><strong>时间和日期：</strong></p><pre><code>on February 6, in the evening, at 5 o&#39;clock</code></pre><p><strong>地点：</strong></p><pre><code>at Martina&#39;s restaurant, in Central Park, on 5th Street</code></pre><p>这里还有一些其他可能的关键词：</p><pre><code>admission    入场费perform    表演start     开始ticket    票available    可用的，可得到的</code></pre><p> <strong>专有名词</strong></p><p>我们使用专有名词来命名事物，比如人、公司或地点。专有名词首字母始终大写，这样易于辨认。不要被这些名词所迷惑。在这些名称中寻找你明白的单词。比如，在 Central Park 中，你可以看到你知道意思的单词 park。在下列专有名词中，各种地点的关键词以粗体表示，通过这些词帮你理解该短语。</p><pre><code>The Monterey Bay AquariumThe Empire State BuildingHarry&#39;s Bar and Grill</code></pre><p>看该段文字，体会使用关键词策略的优势。理解这段文字，你不必逐字逐句阅读，只用理解关键词。在下面这段文字中，关键词以粗体表示。</p><pre><code>Concert in the ParkOn Saturday, June 23rd, the Springfield Orchestra is going to perform Beethoven&#39;s Fifth Symphony. The concert starts at 3 p.m. in Springfield Park. Admission is $5 for adults and $1 for children. Tickets are available online at www.springfield.orchestra.com.</code></pre><h2 id="有关演出的形容词"><a href="#有关演出的形容词" class="headerlink" title="有关演出的形容词"></a>有关演出的形容词</h2><p>许多可以用来描述演出的形容词都以 -ing 结尾，从动词变化而来。比如，形容词 relaxing 来自动词 relax。</p><pre><code>interesting      有趣的           boring           无聊的relaxing        轻松的exciting        令人兴奋的surprising    令人惊讶的</code></pre><p>以下是其他一些描述演出的形容词。</p><pre><code>fun              快乐的，有趣的incredible      精彩的loud            喧闹的quiet            安静的wonderful       出色的terrible        糟糕的</code></pre><p>识记形容词的一个方法是同时学习它们的反义词。</p><pre><code>interesting   -     boringrelaxing      -     excitingloud          -     quietwonderful     -     terrible</code></pre><p><strong>Why 和 because</strong></p><p>使用疑问词 why 询问原因，使用单词 because 说明原因。</p><pre><code>A: Why did you go to Paris?B: I went to Paris because it&#39;s beautiful!    你为什么去巴黎？我去巴黎因为她太美了！</code></pre><p>单词 because 引出原因从句，比如 because it’s beautiful。原因从句与提出句子主题的主句共同使用，比如 I went to Paris。下面还有一些例子。</p><pre><code>主句                          原因从句I go to that restaurant     because it&#39;s cheap, and the food is delicious.       I love surfing    because it&#39;s exciting.I go to concerts    because I enjoy classical music.</code></pre><p>在英语口语中，常常只用带有 because 的分句回答问题。主句 (I went to Paris) 意思都明白。</p><pre><code>A: Why did you go to Paris?B: Because it&#39;s beautiful!    Why did you go to Paris? Because it&#39;s beautiful!因为它美极了！</code></pre><h2 id="建议活动"><a href="#建议活动" class="headerlink" title="建议活动"></a>建议活动</h2><p>提出活动建议有几种方法。</p><p><strong>Let’s + 搭配动词原形</strong></p><pre><code>Let&#39;s go to the dance performance.    我们去看舞蹈演出吧。</code></pre><p><strong>How about 或 what about + 搭配动名词</strong></p><pre><code>What about meeting some friends?    去见一些朋友怎么样？</code></pre><p><strong>Could + 搭配动词原形</strong></p><pre><code>We could go out for a drink at Harry&#39;s Bar.    我们可以去 Harry&#39;s Bar 酒吧喝点东西。</code></pre><p><strong>Why don’t we + 搭配动词原形</strong></p><pre><code>Why don&#39;t we try a new restaurant?    我们为什不试试一家新餐馆呢？</code></pre><h2 id="一般现在时表示的将来时"><a href="#一般现在时表示的将来时" class="headerlink" title="一般现在时表示的将来时"></a>一般现在时表示的将来时</h2><p>谈论将来时，你有时可以使用一般现在时。如果谈及的演出活动隶属某计划表、时间表或演出日程，这种情况最为常见。表示演出开始或结束的动词，比如 begin 和 close，常常以一般现在时来表示将来时。</p><p>表示演出开始的一般现在时</p><pre><code>     begin    开始     start    开始     open    开始The dance performance begins at 8 o&#39;clock tonight.    舞蹈演出今晚八点开始。Harold&#39;s Department Store opens at 9 a.m. tomorrow.    Harold&#39;s Department Store 明天早上九点开张。</code></pre><p>表示演出结束的一般现在时</p><pre><code>close     结束end     结束be over     结束，完了finish     结束</code></pre><pre><code>The movie is over at 9:15 p.m.           电影晚上九点一刻结束。She closes her shop at 6 o&#39;clock.    她六点钟关店。</code></pre><blockquote><p>语言点：记住在 he、she 和 it 后面，动词一般现在时后加 s。例如：  </p></blockquote><pre><code>The movie ends at midnight.     电影午夜结束。</code></pre><p><strong>询问有关电影的信息</strong></p><p>想去看电影时，你需要了解有关电影的一些基本信息。你需要知道电影开始的时间、上映地点和电影票价。同时还要了解在哪里买票。使用下列问题来获取这一信息。</p><pre><code>Can you give me some information?    你能告诉我一些信息吗？Do you have a website?    你们有网站吗？Can I buy tickets online?    我可以网上购票吗？What&#39;s your address?    地址在哪里？What time is the next show?    下一场演出在什么时候？Are tickets still available?    还有票吗？How much are tickets?    票多少钱一张？</code></pre><h2 id="表达恼怒"><a href="#表达恼怒" class="headerlink" title="表达恼怒"></a>表达恼怒</h2><p>表达恼怒有许多方法。主要的方法是提高说话音量。这表达出强烈的情感。</p><p><strong>重复</strong></p><p>表达恼怒的另一种方法是重复短语表示强调。  </p><pre><code>OK, OK. I&#39;m coming. I&#39;m coming.    好好，我来了，我来了。  </code></pre><p><strong>表达怀疑</strong></p><p>通过表示你不相信某人做了某事，也能传达你的恼怒。</p><pre><code>I don&#39;t believe it!     我不相信！I can&#39;t believe it!    我不敢相信！</code></pre><p><strong>夸张</strong></p><p>你也可以通过夸大某人犯错的频率来表达愤怒。使用 always 和 never 来表示夸大。重读这些词来强调频率。</p><pre><code>Jake always forgets.    Jake 老是忘记。Mary never helps me.    Mary 从来不帮我。</code></pre><p><strong>表达强烈的恼怒</strong></p><p>你可以使用 stupid 或 crazy 等形容词表达程度更强的恼怒。如果你用这些词形容一个人，表示你不是恼怒，而是生气了。谨慎使用这些词，因为它们可能伤害人的感情。</p><pre><code>This is stupid!    这很傻。Are you crazy?    你疯了吗？</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English - UNIT2</title>
      <link href="/2018/03/31/English-Level2-UNIT2/"/>
      <url>/2018/03/31/English-Level2-UNIT2/</url>
      
        <content type="html"><![CDATA[<h2 id="人的外型描述"><a href="#人的外型描述" class="headerlink" title="人的外型描述"></a>人的外型描述</h2><p>在描述人的身体时，我们通常会谈到身高和体重。需要注意的是，说人 <code>fat</code> 或者 <code>overweight</code> 往往被视为不礼貌的。不过在对人进行描述时，<code>overweight</code>一词不礼貌的程度稍轻。<br><a id="more"></a></p><pre><code>tall    高medium height    中等高度short    矮overweight    超重fat    肥胖thin    瘦</code></pre><p>描述身高和体重时，使用动词 <code>be</code>。</p><pre><code>She is tall and thin.    她又高又瘦。</code></pre><p>在描述人的面孔时，我们通常会谈及眼睛的颜色和任何其他显著的容貌。描述容貌时，我们通常使用动词 have。</p><pre><code>She has blue eyes.    她长着一双蓝眼睛。He has big ears.     他长着一对大耳朵。He has a nice smile.    他拥有迷人的笑容。</code></pre><p>当描述一个人的头发时，我们通常谈论长度，发型以及颜色。一个人秃顶我们就描述成 <code>bald</code>. 这里有一些有用的形容词：</p><pre><code>long     长发medium length    中长发short    短发curly    卷发straight    直发blond    金发bald    秃顶</code></pre><p>在描述人的头发时，我们通常使用动词 have。但是，如果某人是 bald，我们就会使用动词 be。</p><pre><code>She has long, straight, brown hair.    她拥有一头棕色的长长的直发。My father is bald.    我父亲是秃顶。</code></pre><p>另一种描述人的方法是谈论年龄。</p><pre><code>old    老年middle-aged    中年young    年轻</code></pre><blockquote><p>文化点：对有些人来说，年龄是一个非常敏感的话题。在熟悉他们之前，避免和他们谈论年龄。</p></blockquote><p>形容词的排序</p><p>当您使用一个以上的形容词进行描述时，一般的规则是把它们按大小，年龄，然后颜色的顺序排列。</p><pre><code>That is a fat, old, black dog.那是一只肥肥的老黑狗。</code></pre><p>请注意这些例子中的大小-年龄-颜色的顺序：</p><pre><code>He has big, brown eyes.他长着一双大大的棕色眼睛。Her hair is shorter and grayer than before.她的头发比以前更短了，也变得更灰白了。He&#39;s a thin, middle-aged man.他是个瘦瘦的中年男子。That tall, young, blond man drives a truck.那个高个儿的，金发碧眼的年轻男子开一辆卡车。</code></pre><h2 id="描述人物"><a href="#描述人物" class="headerlink" title="描述人物"></a>描述人物</h2><p><code>What is (person) like?</code>或者 <code>What does (person) look like?</code>是用来询问一个人的身材，形体，年龄或者整体的外貌。 使用动词 be 来描述整体的外貌。</p><pre><code>A: What does he look like?    他长什么样？B: He is tall and middle-aged. He&#39;s very good-looking.    他高个子，中年人，样子很好看。</code></pre><p>您也可以使用像<code>What&#39;s his hair like?</code>或 <code>What color are his eyes?</code>这样的疑问句去询问一个人的身体特定部位的描述。 使用动词<code>have</code>来指身体的部位。</p><pre><code>A: What color are his eyes?    他的眼睛是什么颜色的？B: They&#39;re brown.    它们是棕色的。A: How tall is she?    她有多高？B: She&#39;s very tall.    她很高。A: What do the children look like?    这些小孩看起来像什么？B: They have curly, red hair. Jasmine has big, brown eyes, and Jason has blue eyes.他们的头发又红又卷，杰斯敏的眼睛大大的，是棕色的，而贾森的眼睛是蓝色的。</code></pre><p>这里有很多形容词来给您描述一个人的外貌。请注意动词 be与它们搭配时的用法。</p><pre><code>He&#39;s not very good-looking.    他长得不是很好看。She&#39;s beautiful!                 她天生丽质!He&#39;s very attractive.                      他很迷人。He&#39;s handsome.                     他相貌英俊。</code></pre><p>语言点<code>Good-looking</code>与 <code>attractive</code> 具有相同的含义。<code>Good-looking</code>与 <code>attractive</code> 可用于描述男性和女性。通常<code>Beautiful</code> 用于描述女性，<code>handsome</code> 则一般用于描述男性。</p><h2 id="关系词汇"><a href="#关系词汇" class="headerlink" title="关系词汇"></a>关系词汇</h2><p>您应该已经知道家庭成员的基本词汇了。这里还有一些您将需要到的：</p><pre><code>wife    妻子husband    丈夫granddaughter    孙女grandson    孙子aunt    阿姨uncle    叔叔niece    侄女nephew    侄子cousin    堂表兄弟姐妹</code></pre><p>使用 <code>friend</code> 以区分哪些是您熟悉并喜爱的人。使用 <code>girlfriend</code> 来确定与一位女性的恋爱关系，使用 <code>boyfriend</code> 确定与一位男性的恋爱关系。</p><pre><code>Is he your friend?    他是您的朋友?I&#39;m meeting my girlfriend tonight.    我今晚要去见我的女朋友。He&#39;s my boyfriend.    他是我的男朋友。</code></pre><p>partner 这个词可以指各种关系。您可以使用它来确定与一个人的配偶关系。它可以也指商业伙伴或其他业务关系。</p><pre><code>This is my partner, Paul.    这是我的配偶, Paul。James and I are business partners.    James和我是商业伙伴。</code></pre><p>您也可以用这些词来确定工作关系：</p><pre><code>boss    上司colleague    同事</code></pre><h2 id="描述关系"><a href="#描述关系" class="headerlink" title="描述关系"></a>描述关系</h2><p>使用类似以下的表达来描述一段关系中正在发生的事情。注意，所有表达都后接动名词 (verb + -ing)。</p><p><strong>表达式可以是肯定的：</strong></p><pre><code>We spend time watching movies.     我们看电影打发时间。I always have fun talking with him.    和他谈天我总是感到很开心。</code></pre><p><strong>表达式可以是否定的：</strong></p><pre><code>We have a hard time getting together.    我们好不容易在一起。She has trouble making money.    赚钱对她来说是件困难的事。They often waste time fighting.    (他们常常浪费时间吵架。)</code></pre><h2 id="谈论关系"><a href="#谈论关系" class="headerlink" title="谈论关系"></a>谈论关系</h2><p>请使用类似以下的问题来询问别人一段关系。注意答复中表达式 +动名词的结构。</p><pre><code>A: How are you and your brother doing?    你和你哥哥（弟弟）关系还好吗？B: We&#39;re doing well, thanks. We spend time talking on the phone.    我们关系很好，谢谢。我们会花时间打电话聊天。A: What do you and Sylvia do for fun?B: Let&#39;s see … We have a lot of fun playing tennis together.    你和 Sylvia 都玩什么？让我想想……我们一起打网球，玩得很开心。</code></pre><p>您可以使用you two 表达密切的关系 - 例如，丈夫与妻子之间或母亲与孩子之前。</p><pre><code>A: Are you two having trouble? 你们两人碰到什么难题了吗？B: Yeah, we are. I am having trouble understanding her problems.    是的，我们碰到了难题。我难以理解她的问题。A: I&#39;m sorry to hear that.    听到这我很难过。</code></pre><h2 id="评价员工的词汇"><a href="#评价员工的词汇" class="headerlink" title="评价员工的词汇"></a>评价员工的词汇</h2><p>使用这些形容词和短语来形容员工积极工作的品质。</p><pre><code>hardworking    勤劳的efficient    有效率的creative    富有创造性的helpful     有用的positive    积极的does a good job     做得不错works well with the team / team player    与团队/ 队员合作愉快getting better    逐渐在改善good in meetings    善于开会</code></pre><p>使用这些形容词和短语来描述员工消极的工作品质。</p><pre><code>could do better     可以做得更好late     迟到negative    消极的disorganized    混乱的lazy    懒惰</code></pre><p>一种更积极的方式来应对员工的弱点即是给出建设性的批评，而不是简单地给出消极的评论。</p><pre><code>She&#39;s so disorganized. &gt; She needs to be more organized.    她很混乱。 &gt; 她应该要更有条理些。He&#39;s too negative. &gt; He should be more positive.    他太消极了。 &gt; 他应该积极些。</code></pre><h2 id="‘Too’-和-‘enough’"><a href="#‘Too’-和-‘enough’" class="headerlink" title="‘Too’ 和 ‘enough’"></a>‘Too’ 和 ‘enough’</h2><p>请用 too + 形容词来描述某样东西超过必要，或超过所需时。</p><pre><code>Her project is late because she&#39;s too disorganized.    她的项目已经晚了，因为她太没有条理了。She&#39;s too negative. She thinks too much about problems.    她太消极了。 她想问题考虑得太多了。</code></pre><p>请用形容词 + enough 来描述当某件东西足够的，或让人满意的时候。</p><pre><code>Carson is hardworking and efficient enough to be the new manager.    Carson够勤劳且够有效率，够格成为新经理。</code></pre><p>请用not + 形容词 + enough 来描述某件东西缺乏或不尽人意时。</p><pre><code>Sally&#39;s not efficient enough.     Sally的效率还不够高。He&#39;s not creative enough to work in marketing.       他没有足够的创造力做市场营销工作。</code></pre><p><strong>发表意见的时候用 ‘I think that’</strong></p><p>使用 I think that 来表示您在发表一个意见。 使用 so do I 来表示同意一个 I think that 和 I like 这样的短语所表达的意见.</p><pre><code>A: I think that he does a really good job.B: So do I.          我觉得他干的不错。我也觉得。A: I like them both.  B: So do I.            我喜欢他俩。我也觉得。</code></pre><p>使用neither do I 来赞成 I don’t think that 这样句式所表达的意见, 或其他否定意见。</p><pre><code>A: I don&#39;t think she&#39;s lazy.  B: Neither do I.     我并不觉得她懒。我也不觉得。</code></pre><blockquote><p>请注意 that 可以省掉且句子的含义没有受到影响。</p></blockquote><p><strong>要征求别人的意见，您可以使用what do you think about 以及 do you think。</strong></p><pre><code>A: What do you think about Denise?  您觉得Denise怎么样?B: She&#39;s very efficient.   她很有效率。A: Do you think Paul is too disorganized? 您觉不觉得Paul这个人太混乱了?B: No, not really.       不，不是的。      </code></pre><p>语言注释：neither有两种发音方法。在下面的例子中，第一个在美国比较普遍的；第二种多见于英国。但它们可以互换使用。</p><pre><code>A: I don&#39;t think he&#39;s disorganized. 我并不觉得他这个人没有调理。B: Neither do I.      我也不觉得。A: I don&#39;t think she&#39;s very efficient.     我并不觉得她很有效率。B: Neither do I.  我也不觉得。</code></pre><h2 id="在工作中所用的副词"><a href="#在工作中所用的副词" class="headerlink" title="在工作中所用的副词"></a>在工作中所用的副词</h2><p>副词解释<code>how</code>, <code>when</code> or <code>where</code>。它们可以修饰一个动词，形容词或另一个副词。许多副词以-ly 结尾的是最容易识别的和形成的。但是，许多副词是不以-ly 结尾的,识别它们的最好的方式是将它们连接到它们所修饰的动词，形容词或副词。</p><p><strong>使用状态副词加动词来表示完成某件事情的方式。</strong></p><pre><code>Martina works quickly.     Martina工作效率高。She works well with the team.    她与团队合作得很愉快。I highly recommend Martina.    我强烈推荐Martina。I&#39;m going to miss her terribly.     我将会非常想念她。</code></pre><p><strong>使用时间副词加动词来表示时间。</strong></p><pre><code>Her husband is already in New York.      她的丈夫已经在纽约了。She&#39;s leaving that soon?    她这么快就走了?</code></pre><p><strong>使用频率副词加动词来表示一个动作的频率。</strong></p><pre><code> She was always organized.         她一向都很有条理的。</code></pre><p><strong>使用可能性副词加动词来表示一个行动的可能性。</strong></p><pre><code>She can probably learn that in one or two days.       她可能会在一或两天内知道。</code></pre><p><strong>您可以使用 only 加动词来把注意力集中到信息上。</strong></p><pre><code>The project only took her one day.        她可以仅用一天时间完成此项目。</code></pre><p><strong>您可以使用副词来修饰形容词。</strong></p><pre><code>The brochure was really beautiful.        这本小册子真的很漂亮。She&#39;s so creative.         她真有创意。</code></pre><p>有些副词修饰其他副词. 请注意 pretty 和 so 是如何给这些句子添加额外的细节的。</p><pre><code>She can learn that pretty quickly.    她能领悟得相当快。He writes so well.     他写得真好。</code></pre><p>您可以使用副词honestly 在一个句子前边来强调强调某个要点。</p><pre><code>Honestly, what are we going to do?        说实话, 我们去干嘛?</code></pre><h2 id="‘So’-和-‘such’"><a href="#‘So’-和-‘such’" class="headerlink" title="‘So’ 和 ‘such’"></a>‘So’ 和 ‘such’</h2><p>请用so + 形容词 或 so + 副词来强调个人品质。</p><pre><code>Kyle is so disorganized.      Kyle 非常没有条理。She works so quickly.       她做事很快。</code></pre><p>请用such + 名词来强调个人品质.</p><pre><code>Debra is such a team player.     Debra 是非常具有团队精神的人。She shows such creativity.                       她表现出极大的创造力。Oscar is such a hard worker.          Oscar 是工作非常努力的人。</code></pre><h2 id="写一封介绍信"><a href="#写一封介绍信" class="headerlink" title="写一封介绍信"></a>写一封介绍信</h2><p>以下是一些在介绍信不同部分所使用到的表达式。</p><ol><li>日期及称呼</li></ol><p>写信前先写日期</p><p>September 16, 2012</p><p>如果你知道收信人的名字，使用 Dear + 人的名字作为致敬语。</p><p>Dear Mr. Park,      (敬爱的 Park先生,)</p><p>如果您写一封普通的信，请使用：</p><p>To whom it may concern:<br>(它可能会涉及到的人:)</p><ol start="2"><li>您为什么写</li></ol><p>请使用这个段落格式来解释您为什么写：</p><p>I am writing to highly recommend Jacqueline Johnson. I worked with her for two years.         我正在写信，大力推荐 Jacqueline Johnson。我和她共事两年。</p><p>3.员工的品质及成就</p><p>在本段中，请写几个描述员工的品质和所取得的成就的句子。</p><p>Ms. Johnson was our chief designer. She was very creative. She also worked really quickly. Her last project only took her three days. It usually takes one week. Honestly, Ms. Johnson was the perfect employee.         Johnson 小姐是我们的首席设计师。她有很强的创造力，而且做事极快。她的上个项目只用三天就完成了。这通常需要一周时间。实话实说，Johnson 是员工的模范。</p><ol start="4"><li>结尾 – 联系信息及签名行</li></ol><p>您可以用这句话来告诉他人您愿意进一步谈论某个员工：</p><p>Please feel free to contact me about Ms. Johnson at …<br>请随时在…与我联系谈论关于约翰逊女士</p><p>您可以用这个表达方式来正式地给一封信收尾：</p><p>Sincerely,<br>(诚挚地,)</p><p>把您的签名行 - 包括姓名，职务和公司 - 置于最下方：</p><p>Giovanni McKean<br>Vice President, Design<br>Imagicot</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English UNIT3</title>
      <link href="/2018/03/31/English-Level2-UNIT3/"/>
      <url>/2018/03/31/English-Level2-UNIT3/</url>
      
        <content type="html"><![CDATA[<h2 id="动词过去时"><a href="#动词过去时" class="headerlink" title="动词过去时"></a>动词过去时</h2><p>许多动词过去时只用在动词词尾添加 -ed 即可。</p><pre><code>walk - walkedclean - cleaned</code></pre><a id="more"></a><p><strong> 不规则动词 </strong></p><p>但是，一些最常用的动词都是不规则的，也就是说它们的过去形式不以 -ed 结尾。它们有多种不同的形成方式。</p><pre><code>have - hadmake - madeeat - atedrink - dranklet - let      </code></pre><p><strong> be 动词 </strong></p><p><strong><em> be 动词有两种过去时形式：was 和 were。代词 he、she、it 和 I 使用 was，you、we 和 they 使用 were。</em></strong></p><pre><code>He was tired yesterday.            他昨天很累。They were happy in Paris.         他们以前在巴黎过得很开心。</code></pre><p><strong>否定式</strong></p><p>使用 did + not 来组成动词过去时否定式。主要动词保持原形。</p><pre><code>They did not like London.              他们以前不喜欢伦敦。We did not meet John yesterday.             我们昨天没有碰到 John。</code></pre><p>在英语口语中，短语 did + not 通常缩写为 didn’t。</p><pre><code>They didn&#39;t like London.         他们以前不喜欢伦敦。We didn&#39;t meet John yesterday.                  我们昨天没有碰到 John。</code></pre><p>be 动词的过去时否定式为 was not 和 were not，对应的缩写形式分别为 wasn’t 和 weren’t。</p><pre><code>Frank was not happy in Los Angeles. &gt; Frank wasn&#39;t happy in Los Angeles.         Frank 以前在洛杉矶过得不开心。Oscar and Pam were not at home yesterday. &gt; Oscar and Pam weren&#39;t at home yesterday.         Oscar 和 Pam 昨天不在家。</code></pre><p><strong>过去时疑问句</strong></p><p>在句首使用单词 did 来形成过去时疑问句。did 后使用主要动词的原形。不得在动词词尾后加 s。</p><pre><code>Did he go to Shanghai?                 他去上海了吗？Did they eat dinner?                          他们吃了吗？</code></pre><p>要使用 be 动词组成过去时疑问句，请将 was 或 were 置于问句之首。  </p><pre><code>陈述句：  He was happy.         他以前很开心。疑问句：  Was he happy?                      他以前很开心吗？</code></pre><h2 id="过去时间的表达"><a href="#过去时间的表达" class="headerlink" title="过去时间的表达"></a>过去时间的表达</h2><p>使用下列表达来谈论过去的事情。</p><pre><code>&#39;Yesterday&#39;          I visited Carol yesterday.    我昨天拜访了 Carol。&#39;The day before yesterday&#39;     Jack and Nancy got back from Mexico the day before yesterday.    Jack 和 Nancy 前天从墨西哥回来了。</code></pre><p><strong>数字 + 时间单词 + ago</strong></p><pre><code>We went to that new restaurant two days ago.    我们两天前去了那家新餐馆。</code></pre><p><strong>last + 时间单词</strong></p><pre><code>I worked at a supermarket last year.    我去年在一家超市上班。</code></pre><h2 id="开放式问题和封闭式问题"><a href="#开放式问题和封闭式问题" class="headerlink" title="开放式问题和封闭式问题"></a>开放式问题和封闭式问题</h2><p><strong>开放式问题是指答案不止一个的问题。比如，How was Paris? 有多种可能的回答。</strong></p><pre><code>How was Paris?    巴黎怎么样？It was great!    太棒了！It was terrible.    很差。We loved it.    我们很喜欢。We hated it.    我们很讨厌。</code></pre><p><strong>封闭式问题则只有肯定和否定两种回答：yes 或 no。</strong></p><pre><code>Did you go to Paris?    你去过巴黎吗？Yes, I did.    是的，我去过。  No, I didn&#39;t.    没，我没去过。</code></pre><blockquote><p>开放式问题一般更利于推动对话。它们让和你对话的人可以自由回答，回答方法也有多种。开放式问题主要分为两种：描述性问题和意见性问题。</p></blockquote><p><strong>描述性问题</strong></p><pre><code>What was it like?    （它什么样子？）What was the wedding like?    婚礼是什么样子？What did he look like?    他长什么样？</code></pre><p><strong>意见性问题</strong></p><pre><code>How did you like Beijing?    你有多喜欢北京？How was your vacation?    你的假期怎么样？How was Russia?    （俄罗斯怎么样？）</code></pre><blockquote><p>语言点：谨慎使用单词 like，该词有两种不同的意思。<br>描述： What was it like?    （它是什么样子？）<br>观点： How did you like it?    （你有多喜欢它？）     </p></blockquote><h2 id="不规则动词过去时态"><a href="#不规则动词过去时态" class="headerlink" title="不规则动词过去时态"></a>不规则动词过去时态</h2><p>许多动词的过去时形式都是不规则的，也就是说它们的过去时形式不能通过简单在词尾添加 -ed 形成。</p><p>有些不规则动词的过去时和现在时截然不同，必须加以熟记。</p><pre><code>go - went      去                                                            eat - ate      吃bring - brought      带来leave - left        离开sell - sold      卖</code></pre><p>其他不规则动词的过去时形式只是改变了一个字母，因此更容易识记。</p><pre><code>make - made    做rise - rose     上升get - got            得到</code></pre><p>一些动词的一般现在时和过去时的形式相同。</p><pre><code>cut - cut       切割let - let     让shut - shut    关闭</code></pre><p>动词 read 的一般现在时和过去时拼法相同，但读音不同。请听这两句中 read 的读音。</p><pre><code>I often read novels.      我经常看小说。I read a good novel last week.    上周我看一本精彩的小说。</code></pre><h2 id="开启对话"><a href="#开启对话" class="headerlink" title="开启对话"></a>开启对话</h2><p>开启对话有多种方法。</p><ul><li>一般性问题</li></ul><p>如果没有想要谈论的话题，问候完后你可以使用一个常见的一般性问题。</p><pre><code>How are you doing?     你还好吗？How are you today?      你今天怎么样？What&#39;s up?    你好吗？What&#39;s happening?    在忙什么呢？What&#39;s going on?     发生什么事了？How was your weekend?    你周末过得怎么样？</code></pre><ul><li>特定问题</li></ul><p>你可以向你认识的人询问他们的生活。</p><pre><code>How was Peru?     秘鲁怎么样？How is your mom feeling?         你妈妈感觉怎么样？</code></pre><ul><li>陈述句</li></ul><p>在有些场合，你会有一个你想讨论的话题。你可以提出陈述，然后听众会对你的陈述发表意见。</p><pre><code>A: Hey, there was a great movie on last night.B: Really? What was it?     嗨，昨天晚上的电影很好看。真的吗？什么电影？A: That was a great game last night!B: Yeah, it was really exciting!     昨天晚上的比赛非常精彩！是啊，真的令人兴奋！</code></pre><h2 id="改变话题"><a href="#改变话题" class="headerlink" title="改变话题"></a>改变话题</h2><p>对话从一个话题转到另一个话题，有一些表达可以帮助人们暗示他们要改变话题。</p><ul><li><code>&#39;By the way&#39;</code></li></ul><p><strong>使用表达 by the way 来引入新话题，它也表示你刚想起了某事。</strong></p><pre><code>A: By the way, I saw Joe last night. He looked good.B: Really? I&#39;m so glad!    对了，我昨天晚上见到 Joe 了。他气色看起来不错。真的吗？我非常高兴！</code></pre><ul><li><code>&#39;That reminds me&#39;</code></li></ul><p>当你想起了想说的其他事情，使用 that reminds me 来转变话题。</p><pre><code>A: There was a great baseball game on TV last night.B: Oh, that reminds me. I have two tickets to tonight&#39;s game. Do you want to go?A: Yeah!    昨天晚上电视上有一场精彩的棒球比赛。哦，我想起来了。我有两张今天晚上比赛的票。你想去吗？是啊！</code></pre><ul><li><code>&#39;Anyway&#39;</code></li></ul><p>使用单词 anyway 来结束或总结话题，这样一来你可以开始一个新话题。当你听厌了某人谈论某事，非常想改变话题时，就可以使用这个词。</p><pre><code>A: That restaurant wasn&#39;t very good.B: No, it wasn&#39;t! The meat tasted bad, and the salad wasn&#39;t fresh. And the waiter was awful! His clothes were dirty!A: Anyway, we&#39;re not going there again. So, how&#39;s Jane?    那家餐馆不是很好。是啊，不怎么好！肉有味道，沙拉也不新鲜。而且服务员也很差劲！他的衣服很脏！总之，我们不打算再去了。对了，Jane 还好吧？</code></pre><h2 id="新闻词汇"><a href="#新闻词汇" class="headerlink" title="新闻词汇"></a>新闻词汇</h2><p>新闻消息涵盖罪行、政治和商业等各种各样的话题。我们再次只关注 crime。以下是一些和 crime相关的有用名词。</p><ul><li>与罪行相关的名词</li></ul><pre><code>crime    犯罪案件                    police     警察thief      小偷theft    盗窃</code></pre><blockquote><p>thief 是指犯偷窃罪的人，theft 则是偷窃这一事件。thief 一词的复数形式是不规则的： thieves。</p></blockquote><ul><li>与罪行相关的动词</li></ul><p>以下是一些和 crime 相关的有用动词。</p><pre><code>break into       闯入，破门而入murder    谋杀kill    杀死arrest    逮捕steal    偷盗</code></pre><blockquote><p>zsteal 是不规则动词，过去式形式是 stole。</p></blockquote><h2 id="不定代词"><a href="#不定代词" class="headerlink" title="不定代词"></a>不定代词</h2><p>有些代词并不指代某个已知的名词，它们就是不定代词，包括以下三个单词。</p><pre><code>somewhere某处                                                            someone    某人something    某事   </code></pre><ul><li>使用 somewhere 谈论不确定的地点。</li></ul><pre><code>John lives somewhere in Tokyo. I don&#39;t know his address.    John 住在东京的某个地方，我不知道地址。</code></pre><ul><li>使用 someone 谈论不确定或不知道的人。</li></ul><pre><code>Someone stole a painting from the museum.         有人从博物馆偷了一幅画。</code></pre><ul><li>使用 something 谈论不确定的事物。</li></ul><pre><code>The thief stole something from the woman&#39;s bag.      小偷从那位女士的包里偷了什么东西。</code></pre><p>语言点：单词 somebody 与 someone 意义相同。</p><h2 id="故事排序"><a href="#故事排序" class="headerlink" title="故事排序"></a>故事排序</h2><p>在讲故事或写故事时，将事情发生的顺序理清很重要。理清顺序有几种方法。</p><ul><li>如果你描述的事情在另一件事情一天之后发生，使用短语 the next day。</li></ul><pre><code>They stole 15 computers on Friday night. The next day, the police came.     他们周五晚上偷了 15 台电脑，第二天来了警察。</code></pre><ul><li>要表示一件事情在某事多久之后发生，使用数字 + 时间单词 + later。</li></ul><pre><code>There was a theft on Friday night. Three days later, we hired a security guard.     周五晚上发生了盗窃。三天后，我们聘请了一名保安。</code></pre><ul><li>向他人讲述某件发生的事情，你也可以使用本课中之前学到的时间表达。</li></ul><pre><code>The theft was three days ago.    盗窃发生在三天前。They broke in last Friday.    他们上周五闯了进去。      They stole money the day before yesterday.    他们前天偷了钱。</code></pre><h2 id="预览新闻文章"><a href="#预览新闻文章" class="headerlink" title="预览新闻文章"></a>预览新闻文章</h2><p>随着你的英语更加熟练，你将开始阅读难度更大的文字，比如新闻和杂志文章。这时培养理解这些文字的策略很重要。一种有用的策略是在开始阅读故事前先预览或通看整篇文章。以下是一些具体步骤，将让你的阅读更加具有效率。</p><ul><li>标题</li></ul><p>标题以一种特有的简短英语形式撰写，因此起初可能会难以理解。例如，标题 U.K., U.S. Talk Trade 表示英美两国协商贸易问题。由于标题涵盖文章大意，尤其应该引起你的注意。</p><ul><li>照片和插图</li></ul><p>照片和插图置于文中，可以让文章更容易理解，增加阅读趣味。慢慢仔细观看照片和图片。如果图片配有文字说明，阅读这些说明，获取更多有关图片和故事的信息。</p><ul><li>导语</li></ul><p>新闻文章的第一段称为导语，通常包含该新闻最重要的细节。导语常常引出人物、时间、时间和地点，有时也会介绍方式和原因。由于导语信息充分，因此你应该密切关注。</p><ul><li>新闻来源</li></ul><p>在文章上方，你可能看到至少下列一项：署名行（记者姓名）、日期栏（记者发稿的城市）和通讯社的名称。有时通讯社的名称见于括号中 (Global News)，有时缩写为 (GN)。</p><h2 id="含有疑问词的过去时疑问句"><a href="#含有疑问词的过去时疑问句" class="headerlink" title="含有疑问词的过去时疑问句"></a>含有疑问词的过去时疑问句</h2><p>过去时疑问句如果不使用 be 动词，而且句首为疑问词，需要使用辅助动词 did。另外请注意主要动词保持原形。</p><pre><code>A: What did you do on the weekend?B: I played badminton.    你周末做了什么？             我打羽毛球了。                               A: Where did you go for your vacation?B: I went to Peru.    你去哪度假了？我去秘鲁了。</code></pre><ul><li>询问某物的所有者，使用疑问词 whose。</li></ul><pre><code>A: Whose backpack did you borrow?B: I borrowed my brother&#39;s.    你借了谁的背包？我借了我哥哥（弟弟）的背包。</code></pre><ul><li>询问某物的种类，使用疑问短语 what kind of。</li></ul><pre><code>A: What kind of tent did you buy?B: I bought a Shelty. It&#39;s the best brand.    你买了哪种帐篷？我买了一个 Shelty，这个牌子最好。A: What kind of animals did you see?B: We saw deer, wolves and a snake.    你看到了哪些种类的动物？我们看到了鹿、狼和蛇。</code></pre><ul><li>你可以使用疑问词 how 与许多不同的形容词搭配，用以询问详细信息。</li></ul><pre><code>How far did you walk?    你们走了多远？How difficult was the hike?    徒步旅行有多困难？</code></pre><ul><li>be 动词疑问句不需要辅助动词 did。</li></ul><pre><code>A: How was your weekend?B: It was great, thanks.    周末过得怎么样？非常愉快，谢谢。A: How long was your trip?B: We hiked for two weeks.    这次旅行你们去了多久？我们徒步旅行了两周。</code></pre><h2 id="积极聆听"><a href="#积极聆听" class="headerlink" title="积极聆听"></a>积极聆听</h2><p>听故事不应该完全被动接受。与通常的对话相同，你应避免沉默，激发讲故事的人，不懂得时候要提问。做一个积极的聆听者。</p><p>常常可以通过询问故事接下来的事情来激发讲故事的人。使用下列表达询问之后发生的事情：</p><pre><code>And then what happened?    然后发生了什么事？                            What happened next?    接着发生了什么事？What did you do then?    然后你做了什么？Go on.    继续讲。</code></pre><p>请记住，升调可以将陈述句变为疑问句。使用类似下面的问题确定你理解了或表达惊奇。</p><pre><code>Bears?    熊吗？A problem with a bear?    碰到熊了吗？And we&#39;re going to the same place?    我们打算去同一个地方吗？</code></pre><p>最好的故事会故事讲述人和听故事的人应该互动，从而营造一场难忘的活动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数值比较</title>
      <link href="/2018/03/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/"/>
      <url>/2018/03/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<pre><code>#define FLT_EPSILON __FLT_EPSILON__#define DBL_EPSILON __DBL_EPSILON__#define LDBL_EPSILON __LDBL_EPSILON__</code></pre><p>这三个宏定义可用来作为float、double、long double趋0最小的判断值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客文章收集</title>
      <link href="/2018/03/08/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/"/>
      <url>/2018/03/08/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><a href="https://juejin.im/post/5a9e57af6fb9a028df222555#comment" target="_blank" rel="noopener">iOS多线程：『NSOperation、NSOperationQueue』详尽总结</a>  </p><p><a href="https://juejin.im/post/5a90de68f265da4e9b592b40?utm_source=gold_browser_extension" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a>  </p><h1 id="类与类对象"><a href="#类与类对象" class="headerlink" title="类与类对象"></a>类与类对象</h1><p><a href="http://www.cocoachina.com/ios/20180309/22515.html" target="_blank" rel="noopener">格物致知iOS类与对象</a>  </p><p><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Interface Builder</title>
      <link href="/2018/03/06/iOSUI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B01/"/>
      <url>/2018/03/06/iOSUI%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="Interface-Builder-简介"><a href="#Interface-Builder-简介" class="headerlink" title="Interface Builder 简介"></a>Interface Builder 简介</h1><p>Interface Builder（IB）源于NeXT Interface Builder,从iOS系统的问世到现在，一直伴随着它共同成长。</p><h2 id="IB是什么？"><a href="#IB是什么？" class="headerlink" title="IB是什么？"></a>IB是什么？</h2><p>IB是苹果公司给开发者提供的可视化UI开发工具。</p><blockquote><p>IB之于程序员，就像ps之于设计师，它们都是在可视化编辑UI</p></blockquote><h2 id="xib是什么？"><a href="#xib是什么？" class="headerlink" title="xib是什么？"></a>xib是什么？</h2><p>xib是IB中的一种文件类型，也就是<code>.xib</code>扩展名的文件。 xib是文本文件，以xml的形式存储UI相关数据。<br>xib在项目中作为资源文件存在，<strong>和普通的图片，音频，视频等资源文件有所不同</strong>。其在<code>Copy Bundle Resource</code>中显示。</p><blockquote><p>xib之于程序员，就像psd之于设计师，它们都是一种文件格式，大部分工作都是在可视化地编辑这些文件。</p></blockquote><h2 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a><a href="https://developer.apple.com/documentation/foundation/bundle" target="_blank" rel="noopener">Bundle</a></h2><blockquote><p>Bundle： 一种标准化的层次结构，保存了可执行代码及代码所需要的资源。<br>A representation of the code and resources stored in a bundle directory on disk.</p></blockquote><p>Bundle的两种表现形式：</p><ul><li><p>保存可执行代码<br>  我们的应用（App）就是一个bundle。因为每个app内部结构都是固定的，而且app这个bundle就是在开发中经常使用的<code>main bundle</code>.</p></li><li><p>保存所需要的资源<br>  这里的资源包括xib,storyboard，图片，音频，视频，字体等</p></li></ul><p>添加到工程里的资源文件在编译时会被复制到main bundle中，可以在<code>Copy bundle resources</code>中查看所有被打包到<code>main bundle</code>中的资源文件。只有在<code>Copy bundle resources</code>中显示的文件在编译时才会被复制到<code>main bundle</code>中，直接向工程里添加的文件和通过<code>Asset Catalog</code>方式添加的资源都会在<code>Copy Bundle resources</code>中显示。如果向工程中添加了资源，但未显示在<code>Copy Bundle resources</code>中显示，我们可以通过<code>+</code>按钮，手动添加。否则，在使用该文件时可能会出现问题。</p><h2 id="storyboard-是什么"><a href="#storyboard-是什么" class="headerlink" title="storyboard  是什么"></a>storyboard  是什么</h2><p><code>storyboard（sb）</code>是iOS5 的新特性，它提供了一种全新的方式来可视化编辑UI，最早在xcode4.2中出现。sb是基于IB的一种文件类型，就是<code>.storyboard</code>扩展名的文件，sb也是文本文件，以<code>XML</code>的形式存储着UI相关的数据。IB和SB的这一特性很重要，这使得它们可以以<code>XML</code>形式查看，也为解决IB/SB引起的冲突提供了一个突破口。<br>SB可以理解成一组与VC”关联”的xib集合。该集合中同时也保存了各个VC之间跳转的数据，可以在sb文件上查看每个VC的布局样式、跳转关系等信息，利用sb可以自动完成页面的跳转。</p><blockquote><p>sb 是xib2.0,即增强版</p></blockquote><h2 id="nib-是什么"><a href="#nib-是什么" class="headerlink" title="nib 是什么"></a><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html" target="_blank" rel="noopener">nib</a> 是什么</h2><p>xib文件随着工程编译之后发生变化，并且在bundle中产生与之对应的nib文件</p><blockquote><p>A nib file describes the visual elements of your application’s user interface, including windows, views, controls, and many others. It can also describe non-visual elements, such as the objects in your application that manage your windows and views</p></blockquote><blockquote><p>nib 文件描述应用外观的视觉元素，其中包括了窗口、视图、控制对象和其他元素，它也可以描棕非视觉元素，例如应用中管理窗口和对象的对象。</p></blockquote><p>nib名字来源<code>NeXT Interface Builder</code>,xib是IB编辑过程的一种文件类型，而nib是工程编译后，由xib生成的一种文件类型。xib文件编译后要被序列化为二进制文件的nib文件，使用nib文件就是进行反序列化。</p><ul><li>为什么xib在项目中作为资源文件存在，但与其他资源文件（图片，音频，视频等）有所不同<br>  因为xib文件是需要编译的，编译后xib文件将不存在，而bundle中生成与之对应的nib文件，其他资源文件在编译时仅仅是被复制到bundle中。加载其他资源文件（图片，音频，视频等），可以使用bundle获取对应的path,然后通过path,使用不同的api加载不同的资源。</li></ul><p>xib和nib都属于plist文件，plist文件有三种格式： </p><ul><li>XML</li><li>二进制</li><li>json<br>在开发过程中使用的.plist,xib,sb等文件都是XML格式的文件，但是xib经过编译后的nib文件是二进制的plist文件，苹果不允许查看并再次编辑nib文件，所能通过path来加载IB没有意义。<blockquote><p>nib 是序列化的、 加密的xib</p></blockquote></li></ul><h2 id="storyboardc是什么"><a href="#storyboardc是什么" class="headerlink" title="storyboardc是什么"></a>storyboardc是什么</h2><p>理解了nib,再理解storyboardc就行简单了，storyboardc 是编译后被序列化的storyboard,与nib相似。<br>简单说：</p><blockquote><p>IB开发过程中的xib,storyboard属于XML格式的plist文件，当工程被编译后，它们就变成了相应的nib、storyboardc文件，nib、storyboardc属于二进制格式的plist文件，不允许再次查看和编辑。<br>storyboardc是序列化的、加密的storyboard</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> xib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGRect相关方法的使用说明</title>
      <link href="/2018/03/05/CGRect%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/03/05/CGRect%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="CGRectInset和CGRectOffset。"><a href="#CGRectInset和CGRectOffset。" class="headerlink" title="CGRectInset和CGRectOffset。"></a>CGRectInset和CGRectOffset。</h1><p>两者的作用都是通过参数改变CGRect并返回一个CGRect类型的数据。<br>两者的区别：</p><ul><li>CGRectInset会进行平移和缩放两个操作。</li><li>CGRectOffset做的只是平移。</li></ul><h2 id="CGRectInset："><a href="#CGRectInset：" class="headerlink" title="CGRectInset："></a>CGRectInset：</h2><p>CGRectInset(CGRect rect, CGFloat dx, CGFloat dy),三个参数。</p><ul><li>rect：待操作的CGRect。</li><li>dx：为正数时，向右平移dx，宽度缩小2dx。为负数时，向左平移dx，宽度增大2dx。</li><li>dy：为正数是，向下平移dy，高度缩小2dy。为负数是，向上平移dy，高度增大2dy。</li></ul><h2 id="CGRectOffset："><a href="#CGRectOffset：" class="headerlink" title="CGRectOffset："></a>CGRectOffset：</h2><p>CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy),三个参数。</p><ul><li>rect：待操作的CGRect。</li><li>dx：为正数时，向右平移dx。为负数时，向左平移dx。</li><li>dy：为正数时，想下平移dy。为负数时，向上平移dy。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CGRect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IJK_learn</title>
      <link href="/2018/02/10/IJK-learn/"/>
      <url>/2018/02/10/IJK-learn/</url>
      
        <content type="html"><![CDATA[<ol><li>如何切换播放路径<br>不能切换路径，解决方法释放当前播放器，重新创建一个新的播放器</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑运算符</title>
      <link href="/2018/02/06/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/02/06/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h1><p>逻辑或（logical or）又称逻辑析取（logical disjunction）、逻辑选言，是逻辑和数学概念中的一个二元逻辑算符。其运算方法是：如果其两个变量中有一个真值为“真”，其结果为“真”，两个变量同时为假，其结果为“假”。<br>逻辑或是两个逻辑变量的一种运算，经常是两个命题的运算。它满足：当且仅当其两个变量的真值都为假时，其结果为假。</p><p>真值表[编辑]<br>A或B的真值表（也写作A {\displaystyle \lor } \lor B（逻辑学），A || B（计算机科学），或A + B（电子学））。<br>A     B      ∨<br>真    真    真<br>真    假    真<br>假    真    真<br>假    假    假</p><p>性质<br>逻辑或满足以下性质：<br>保真性: 所有变量的真值皆为“真”的命题在逻辑或运算后的结果为真。<br>保假性: 所有变量的真值皆为“假”的命题在逻辑或运算后的结果为假。</p><h1 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h1><h1 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h1><h1 id="逻辑异或"><a href="#逻辑异或" class="headerlink" title="逻辑异或"></a>逻辑异或</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARC学习笔记</title>
      <link href="/2018/02/04/ARC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/04/ARC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><p>ARC代表自动引用计数（Automatic Reference Counting）,它是在开发Clang Anlyzer时所获得的经验的基础上构建的，是检查代码并在任何需要的地方插入retain,release和autorelease消息的编译过程的一部分。</p><h1 id="ARC是什么，不是什么？"><a href="#ARC是什么，不是什么？" class="headerlink" title="ARC是什么，不是什么？"></a>ARC是什么，不是什么？</h1><p>ARC的一些基本要点：</p><ul><li>ARC中的<code>RC</code>代表引用计数，ARC不是一种全新的和不同的内存管理模式，它可以使用现有的OC引用计数系统自动化</li><li>ARC为OC对象管理内存。它不会管理CF对象（它们具有自己的引用计数系统）或者malloc分配的原始字节。如查直接利用<code>malloc()</code>分配的一些字节，就必须记得利用<code>free()</code>释放它们。如果创建了一些CF对象，也必须记得释放它们</li><li>ARC的工作是作为编译过程的一部分执行的。不过，它需要一个实现了一组指定函数的运行库。</li><li>ARC可以与利用手动引用计数编译的文件和库互操作。 在编译一个项目时，可以在逐个文件上基础上打开和关闭ARC</li><li>ARC不会查找或校正保留循环。新的弱引用系统提供了一个工具，有助于阻止保留循环。</li><li>ARC可以在iOS和OS X上工作，但是在OSX上，ARC只能与64位新的运行库协同工作。</li></ul><h1 id="ARC的规则"><a href="#ARC的规则" class="headerlink" title="ARC的规则"></a>ARC的规则</h1><ul><li>不能实现或调用retain,release,autorelease或者retainCount方法.这一限制不仅针对对象，对选择器同样有效。因此[obj relase],@selector(retain)会在编译时报错。</li><li>可以实现dealloc方法，但不能调用它们。不仅不能调用其他对象的dealloc,也不能调用超类的。[super dealloc]是编译时的错误。 但仍然可以对Core foundation类型的对象调用CFRetain,CFRelease 等相关方法。</li><li>不能调用NSAllocateObject和NSDeallocObject方法。应使用alloc方法创建对象，运行时负责回收对象。</li><li>不能在C语言结构体内使用对象指针</li><li>不能在id类型和void*类型之间进行自动转换。 如果需要，必须显示转换</li><li>不能使用NSAutoreleasPool，要使用autoreleasepool块替换。</li><li>不能使用NSZone内存区域</li><li>属性的访问器名称不能以<code>new</code>开头，确保与MRC的互操作性，</li></ul><h2 id="ARC-和dealloc"><a href="#ARC-和dealloc" class="headerlink" title="ARC 和dealloc"></a>ARC 和dealloc</h2><p>在手动引用计数下，dealloc方法的主要任务是<strong><em>释放保存在保留的实例变量中的任何对象。你的对象将会消失，并且dealloc是你不得不交出在你的对象的实例变量中保存的任何对象的所有权的最后机会</em></strong><br>在ARC下，将负责释放保存在实现变量中的任何对象，不再需要调用<code>[super dealloc]</code>,编译器将会为你自动处理。</p><blockquote><p>ARC把释放保存在类的实例变量中的对象作为它在销毁对象时所做的最后几个事情之一。此时，将会调用你的dealloc方法，所有保存在实例变量中的对象仍然是活动和有效的，即使用只有你的对象保存了指向它们的强引用也是如此。</p></blockquote><h2 id="方法命名约定"><a href="#方法命名约定" class="headerlink" title="方法命名约定"></a>方法命名约定</h2><p>手动引用计数的约定：</p><ul><li>其名称以“alloc”,”new”，“cpy”,”mutablecopy”开头的方法将返回具有“+1的保留计数”的对象。你拥有通过这样的方法返回的任何对象</li><li>对象是由其他任何类型的名称的方法返回的，则不拥有它们。<br>ARC将该规则转变成了一个官方规则：<ul><li>以“alloc”，“new”，“copy”，“mutableCopy”开头的方法必须把所有权传递给调用代码，具有其他名称的方法则不会传递所有权<br>如果希望在方法中以这些单词开头，可以通过向方法声明中添加<code>RETURN_NOT_RETAIN</code>或<code>RETURN_RETAIN</code>来绕开这些规则</li></ul></li></ul><h2 id="ARC-需要看到方法声明"><a href="#ARC-需要看到方法声明" class="headerlink" title="ARC 需要看到方法声明"></a>ARC 需要看到方法声明</h2><p>ARC需要看到它在消息表达式中遇到的每个方法的声明，“看到”指方法在与消息表达式相同的文件中或者是在最终会导入的文件中或者最终会导入那个文件的某个文件声明中。<br>在手动引用计数下：</p><pre><code>Foo  * foo = [[Foo alloc]init];[foo  undeclareMethod];</code></pre><p>会得到一个警告：<code>Instance method &#39;-undeclareMethod&#39; not found(return type defaults to &#39;id&#39;)</code><br>使用ARC，警告将会变成错误：<br><code>No visible @interface for &#39;Foo&#39; declares the selector &#39;undeclaredMethod&#39;</code></p><p>这是由于ARC不能通过方法名确定方法将会返回一个对象还是一种基本数据类型。尽管有这些规则，ARC还是不能只通过查看方法名来判断返回对象的内存状态是什么以。可以通过向方法声明中添加<code>NS_RETURNS_NOT_RETAINED</code>或<code>NS_RETURNS_RETAINED</code>,改变方法期望的保留状态。</p><h2 id="OC-指针与C结构"><a href="#OC-指针与C结构" class="headerlink" title="OC 指针与C结构"></a>OC 指针与C结构</h2><p>不能把指向OC对象的指针放在C结构（struce）或联合（union）中，ARC将不允许编写下面代码：</p><pre><code>  struct _sentence{        NSString * noun;        NSString * verb    }sentence;    //    ARC forbids Objective-C objects in struct</code></pre><p>ARC无法可靠地遵循C结构的生存期，因此，它无法知道自己何时可以安全的释放赋予结构成员的任何对象，通过把结构体的成员声明为<code>__unsafe_unretained</code>就可以解决。</p><pre><code>    struct _sentence{        __unsafe_unretained NSString * noun;        __unsafe_unretained NSString * verb    }sentence;</code></pre><p><code>__unsafe_unretained</code>是ARC引入的变量修饰符，当把一个变量声明为<code>__unsafe_unretained</code>时，它告诉ARC把在一个对象赋予该变量时放弃进行任何内存管理。<br>更好的解决方案是把结构变成一个类：</p><pre><code>@interface Sentence: NSObject@property (nonatomic) NSString * noun;@property (nonatomic) NSString * verb;@end</code></pre><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>ARC带来了新的引用类型：弱引用。其支持的引用类型有：强引用、弱引用</p><ul><li>强引用<br>  强引用是默认的引用类型。被强引用指向的内存不会被释放，强引用会对引用计数加1，从而扩展对象的生命周期。</li><li>弱引用<br>  弱引用是一种特殊的引用类型。它不会增加引用计数，因而不会扩展对象的生命周期。在启用ARC的开发中，弱引用显得格外重要。</li></ul><h1 id="变量修饰符"><a href="#变量修饰符" class="headerlink" title="变量修饰符"></a>变量修饰符</h1><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a><code>__strong</code></h2><p>当把对象存储在一个<code>__strong</code>变量中时，就会创建一个指向该对象的强引用。强引用将使用对象保持活动状态：<br>当ARC在一个<code>__strong</code>变量中存储对象时，它将给该对象发送一条<code>retain</code>消息。如果变量已经保存有一个对象，ARC将给当前的对象发送一条<code>release</code>或<code>autorelease</code>消息。 当保存有一个指向对象的引用的<code>__strong</code>变量超出作用域时，该对象也会接收到一个<code>release</code>或<code>autorelease</code>消息。<br>当最后一个指向对象的强引用消失时，对象的保留引用计数归零，对象将取消分配，并且会把它的字节归还给堆。<br>栈局部变量以及保存对象的函数和方法的实参默认也是<code>__strong</code>类型.在转换没有使用ARC的OC程序时，将把保存对象的栈局部变量初始化为nil.<br>由于实例变量也会初始化为nil,这意味着每个OC对象的强变量要么是nil,要么保存一个对象，该对象在存储到变量时将会被保留。这是一个重要的保证：<strong>每个强类型变量要么包含一个有效的对象，要么是nil,。没有悬挂指针，这样就可以对一大类错误说goodbye</strong></p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a><code>__weak</code></h2><p>这表明引用是不会保持被引用对象的存活。当没有强引用指向对象时，弱引用会被置为nil,可以将<code>__weak</code>看作assign操作符的ARC版本，只是对象被回收时，<code>__weak</code>具有安全性，指针将自动被设置为nil.</p><h2 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a><code>__autoreleasing</code></h2><p><code>__autoreleasing</code>用于由引用使用<code>id *</code>传递的消息参数，它预期了<code>autorelease</code>方法会在传递参数中调用。</p><h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a><code>__unsafe_unretained</code></h2><p>与<code>__weak</code>类似，只是当没有强引用指向对象时，<code>__unsafe_unretained</code>不会被置为nil,可将其看作assin操作符的ARC版本。</p><blockquote><p>使用这些限制符的方法<br><code>typename * qualify(限制符) variable（变量）;</code></p></blockquote><h1 id="属性限定符"><a href="#属性限定符" class="headerlink" title="属性限定符"></a>属性限定符</h1><ul><li>strong  默认修饰符，指定了<code>__strong</code>关系</li><li>weak  指定了<code>__weak</code>关系</li><li>assign 在MRC下,assign 是默认的持有关系限制符，在ARC下表示<code>__unsafe_unretained</code>关系</li><li>copy  暗指了<code>__strong</code>关系</li><li>retain 指定了<code>__strong</code>关系</li><li>unsafe_unretained 指定了<code>__unsafe_unretained</code>关系</li></ul><blockquote><p><code>assign</code>和<code>unsafe_unretained</code>只进行值复制而没有任何的实质检查，所以它们只用于值类型（BOOL,NSInteger,…），应避免将它们使用于引用类型，尤其是指针类型（NSString*,…）</p></blockquote><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul><li>避免使用大量的单例</li><li>对子对象使用<code>__strong</code></li><li>对父对象使用<code>__weak</code></li><li>对使用引用图闭合的对象(如代理)使用<code>__weak</code></li><li>对数值属性（NSInteger,SEL,CGFloat，…）使用<code>assign</code></li><li>对块属性，使用<code>copy</code></li><li>当声明使用<code>NSError **</code>参数的方法时，需要使用<code>__autoreleasing</code>，并注意正确的语法：<code>NSError * __autoreleasing*</code></li><li>避免在块内直接引用外问的变量</li><li>进行必要的清理时，遵守以下准则：<ul><li>销毁计时器</li><li>移除观察者(移除对通知的注册)</li><li>解除回调（将强引用的委托设置为nil）</li></ul></li></ul><p>内存使用情况获取</p><pre><code class="c">#import &lt;mach/mach.h&gt;/**获取使用内存大小*/vm_size_t getUsedMemory(){    task_basic_info_data_t info ;    mach_msg_type_number_t size = sizeof(info);    kern_return_t kerr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);    if (kerr == KERN_SUCCESS) {        return info.resident_size;    }else{        return 0;    }}/**获取空余内存大小*/vm_size_t getFreeMemory(){    mach_port_t host  = mach_host_self();    mach_msg_type_number_t size = sizeof(vm_statistics_t)/sizeof(integer_t);    vm_size_t pagesize;    vm_statistics_data_t vmstat;    host_page_size(host, &amp;pagesize);    host_statistics(host, HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;size);    return vmstat.free_count * pagesize;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC 和 Core Foundation</title>
      <link href="/2018/02/04/Foundation/"/>
      <url>/2018/02/04/Foundation/</url>
      
        <content type="html"><![CDATA[<h1 id="Core-Foundation"><a href="#Core-Foundation" class="headerlink" title="Core Foundation"></a>Core Foundation</h1><p>Core Foundation 杠框架使用一个朴素的C语言编写的纯手工创建的对象系统。CF对象具有它们自己的音独的引用计数系统。从其名称中具有的单词”Create”、”Copy”的函数获得的对象在返回时将具有“+1的保留计数”。CFRetain(aCFObject)函数将把aCFObject的保留计数加1，而CFRelease(aCFObject)函数则会把aCFObject的保留计数减1。 当一个对象的保留计数归零时，它将被取消分配。如果你从一个“Create”、“Copy”函数接收到对象，最终必须通过调用CFRelease来抵消创建或复制。如果不这样做，就会产生内存泄漏。</p><p>ARC不会使用这个单独的引用计数系统自动化。 <strong>如果你在使用CF对象，就要负责理解手动引用计数，并且正确地保留和释放你的CF对象</strong></p><h1 id="ARC-与-Core-Foundation-之间的免费桥接"><a href="#ARC-与-Core-Foundation-之间的免费桥接" class="headerlink" title="ARC 与 Core Foundation 之间的免费桥接"></a>ARC 与 Core Foundation 之间的免费桥接</h1><p>从免费桥接的一方到别一方的强制转换对于ARC而言都是一个问题。当把一个对象从CF强制转成OC(或者采用相反方向)时，结果将得到单个对象，它的保留计数可以被两个不同的不会彼此交流的系统操纵。ARC对CF的内存管理约定一无所知，使事情更坏的是，你可以直接控制其中一个系统（CF），但不能控制另一个系统ARC。<strong><em>就像由两位厨师一起做一碗汤一样，会引起烹饪麻烦。</em></strong><br>编译器避免这种麻烦的方式是禁止在OC对与CF对象之间进行强制转换。解决这个问题的方式是：<strong>通过一种称为 *</strong>桥接强制转换（brige casts）<strong>* 的特殊的强制转换类型给ARC提供一些额外的信息</strong> 有以下三种情况</p><ul><li>强制转换不转移所有权</li><li>强制转换把所有权转出CF并转入ARC中</li><li>强制转换把所有权转出ARC 并转入CF中</li></ul><h2 id="强制转换不会转移所有权"><a href="#强制转换不会转移所有权" class="headerlink" title="强制转换不会转移所有权"></a>强制转换不会转移所有权</h2><p>在这种情况下，一方只会从另一方临时“借用”对象，而不会转移所有权<br><code>__bridge</code>告诉ARC在强制转换下不会转移所有权。<br><pre><code>&#x2F;&#x2F; CF----&gt;OCCFStringRef cfstr =  CFStringCreateWithCString(NULL, &quot;hello cfstring!&quot;, kCFStringEncodingUTF8);NSString * ocstr = (__bridge NSString*)cfstr;&#x2F;&#x2F;只是类型的转换，没有进行所有权的交接NSLog(@&quot;%@&quot;,ocstr);CFRelease(cfstr);&#x2F;&#x2F; 内存管理仍需要所手动释放</code></pre></p><pre><code>&#x2F;&#x2F;OC --&gt; CFNSString * ocString = @&quot;hello objective C string!&quot;;CFStringRef cfstring = (__bridge CFStringRef)ocString;&#x2F;&#x2F; 只是类型转换，对象释放仍由ARC来进行管理，不需要进行手动释放该cfstring</code></pre><pre><code>&#x2F;&#x2F; 生成gif文件路径   NSString * gifpath = [imgDir stringByAppendingPathComponent:@&quot;newgif.gif&quot;];   CFURLRef  urlref = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (__bridge CFStringRef)gifpath, kCFURLPOSIXPathStyle, NO);   CFRelease(urlref);</code></pre><pre><code>NSString * gifpath = [imgDir stringByAppendingPathComponent:@&quot;newgif.gif&quot;];CFURLRef  urlref = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFBridgingRetain(gifpath)&#x2F;**只做类型的转换，不需要移交所有权*&#x2F;, kCFURLPOSIXPathStyle, NO);&#x2F;&#x2F;这里会造内存泄漏</code></pre><h2 id="强制转换把所有权转出CF并转入ARC中"><a href="#强制转换把所有权转出CF并转入ARC中" class="headerlink" title="强制转换把所有权转出CF并转入ARC中"></a>强制转换把所有权转出CF并转入ARC中</h2><p><code>__bridge_transfer</code>强制转换将把所有权从CF转移给ARC。它告诉ARC在CF一方有一个没有抵消的保留计数，最终必须通过一个release抵消它。ARC负责发送该release消息<br><pre><code>CFStringRef cfstring = CFStringCreateWithCString(NULL, &quot;hello CFStringRef object&quot;, kCFStringEncodingUTF8);NSString * ocString = (__bridge_transfer NSString*)cfstring;&#x2F;&#x2F; ARC 将接替CF的所有权，负责ocString的释放，其将会在不再使用ocString对象时，向该对象发送一条release消息NSLog(@&quot;%@&quot;,ocString);</code></pre></p><h2 id="强制转换把所有权转出ARC并转入CF中"><a href="#强制转换把所有权转出ARC并转入CF中" class="headerlink" title="强制转换把所有权转出ARC并转入CF中"></a>强制转换把所有权转出ARC并转入CF中</h2><p><code>__bridge_retain</code>强制转换采用的是相反的方向，它把所有权从ARC中转移给CF。它告诉ARC抵消对象创建的责任传递给了CF。当CF代码用完对象后，它必须利用对象作为参数来调用<code>CFRelease()</code><br><pre><code>NSString * ocObject = @&quot;我将放器ARC的内存管理，转入CF的内存管理系统&quot;;CFStringRef cfObject = (__bridge_retained CFStringRef)ocObject;&#x2F;&#x2F; CF接管现OC对象的所有权，它的释放由CF来负责,必须手动进行释放CFRelease(cfObject);</code></pre></p><h2 id="利用宏隐藏强制转换"><a href="#利用宏隐藏强制转换" class="headerlink" title="利用宏隐藏强制转换"></a>利用宏隐藏强制转换</h2><p>可以利用宏<code>CFBrigingRelease()</code>和<code>CFBrigingRetain()</code>分别隐藏<code>__bridge_transfer</code>和<code>__bridge_retain</code>强制转换，来改进代码的美感。<br><pre><code>&#x2F;&#x2F; 以下两行代码将做相同的事情NSString * ocString = (__bridge_transfer NSString*)cfstring;NSString * ocString = CFBridgingRelease(cfstring);&#x2F;&#x2F; 以下两行代码将做相同的事情CFStringRef cfObject = (__bridge_retained CFStringRef)ocObject;CFStringRef cfObject = CFBridgingRetain(ocObject);</code></pre></p><h2 id="与void-之间来回进行强制转换"><a href="#与void-之间来回进行强制转换" class="headerlink" title="与void*之间来回进行强制转换"></a>与void*之间来回进行强制转换</h2><p>ARC禁止在对象指针与类型化<code>void*</code>的变量之间直接进行强制转换。<br>其原因与ARC禁目对象指针与CF类型之间直接进行大多数强制转换原因相同。如果把一个对象指针强制转换成<code>void*</code>，将把该对象提供给一个未知量。ARC不会管理非OC指针，因为它无法跟踪一个<code>void*</code>变量中存储的对象所发生的事情，别外，如果把一个<code>void*</code>指针强转为OC对象，ARC将无法确定对象的所有权状态。<br>如果确信知道自己正在做什么，可以使用桥接来转换支配ARC：<br><pre><code>NSMutableArray * array = [NSMutableArray arrayWithObject:@&quot;hello OC object&quot;];&#x2F;&#x2F;    void * cPointer = (void*)array;&#x2F;&#x2F;Cast of Objective-C pointer type &#39;NSMutableArray *&#39; to C pointer type &#39;void *&#39; requires a bridged cast  这样编译器会不报错void * cPointer = (__bridge void*)array;&#x2F;&#x2F;这样是OK 的</code></pre><br><strong><em>小心：  __bridge 强制转没有内存管理的隐含意思，并且`void</em><code>不是强引用，如果指向对象的所有的强引用都消失了，就会取消分配对象，并且</code>void<em>`变理可能保存一个指向死对象的指针。 </em></strong></p><h1 id="ARC-和额外的自动释放池"><a href="#ARC-和额外的自动释放池" class="headerlink" title="ARC 和额外的自动释放池"></a>ARC 和额外的自动释放池</h1><p>使用ARC，你将不知道特定的对象是否将被释放或者自动释放，或者它将被取消分配的确切时间，不过当你的代码将创建许多只在短时间内需要的对象时，仍然可以使用额外的自动释放时来限制内存占用：</p><pre><code>   for (int i = 0; i&lt;10000; i++) {        @autoreleasepool{            // 创建监时的对象        }    }</code></pre><p>@autoreleasepool的作用域确保：在循环的单独一次迭代中创建的任何临时对象都会在不晚于循环的底部位置收到一个release消息，在那个位置@autoreleasepool的作用域将终结，并会清空对应的自动释放池，ARC可能决定在更早的时间给这样的对象发送一条release消息，而不是自动释放它们，但是额外的@autoreleasepool作用域将会阴止随着循环的每次迭代而使用当前自动释放池中的对象数量增加的情况发生。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCD</title>
      <link href="/2018/01/27/GCD/"/>
      <url>/2018/01/27/GCD/</url>
      
        <content type="html"><![CDATA[<h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><p>GCD(Grand Central Dispatch)是一个能让开发者轻松写出并发代码的强大特性。它把管理多个线程及线程同步的重担转移给了操作系统。使用GCD时，只需要创建能够彼此独立执行的单元，而让操作系统为你处理队列和同步。iOS上的GCD实现了一系列包含了一系列的C语言扩展、API、和一个运行时引擎。如果有多个处理器，GCD会自动确保独立单元运行在多个处理器上。<br>GCD提供了三种派发队列：<strong>串形队列</strong>、<strong>并发队列</strong>和<strong>主队列</strong>。可以把任务加入这些队列。串形队列按先进先出（FIFO）的顺序，在同一时间只执行一个任务。并发队列也是按照FIFO顺序，但并行地执行任务。主队列在主线程上执行操作，通常用于不同的串行或并发队列上执行线程间的同步。<br>GCD是iOS多任务的核心，广泛应用在系统在系统层的几乎各个方面。NSOPerationQueue是GCD的基础上实现的，而基本的队列原理都类似。只要把一个块添加到分派队列，而不是把NSOperation添加到NSOperationQueue。<br>分派队列要比操作队列更底层。块添加到分配队列后就无法取消了。分派队列是严格FIFO结构。所以无法在队列中使用优先级或者调整块的次序。</p><h2 id="源和定时器"><a href="#源和定时器" class="headerlink" title="源和定时器"></a>源和定时器</h2><p>分派源是一种方便的事件处理方法。先注册处理事件，当事件发生后，你就能得到通知。如果在系统还没有来得及通知你之前事件就已经发了多次，那么这些事件会被合并为一个事件。这对于底层的高性能I/O代码很有用。分派源可以应答UNIX信号、文件系统变化、其他进程的变化以及mach port事件。它们在MAC上很有用。<br><strong><em>定时器源</em></strong>在iOS上很有用。GCD定时器源基于分派队列。而不是像NSTimer那条基于运行循环，这意味着把它们用于多线程应用中要容易得多。GCD定时器不用块而不是用选择器。所以不需要一个独立的方法处理定时器，这样也更容易避免重复GCD定时器的循环保留。<br><strong><em>分派屏障（dispathc barrier）</em></strong>可以在并发队列内部创建一个同步点，当它运行时，即使用有并发条件和空闲的处理器核心，队列中也不能运行。听起来像互斥（写入）锁，确实如此。没有屏障的块可以看作共享（读取）锁。只要所有对资源的访问都要通过这个队列的进行，那么屏障就能以极低的代价提供同步。<br>作为比较，可以使用@syschronize管理多线和访问，它会在参数上加一个互斥锁。</p><h2 id="队列目标和优先级"><a href="#队列目标和优先级" class="headerlink" title="队列目标和优先级"></a>队列目标和优先级</h2><p>GCD中的队列是有层次结构的，只有全局队列才是调度运行的，可以用<code>dispatch_get_global_queue</code>和下列某个优先级参数来访问这些队列</p><ul><li>DISPATCH_QUEUE_PRIORITY_HIGH</li><li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li><li>DISPATCH_QUEUE_PRIORITY_LOW</li><li>DISPATCH_QUEUE_PRIORITY_BACKGROUND<br>所有这些队列都是并发的，GCD调度与HIGH队列中线程数量相同的块。当high队列空了以后就转移到default队列。以些类推。系统根据当前的空余处理器核心数量和系统负载按需创建或销毁线程。<br>创建队列时，它被连接到某个全局对队列（全局队列就是它的目标）。默认情况下连接到default队列。当一个块到了队列的最前面，块其实就到了目标队列的最尾。块到了全局队列的最前面才会执行，可以使用<code>dispatch_set_target_queue</code>改变目标队列</li></ul><h2 id="分派组"><a href="#分派组" class="headerlink" title="分派组"></a>分派组</h2><p>分派组类似于NSOpertion中的依赖关系。首先创建一个组<br><pre><code>dispatch_group_t group = dispatch_group_create();</code></pre></p><p>*PS. 组本身没有任何配置项，它们没有绑到任何队列上，只是一个组块。一般通过<code>dispatch_group_async</code>把块添加到组，类似<code>dispatch_async</code>:<br><pre><code>dispatch_group_async(group, queue, ^{        });</code></pre><br>然后调用<code>dispatch_gourp_notify</code>注册一个块，即当组执行完毕后调用它<br><pre><code>dispatch_group_notify(group, queue, ^{            });</code></pre><br>组里所有的块执行完毕时，block就会被调用到queue上，可以注册同一个组的多个通知。可以把这些通知块放到不同的队列上。如果调用<code>dispatch_group_notify</code>时队列上没有任何块，那么马上触发通知。可以在配置组上时用<code>dispatch_supend</code>暂停队列来防止这种情况，配置完后用<code>dispatch_resume</code>启动队列。<br>实际上组并不像追踪任务一样追踪块，可以直接使用<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>增加和减少任务数量。<br><pre><code>dispatch_async(queue, ^{    dispatch_group_enter(group);    dispatch_sync(queue, ^{            });    dispatch_group_leave(group);});</code></pre><br>调用<code>dispatch_group_wait</code>会阻塞当前线程，直到整个组执行完毕。 </p><h1 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h1><h2 id="什么时候应该使用GCD，什么时候应该使用NSOperationQueue"><a href="#什么时候应该使用GCD，什么时候应该使用NSOperationQueue" class="headerlink" title="什么时候应该使用GCD，什么时候应该使用NSOperationQueue?"></a>什么时候应该使用GCD，什么时候应该使用NSOperationQueue?</h2><p>两者的相同点与异点：</p><ol><li>NSOperationQueue 用GCD创建，是GCD的高级抽象</li><li>GCD只支持FIFO队列,而加入NSOperationQueue队列的操作可以被重新排序（重新设置优先级）</li><li>NSOperationQueue支持在操作之间设置依赖关系，而GCD不支持。如果一个操作需要别一个操作生成的数据，可以让这个操作依赖别一个操作。NSOpertionQueue会自动按照正确的顺序执行。而GCD没有内建依赖关系支持</li><li>NSOperationQueue 兼容KVO. 这意味着你可以观察任务的状态。那么我们应该只用NSoperationQueue而不用GCD吗？答案是否定的。NSOperationQueue的执行速度比GCD慢.如果用Instruments查看代码性能并且觉得需要性能提升的话，那就用GCD。通常情况下底层代码中，任务之间可能不会相互依赖或者没有必要用KVO观察状态。</li></ol><h1 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h1><p>多任务最基本的形式就是运行循环，多任务最早在NeXTSTEP上出现时使用的就是这种形式<br>每个iOS程序都是由一个处于阻塞状态的do/while循环驱动，当有事件发生时，就把事件分派给合适的监听器。如此反复直至循环结束。处理分派的对象就叫作运行循环（NSRunloop）</p><blockquote><p>运行循环其实就是一个大的do/while循环，它运行在某个线程中，从各种事件队列中取得事件（每次取一个），然后把它分派给合适的监听器。这就是iOS的核心</p></blockquote><p>NSTimer基于运行循环进行消息派发。调度NSTimer时，其实是要求当前的运行循环在某个特定的时间分派某个选择器。运行循环的每次迭代都会对时间进行检查并且触发所有过期的选择器，延迟执行的方法也是通过调度定时器实现的。</p><h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p>NSOperation是封装任务的基本单位，在OC中用块来表示，NSOperation支持优先级、依赖关系和取消<br>NSOperationQueue尝试管理生成的线程数，但是大多数情况下，它做得并不好。NSOperationQueue会同时调度太多的操作，如果明确告诉NSOperationQueue不要超过CPU数量的计算型密集操作，那么简单代码就跑得更快了。<br><pre><code>#include &lt;sys&#x2F;sysctl.h&gt;unsigned int countOfCores() {    unsigned int ncpu;    size_t len = sizeof(ncpu);    sysctlbyname(&quot;hw.ncpu&quot;, &amp;ncpu, &amp;len, NULL, 0);    return ncpu;}</code></pre></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>URL的组成部分</title>
      <link href="/2018/01/10/URL%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
      <url>/2018/01/10/URL%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="URL的组成部分"><a href="#URL的组成部分" class="headerlink" title="URL的组成部分"></a>URL的组成部分</h1><p>URL(统一资源定位符)是URI(通用资源标识)的特定类型，URL通常在因特网上查找现有资源。当Web客户机向服务器发出对资源的请求时，使用URL。<br>URI 和 URL 的概念由因特网协会和 IETF（因特网工程任务组织）请求评论文档 RFC 2396 统一资源标识（URI）：一般语法定义（<a href="http://www.ietf.org/rfc/rfc2396.txt）。简要地说，***URI" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2396.txt）。简要地说，***URI</a> 是定义为识别资源的任何一个字符串<strong>*。</strong>URL 定义为按资源的位置或用户访问它的方式，而不是按资源的名称或其他属性来识别资源的那些 URI。**</p><p>HTTP（HTTPS）的 URL 通常由三或四个组成部分组成：</p><ul><li><strong>规则</strong><ul><li>规则识别用于访问因特网上的资源协议</li></ul></li><li><strong>主机</strong><ul><li>主机名识别拥有资源的主机</li></ul></li><li><strong>路径</strong> <ul><li>路径识别主机中Web客户机要访问的特定资源</li></ul></li><li><strong>查询字符</strong> <ul><li>如果使用查询字符串，那么它跟随路径部分，并且提供一串字符串，资源使用这些字符串可以完成某些操作（例如，作为用于搜索的参数或用于处理的数据）。 查询字符串通常是一串名称和值对，例如，q=bluebird。</li></ul></li></ul><p>URL 的规则和主机部分不定义为区分大小写，但是路径和查询字符串是区分大小写的。通常，整个 URL 指定为小写字母。<br>URL 的组成部分如下所示进行组合和定界：</p><pre><code>scheme://host:port/path?query</code></pre><ul><li>规则后跟冒号和两个正斜杠。</li><li>如果指定端口号，那么主机名后面是号码，并用冒号分隔。</li><li>路径名以单正斜杠开始。</li><li>如果指定查询字符串，那么在它的前面加个问号。</li></ul><p>图 1. HTTP URL 语法<br>阅读语法图跳过直观语法图<br>                            .-:80—–.                      </p><blockquote><blockquote><p>-<a href="http://--+-host" target="_blank" rel="noopener">http://--+-host</a> name–+–+———+–/–path component——&gt;<br>            ‘-IP address-‘  ‘-:–port-‘                      </p></blockquote></blockquote><blockquote><p>–+—————–+—————————————–&gt;&lt;<br>   ‘-?–query string-‘</p></blockquote><p>URL 的后面可以跟片段标识。URL 与片段标识之间使用的分隔符是字符 #。<strong>片段标识用于使 Web 浏览器指向它刚检索的项中的引用或函数</strong>。 例如，如果 URL 标识 HTML 页面，那么可使用片段标识，以子节的标识来指示页面中的子节。对于这种情况，Web 浏览器通常向用户显示页面， 以使用户可以看到子节。根据项的介质类型以及为该介质类型的片段标识所定义含义的不同，Web 浏览器为片段标识所采取的操作也会不同</p><pre><code>https://item.jd.com/11818781778.html#crumb-wrap</code></pre><h1 id="OC中如何获取URL的中各个组成部分"><a href="#OC中如何获取URL的中各个组成部分" class="headerlink" title="OC中如何获取URL的中各个组成部分"></a>OC中如何获取URL的中各个组成部分</h1><p>为获取URL中的各个组成部分，Foundation框架为我们提供了一个<code>NSURLComponents</code>类，通过该类，可以获取到URL中和各个组成部分</p><pre><code class="objc">    // NSURLComponents 相关字段    @property (nullable, copy) NSString *scheme; // 规则， Attempting to set the scheme with an invalid scheme string will cause an exception.    @property (nullable, copy) NSString *user;//用户    @property (nullable, copy) NSString *password;//密码    @property (nullable, copy) NSString *host;//主机    @property (nullable, copy) NSNumber *port; // 端口 Attempting to set a negative port number will cause an exception.    @property (nullable, copy) NSString *path;//路径    @property (nullable, copy) NSString *query;//查询字符    @property (nullable, copy) NSString *fragment;//片段标识    @property (nullable, copy) NSArray&lt;NSURLQueryItem *&gt; *queryItems; //查询字段数组</code></pre><p>示例</p><pre><code class="objc">    NSString * urlString = @&quot;http://54.223.156.84:9120/relayserver/spring/commands/command?commandType=cmd_type_ad&amp;commandName=&amp;commandStatus=&amp;code=10001&amp;id=test_snapshow_ios_first_test&amp;page=&amp;restrict=false&quot;;    urlString = @&quot;https://item.jd.com/11818781778.html#crumb-wrap&quot;;    // 创建组件对象    NSURLComponents *components = [NSURLComponents componentsWithString:urlString];    //规则    NSString * scheme = components.scheme;    // 路径    NSString * path = components.path;    //端口    NSString * port = components.port;    //查询字符串    NSString * query  = components.query;    //片段标识    NSString * fragment = components.fragment;    //获取查询参数    NSMutableDictionary *paramsDic = [NSMutableDictionary dictionary];    for (NSURLQueryItem *item in components.queryItems) {        [paramsDic setValue:item.value forKey:item.name];    }</code></pre><p>添加查询字段</p><pre><code class="objc">NS_ASSUME_NONNULL_BEGIN@interface NSURLComponents (addQueryItem)-(void)addQueryItem:(NSURLQueryItem*)queryItem;@endNS_ASSUME_NONNULL_END@implementation NSURLComponents (addQueryItem)-(void)addQueryItem:(NSURLQueryItem *)queryItem{    NSMutableArray * queryitems = [NSMutableArray arrayWithArray:self.queryItems];    [queryitems addObject:queryItem];    self.queryItems = queryitems;}@end</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>runtime - 实现对象的自动拷贝</title>
      <link href="/2018/01/06/runtimecopy/"/>
      <url>/2018/01/06/runtimecopy/</url>
      
        <content type="html"><![CDATA[<p>在我们开发过程中，有时会遇到对象进行拷贝的情况，在对象属性少的情况下，我们可以直接在 <code>copyWithZone:/mutableCopyWithZone:</code> 方法里手动对复制后的对象的相应属性赋值，但在属性成员很多的情况及通过runtime在运行时关联属性时，我们这种手动赋值的方式就有点应赋不过来了。runtime是OC的一把利器，用得好可以帮我们节省很多事情。废话不多说，用代码说话。</p><ol><li>为对象增加一个扩展并遵守 <code>&lt;NSCopying,NSMutableCopying&gt;</code>协议 <pre><code> #import &lt;objc/runtime.h&gt; @interface Person()&lt;NSCopying,NSMutableCopying&gt; @end</code></pre></li><li><p>实现协议  </p><pre><code> -(id)copyWithZone:(NSZone * )zone{     id objCopy = [[[self class] allocWithZone:zone] init];     // 1.获取属性列表     unsigned int propertyCount = 0;     objc_property_t * propertyArray = class_copyPropertyList([self class], &amp;propertyCount);     for (int i=0; i&lt;propertyCount; i++) {         objc_property_t  property = propertyArray[i];         // 2.属性名字         const char * propertyName = property_getName(property);         NSString * key = [NSString stringWithUTF8String:propertyName];         // 3.通过属性名拿到属性值         id value=[self valueForKey:key];         NSLog(@&quot;name:%s,value:%@&quot;,propertyName,value);         // 4.判断 值对象是否响应copyWithZone         if ([value respondsToSelector:@selector(copyWithZone:)]) {             //5. 设置属性值             [objCopy setValue:[value copy] forKey:key];         }else{             [objCopy setValue:value forKey:key];         }     }     //*****切记需要手动释放     free(propertyArray);     return objCopy; }</code></pre><pre><code> -(id)mutableCopyWithZone:(NSZone *)zone{     id objcopy = [[[self class]allocWithZone:zone] init];     //    1.获取属性列表     unsigned int count = 0;     objc_property_t* propertylist = class_copyPropertyList([self class], &amp;count);     for (int i = 0; i &lt; count ; i++) {         objc_property_t property = propertylist[i];         //    2.获取属性名         const char * propertyName = property_getName(property);         NSString * key = [NSString stringWithUTF8String:propertyName];         //    3.获取属性值         id value = [self valueForKey:key];         //    4.判断属性值对象是否遵守NSMutableCopying协议         if ([value respondsToSelector:@selector(mutableCopyWithZone:)]) {             //    5.设置对象属性值             [objcopy setValue:[value mutableCopy] forKey:key];         }else{             [objcopy setValue:value forKey:key];         }     }     //*****切记需要手动释放     free(propertylist);     return objcopy; }</code></pre></li></ol><p>通过以上两个方法的实现，可以应付对象的拷贝场景。</p><blockquote><p>小结下:<br>    使用runtime机制实现对象的拷贝有以下几个步骤:</p><pre><code>* 导入&lt;objc/runtime.h&gt;头文件* 遵守`&lt;NSCopying,NSMutableCopying&gt;`协议* 实现`mutableCopyWithZone:/copyWithZone:`方法    * 获取类的属性列表    * 对属性列表进行遍历        * 拿到属性        * 拿到属性名        * 通过属性名拿到属性值, 使用`valueForKey:`方法        * 判断值对象是否响应协议方法，将值赋值给新对象的相应属性    * 释放属性指针</code></pre></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>copy</title>
      <link href="/2018/01/06/copy/"/>
      <url>/2018/01/06/copy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English-Level4-Unit3</title>
      <link href="/2017/12/10/English-Level4-Unit3/"/>
      <url>/2017/12/10/English-Level4-Unit3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题与解决办法"><a href="#问题与解决办法" class="headerlink" title="问题与解决办法"></a>问题与解决办法</h1><h2 id="个人问题"><a href="#个人问题" class="headerlink" title="个人问题"></a>个人问题</h2><p>如果你无法放弃止做某事，你就是对它addicted，或你对它有了一种addiction，下面就是一些常见的沉溺。  </p><p>He’s addicted to cigarettes.<br>他有烟瘾。                  </p><p>She’s addicted to coffee.<br>她喝咖啡上瘾。  </p><p>They’re addicted to gambling.<br>他们嗜赌成瘾。  </p><p>He’s addicted to alcohol. He’s an alcoholic.<br>他嗜酒成瘾。他是个酒鬼。  </p><p>以下是一些其他常见的个人问题。  </p><p>She has financial problems.    她碰到了一些经济上的问题。  </p><p>He has a weight problem. He’s overweight.    他有体重问题。他非常胖。  </p><p>I have a problem sleeping. I have insomnia.    我睡不着觉。我患有失眠症。  </p><p>They have marital problems.    他们遇到了婚姻问题。  </p><h2 id="阅读找出大意"><a href="#阅读找出大意" class="headerlink" title="阅读找出大意"></a>阅读找出大意</h2><p>找出段落或文本的大意是一种重要的阅读技巧。大意是指梗概，不是具体细节。了解大意后，更容易理解文本。</p><p>你通常可以通过确定主题句来找出大意。主题句一般位于段首，但也可以出现在其他位置。</p><p>如果你不确定主题句，你可以通过用自己的话概括来得出文本大意。寻找重复的单词或观点来帮助概括。</p><p>确定大意时不可太狭隘，也不能太宽泛。一个陈述即便真实，但可能过于具体或笼统，不可能是大意。</p><h2 id="谈论问题"><a href="#谈论问题" class="headerlink" title="谈论问题"></a>谈论问题</h2><p>在确定一个问题后，你可能想详细加以解释。以下是一些帮助你进行解释的表达。  </p><p>I have insomnia. The problem is that I can’t stop thinking about work.         我患有失眠症。问题在于我老想着工作。    </p><p>She can’t quit smoking. One big problem is that her husband smokes, too.         她戒不了烟。一个大问题是她的丈夫也抽烟。  </p><p>that可省略而不会造成意义的改变。  </p><p>He is very overweight. The trouble is he eats too much chocolate.         他非常胖。问题是他吃太多巧克力了。  </p><p>She can’t quit smoking. One big problem is her husband smokes, too.         她戒不了烟。一个大问题是她的丈夫也抽烟。  </p><h2 id="情态动词-‘ought-to’和’had-better’"><a href="#情态动词-‘ought-to’和’had-better’" class="headerlink" title="情态动词 ‘ought to’和’had better’"></a>情态动词 ‘ought to’和’had better’</h2><p>你可以使用情态动词 ought to 和 had better 来给予个人建议。Had better 语气强于ought to，在提出强烈的建议时使用。</p><p>He’s very overweight. He ought to lose some weight.    他很胖，应该减减肥。</p><p>Your health is very poor. You had better quit smoking.    你身体很不好，最好把烟戒了。</p><p>had better 的否定是 had better not。ought to 的否定是 ought not to，但很少使用。</p><p>You had better not start smoking. It’s a terrible habit.    你最好不要开始吸烟。这个习惯很不好。</p><p>She has terrible insomnia. She ought not to drink coffee in the evening.    她严重失眠。她晚上不应该喝咖啡。</p><h2 id="提出强烈建议"><a href="#提出强烈建议" class="headerlink" title="提出强烈建议"></a>提出强烈建议</h2><p>提出强烈建议有许多方法。学习这些不同的表达。</p><p>Make sure to get enough sleep.    务必保持充足的睡眠。</p><p>Make sure not to drink coffee at night.    晚上千万别喝咖啡。</p><p>Be sure to exercise every week.<br>务必每周锻炼身体。</p><p>Be sure not to eat too much fast food.    务必不要吃太多快餐。</p><p>Don’t start smoking.    不要开始吸烟。</p><p>You ought to give up gambling.<br>你应该戒赌。</p><p>You had better stop smoking.    你最好戒烟。</p><p>You had better not talk to him. You’re angry!    你最好别和他说话。你很生气！</p><h3 id="工作问题"><a href="#工作问题" class="headerlink" title="工作问题"></a>工作问题</h3><p>与生活中其他方面一样，有时工作中也会碰到一些问题。一位员工可能需要与老板就以下方面谈话：</p><p>being late = tardiness    迟到</p><p>being disorganized    缺乏条理的</p><p>being lazy    懒惰</p><p>being sloppy    粗心</p><p>being argumentative    好辩</p><p>being offensive    无礼</p><p>not being flexible    处事不灵活</p><p>not following instructions    不遵守指示</p><p>not working well with the team    和团队合作不愉快</p><p>not meeting deadlines    没有如期完成</p><h3 id="‘who’-引导的关系从句"><a href="#‘who’-引导的关系从句" class="headerlink" title="‘who’ 引导的关系从句"></a>‘who’ 引导的关系从句</h3><p>用关系从句连接两个句子。关系从句使您的写作和讲话更流利，并帮助您避免重复。关系代词 who 用来指人。</p><p>We have a lot of engineers. The engineers work late.                  </p><p>We have a lot of engineers who work late.</p><p>在例子中，主句We have a lot of engineers 是一个完整的句子。关系从句who work late不是一个完整的句子，故不能独立成句。</p><h2 id="。。。"><a href="#。。。" class="headerlink" title="。。。"></a>。。。</h2><p>So what’s going on?<br>那么，发生什么事了？</p><p>What’s the story?<br>怎么回事？</p><p>We have to figure out a solution.<br>我们必须想出解决的办法。</p><p>Another possibility would be …<br>另一种可能是……</p><p>Would that work for you?<br>你觉得这可行吗？</p><p>Yeah, that would work.<br>对，这可行。</p><p>Let’s see how it goes.<br>我们看看会怎么样。</p><h2 id="‘that’-引导的关系从句"><a href="#‘that’-引导的关系从句" class="headerlink" title="‘that’ 引导的关系从句"></a>‘that’ 引导的关系从句</h2><p>用关系代词连接两个句子。用关系代词that 代替事物。</p><p>I work for a company. The company has lots of problems.</p><p>I work for a company that has lots of problems.</p><p>在该例子中，主句I work for a company 是一个完整句，关系从句that has lots of problems 不是完整句，故不能单独成句。</p><p>记住，使用关系从句可以让你的作文和讲话更流畅，避免重复。</p><h2 id="提出解决办法"><a href="#提出解决办法" class="headerlink" title="提出解决办法"></a>提出解决办法</h2><p>使用类似表达来提出解决办法:</p><p>One solution could be that we hire a new manager.    一种解决办法是我们雇一位新经理。</p><p>Another possibility would be to have a team meeting.    另一种可能是开一场团队会议。</p><p>为了竭力提出解决方法，使用类似下列表达。</p><p>I really think that the only solution is to replace the entire management team.    我真的认为唯一的解决办法是替换整个管理团队。</p><p>The only way to solve this problem is to buy the company.    解决问题的唯一办法是买下这家公司。</p><p>I strongly suggest that we deal with this problem immediately.    我强烈建议我们即刻处理这一问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English-Level4-Unit2</title>
      <link href="/2017/11/27/English-Level4-Unit2/"/>
      <url>/2017/11/27/English-Level4-Unit2/</url>
      
        <content type="html"><![CDATA[<h1 id="看病"><a href="#看病" class="headerlink" title="看病"></a>看病</h1><h3 id="基本病症"><a href="#基本病症" class="headerlink" title="基本病症"></a>基本病症</h3><p>使用以下医疗词汇，搭配动词 have 描述生病症状。</p><p>I have a fever.    我发烧了。</p><p>He has diarrhea.    他拉肚子了。</p><p>She has a bad cough.    她咳嗽得很厉害。</p><p>使用 sore 一词表示身体某个部位疼痛。</p><p>I have a sore throat.    我嗓子疼。</p><p>使用后缀 -ache 表示身体某个部位疼痛。该后缀并不适用于所有身体部位，只适用于 head、stomach、back 和 tooth。</p><p>He has a headache.    他头痛。</p><p>I have a stomachache.    我胃痛。</p><p>使用以下医疗词汇，搭配动词 be 或 feel 使用。</p><p>I’m dizzy. I feel dizzy.    我头晕。我感觉头晕。</p><p>She’s nauseous. She feels nauseous.    她感觉恶心。她觉得恶心。</p><p>如果是呕吐，使用动词 to vomit。</p><p>I’ve been vomiting for about an hour.    我吐了一个小时左右。</p><h3 id="现在完成时进行时"><a href="#现在完成时进行时" class="headerlink" title="现在完成时进行时"></a>现在完成时进行时</h3><p>用现在完成进行时谈论一种在过去开始一直延续到现在的病症或病。用 I have been + 动词 + -ing结构。</p><p>I have been vomiting a lot.    我一直在吐，吐了好多。</p><p>I have been having problems sleeping.    我一直都难以睡眠。</p><p>用for 增加有关时间的信息。</p><p>I have been feeling very bad for the last two days.    最近两天我一直都感觉不佳。</p><p>医生也可能使用现在完成进行时提问。</p><p>How long has this been going on?    这事持续多久了？</p><p>How long have you been feeling like this?    你这样的感觉多久了?</p><h3 id="‘For’-和-‘since’"><a href="#‘For’-和-‘since’" class="headerlink" title="‘For’ 和 ‘since’"></a>‘For’ 和 ‘since’</h3><p>注意，在使用 since 时，分句顺序可以变换。如果 since 引导的分句位于句首，请在该分句之后加上逗号。</p><p>Since I got home, I’ve been feeling terrible.    自从我回到家，我一直感到恐惧。</p><p>I’ve been feeling terrible since I got home.    自从回到家，我一直都感到恐惧。</p><p>注意： for 引导的分句通常不这样改变。</p><h3 id="医药词汇"><a href="#医药词汇" class="headerlink" title="医药词汇"></a>医药词汇</h3><p>医药和药物有许多专业词汇。了解这些词汇非常重要，这样你可以和药剂师交流，拿到自己需要的药物。形容获得 prescription 的动作，使用动词 fill。当你要去药房取药时使用动词 pick up。</p><p>I’m going to the pharmacy.    我要去药房。</p><p>He talked to the pharmacist.    他跟那位药剂师说话。</p><p>She filled a prescription for her medication.    她按处方配了药。</p><p>药剂师可能询问你是否不能服用一些药物。注意形容词结构 + to：</p><p>Are you allergic to any medications?    你药物过敏吗？</p><p>使用下列词汇谈论你的药物。谈论在家用药时，使用 medicine 搭配动词 take。当你去药房时，使用更正式的词汇 medication。</p><p>You forgot to take your medicine.    你忘记吃药了。</p><p>I’m here to pick up my medication.    我来取药的。</p><p>药物有各种不同形式。pill 一词常用于指固体药物。Capsules 和 tablets 是两种最常见的药物形状。服药的动作使用动词 take。</p><p>I have to take three pills a day.    我每天要吃三片药。</p><p>My medicine comes in tablets.    我的药是片状的。</p><p>She takes four capsules a day.    她每天吃四粒。</p><p>由于处方药有时由保险支付或有折扣，你可能会问药剂师你的医疗计划是否支付某种药品。使用动词 cover，询问你要承担的费用。</p><p>Does my insurance cover this medication?    我的保险覆盖这种药吗？</p><h3 id="阅读处方标签"><a href="#阅读处方标签" class="headerlink" title="阅读处方标签"></a>阅读处方标签</h3><p>药有不同形式-有如 tablets或capsules的固体药物，或如你用teaspoons服用的如syrups的液体药物。你将在处方标签上找到你的施药信息。</p><p>Take four tablets, twice a day.    每次四片，每天两次。<br>The medicine comes in capsules. Take two every day.    胶囊包装，每天两颗。<br>Take one teaspoon, after meals.      餐后服用一匙。</p><p>标签也会提醒你有关的side effects, 你服药时遇到的难题。这会包括drowsiness 或loss of appetite。</p><p>The side effect of this medicine is that it may cause drowsiness.    本药有副作用，可能引起昏睡。<br>Side effects may include loss of appetite.    副作用可能包括食欲不振。</p><p>标签上也许会告诉你药的用量-maximum dosage -和谁suitable for该药-成年人或是小孩。</p><p>Maximum dosage: four capsules per day    最大用量：每日四颗<br>Suitable for: adults and children over 12 years old    适用：成人和 12 岁以上的孩童</p><h3 id="事故和受伤"><a href="#事故和受伤" class="headerlink" title="事故和受伤"></a>事故和受伤</h3><p>你可以通过解释发生的事情或结果来描述事故和受伤。</p><p>发生的事情</p><p>I slipped and cut my arm.<br>我脚下一滑，把胳膊划伤了。</p><p>I fell down and bruised my shoulder.<br>我摔倒了，把肩膀碰伤了。</p><p>结果</p><p>I have a bruise on my arm.<br>我碰伤了肩膀。</p><p>I have a sprained wrist.<br>我扭伤了手腕。</p><p>I have a broken leg.<br>我摔断了腿。</p><h4 id="While-和-when-描述中断的动作"><a href="#While-和-when-描述中断的动作" class="headerlink" title="While 和 when 描述中断的动作"></a><em>While</em> 和 <em>when</em> 描述中断的动作</h4><p>在讲述事故时，我们常常提到两个动作，一个动作 (was + verb + ing) 被另一个动作打断。</p><p>I sprained my ankle while I was playing soccer.    我踢足球的时候扭伤了脚踝。</p><p>I was walking on an icy road when I slipped and broke my leg.    当时我正在结冰的路面上走路，不小心滑倒摔断了腿。</p><p>您可能注意到了，我们可以使用 while 和 when 引出同时进行的动作。</p><p>While I was crossing the road, a woman fell down.<br>我过马路时，一个女人摔倒了。</p><p>When I was driving to work, I saw the accident.<br>我开车去上班时目睹了事故的发生。</p><p>我们也可以使用 when 引出第二个动作。</p><p>A: What happened?<br>发生了什么事？</p><p>B: I was climbing the ladder when I slipped.<br>我爬楼梯时滑了一跤。</p><h3 id="询问事故"><a href="#询问事故" class="headerlink" title="询问事故"></a>询问事故</h3><p>在向人询问他刚经历的一场事故时，以下是一些常见的问题。</p><p>What happened?<br>发生了什么事？</p><p>Oh, no! Were you OK?<br>哟，不会吧！你没事吧？</p><p>And how are you feeling now?<br>你现在觉得怎么样？</p><p>以下是一些常见的回答，通常降低了事故的严重性。</p><p>A: Hey. How was your weekend?<br>嗨，你周末过得怎么样？</p><p>B: Mmmm, it was OK. Not so great.<br>嗯，还行。不算太好。</p><p>A: What happened?<br>发生了什么事？</p><p>B: Well, while I was cooking,I slipped and fell down.<br>嗯，我做饭的时候，脚下一滑摔倒了。</p><p>A: Oh, no! Were you OK?<br>哦，不会吧！你没事吧？</p><p>B: Yes. I went to the hospital, but it wasn’t serious.<br>有事，我去了医院，不过问题不大。</p><p>A: And how are you feeling now?<br>你现在觉得怎么样？</p><p>B: I’m OK. I have a bruise on my head, but I’ll be fine.<br>我没事。我碰伤了头，但没有大碍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English-Level4-Unit1</title>
      <link href="/2017/11/13/English-Level4-Unit1/"/>
      <url>/2017/11/13/English-Level4-Unit1/</url>
      
        <content type="html"><![CDATA[<h1 id="工作交流"><a href="#工作交流" class="headerlink" title="工作交流"></a>工作交流</h1><h2 id="给予反馈"><a href="#给予反馈" class="headerlink" title="给予反馈"></a>给予反馈</h2><h3 id="描述员工的形容词"><a href="#描述员工的形容词" class="headerlink" title="描述员工的形容词"></a>描述员工的形容词</h3><p>以下是一些可用于描述员工的形容词。把形容词和它的反义词一起识记，这种方法一直都很好。</p><p>clever - stupid    聪明的 - 愚蠢的</p><p>outgoing - shy    外向的 - 害羞的</p><p>注意，否定前缀 un- 常用于构成反义词。</p><p>reliable - unreliable    可靠的 - 不可靠的</p><p>ambitious - unambitious    有雄心壮志的 - 无抱负的</p><p>否定前缀 dis- 不如 un- 常见，但是也用于构成一些重要的反义词。</p><p>honest - dishonest    诚实的 - 不诚实的</p><p>organized - disorganized    有条理的 - 紊乱的</p><h3 id="‘Fast-’-‘hard’和’good’-用作形容词和副词"><a href="#‘Fast-’-‘hard’和’good’-用作形容词和副词" class="headerlink" title="‘Fast,’ ‘hard’和’good’ 用作形容词和副词"></a>‘Fast,’ ‘hard’和’good’ 用作形容词和副词</h3><p>很多形容词在词后加上-ly即可用作副词。<br>He’s clever.    他很聪明。</p><p>He managed the project cleverly.    他巧妙地管理项目。</p><p>Fast, hard和good都是例外。 用fast作形容词放在名词前面。</p><p>She’s a fast learner.    她是一个学东西很快的人。</p><p>用fast 作为副词放在动词之后。注意它没有-ly 后缀。</p><p>She learns fast.    她学东西很快。</p><p>用 hard 作形容词放在一个名词的前面。</p><p>Bill is a hard worker.    Bill 是一个工作努力的人。</p><p>用 hard 做副词放在动词后面。注意：它没有-ly 后缀。</p><p>Bill works hard.    Bill 工作努力。</p><p>用 good 作形容词放在名词前面。</p><p>He’s a good guy.    他是个不错的小伙子。</p><p>用well,不是good放在动词后作副词。</p><p>I work well with the team.    我与团队合作融洽。</p><p>语言点：guy 一词在非正式场合可用于指代男性。它也可在口语中指代一群男人或女人。</p><h3 id="用’for’-和-‘since’-表达持续"><a href="#用’for’-和-‘since’-表达持续" class="headerlink" title="用’for’ 和 ‘since’ 表达持续"></a>用’for’ 和 ‘since’ 表达持续</h3><ul><li>用for 谈论一段时间。</li></ul><p>Dave met with us for an hour.    Dave 与我们会晤了一小时。</p><p>Laura will work in Munich for three years.    Laura 将在慕尼黑工作三年。</p><ul><li>用since 谈论强调从过去某一个时间点起至今的一段时间</li></ul><p>Lindsey and Carol have worked here since Wednesday.    Lindsey 和 Carol 从星期三起就在这里上班了。</p><p>He’s been our customer since last year.    他从去年起就一直是我们的顾客。</p><p>注意： Since 通常与现在完成时使用。</p><h3 id="谈论员工表现"><a href="#谈论员工表现" class="headerlink" title="谈论员工表现"></a>谈论员工表现</h3><p>在评估员工表现时，经理可能找你了解一位同事或你的下属的信息。你可能会听到以下问题。</p><p>How long has she been on your team?    她在你的团队做多久了？</p><p>In general, how’s he doing?    总体而言，他表现怎么样？</p><p>Can you give me some details?    你能告诉我一些细节吗？</p><p>经理在了解一位员工的优缺点后，可能会马上询问你他怎样才可能改进。注意提问和回答中 could 一词的使用。</p><p>A: How could she improve?    她能够怎样改进？<br>B: Well, she’s sometimes late to work. She could take an earlier train in the morning.    嗯，她有时上班迟到。她早上可以坐早一点的列车。</p><p>A: What could he do better?    A：他怎样能做得更好？<br>B: Umm, he could pay more attention to deadlines.    B：嗯，他可以多注意截止期限。</p><p>使用表达 working on it 和 getting better，谈论正在进步的员工。</p><p>He’s often disorganized, but he’s working on it.    他做事常常缺乏条理，但正在努力改进。</p><p>She’s sometimes a bit shy in meetings, but she’s getting better.    她有时开会有点害羞，但正在慢慢改进。</p><h3 id="结束会议"><a href="#结束会议" class="headerlink" title="结束会议"></a>结束会议</h3><p>会议结尾常常分为几个步骤，每步都清楚明了。</p><p>1.最后提问。</p><p>Are there any further questions?    大家还有问题吗？</p><p>2.总结会议。</p><p>To summarize, sales look good.    总结来说，销售情况不错。</p><p>3.陈述会议决议。</p><p>Remember, there is one action item: Confirm your team sales.    记住，这有一条决议：确认你的团队销售额。</p><p>4.结束会议。</p><p>That’s it. Thanks. Have a great day.    就这样了。谢谢。祝大家今天愉快。</p><h4 id="‘Anyone’-和-‘anything’"><a href="#‘Anyone’-和-‘anything’" class="headerlink" title="‘Anyone’ 和 ‘anything’"></a>‘Anyone’ 和 ‘anything’</h4><p>当你谈论的东西的数目并不重要或不易识别时，在否定句和问句中用不定代词anyone 和anything 。</p><p>Don’t tell anyone about this.    不要跟任何人讲这件事。                            </p><p>Does anyone have questions?<br>还有人有问题吗？</p><p>I don’t have anything to report.<br>我没有什么要报告的。</p><p>Mike, do you want to say anything?    Mike，你有什么要说的吗？</p><h3 id="撰写会议总结"><a href="#撰写会议总结" class="headerlink" title="撰写会议总结"></a>撰写会议总结</h3><p>会后，你可能需要把总结发邮件告诉同事。这里有一份可供参照的样文。</p><ol><li>撰写简短准确的 subject line（主题行）。</li></ol><p>Royal project meeting summary    Royal 项目会议总结<br>Summary of Thursday’s budget meeting    周四预算会议总结</p><ol start="2"><li>简要说明你撰写这封邮件的 main reason（主要原因）。</li></ol><p>I’m writing to summarize our meeting about the Royal project.    我写信是要总结这次 Royal 项目的会议。</p><ol start="3"><li>列出所讨论的 main topics（主要话题），包括提出的问题和给出的答案。</li></ol><p>Randy asked who is working on the project.    Randy 问现在谁在做这个项目。<br>Jeremy said that Bill and Lucy are working on the project.<br>Jeremy 说 Bill 和 Lucy 正在做那个项目。</p><ol start="4"><li>列出会议达成的所有 action items（行动决议）。</li></ol><p>Jeremy said that he can confirm the budget by Monday.    Jeremy 说 他周一之前可以确认预算。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English-Level3-Unit6</title>
      <link href="/2017/10/18/English-Level3-Unit6/"/>
      <url>/2017/10/18/English-Level3-Unit6/</url>
      
        <content type="html"><![CDATA[<p>‘Too many、’ ‘too much’ 和 ‘enough’</p><p>使用 too many 搭配可数名词，表示超出需要的数量。</p><p>She has 100 hats. That’s too many hats!    她有 100 顶帽子。这帽子也太多了！</p><p>There are too many baggy jeans in the stores now.    商场现在有太多的宽松牛仔裤。</p><p>That store has too many plastic sandals.    那家店有太多的塑料凉鞋。</p><p>使用 too much 搭配不可数名词，表示超出需要的数量。</p><p>She’s wearing too much makeup.    她妆化得太浓。</p><p>They’re wearing too much fur.    他们穿了太多的皮草。</p><p>使用 enough 搭配复数可数名词或不可数名词，表示一个充足的数量。</p><p>I have enough handbags. I don’t need any more.    我的手提袋够多了，不需要了。</p><p>We’ve done enough shopping. Let’s go home.    我们买得够多了。我们回家吧。</p><p>使用 not enough 搭配任意名词，表示你有的东西少于需要。</p><p>I don’t have enough money to buy that dress.    我钱不够，买不了那条裙子。</p><p>批评和回应批评</p><p>人们通常用带有 far too 和way too的表达批评别人，以强调反对。</p><p>That dress looks way too baggy.         那件裙子看起来太宽松了。</p><p>有时，他们会在说出批评的话之前先道个歉。</p><p>I’m sorry, but she’s wearing far too many necklaces.         不好意思，但是她戴的项链太多了。</p><p>批评和回应批评时通常会使用具有强烈贬义的形容词。</p><p>A: That’s a horrible look.<br>B: You’re crazy! I really like it.         那看起来真吓人。<br>你疯了！我真的很喜欢。</p><p>A: This plastic handbag is nasty.<br>B: Come on. Maybe you’re being too critical.         这款塑胶手袋不好看。<br>行了，或许你太挑剔了。</p><p>你可以告诉他人打扮很好，让他安心，以此回应他的自我批评。</p><p>A: I look terrible!         我看起来好糟糕！<br>B: You look fine. Not everybody cares as much about makeup as you do.         你看起来很好。不是每个人都像你一样那么在乎妆容的。</p><p>文化点：谨慎使用强烈的语言批评他人，因为可能显得无礼。</p><p>时尚形容词</p><p>有许多可用于形容 fashion 和 clothes 的形容词。使用它们描述你喜欢的衣服。</p><p>cool    酷的</p><p>stylish    时髦的</p><p>in style    时髦</p><p>fashionable    时髦的，流行的</p><p>使用下列形容词，描述你不喜欢的衣服。</p><p>out of style    过时的</p><p>dreadful    糟糕的</p><p>unfashionable    旧式的，不时髦的</p><p>学习新的形容词时，同时学习它的反义词是一种好的方法。以下是服装语境中的一些例子。</p><p>针对很长时间一直都非常时髦的某物，使用 classic。如果只是一时的时尚，则用 trendy。<br>classic - trendy    经典的 - 时髦的</p><p>形容衣服有多合身，使用形容词 loose 和 tight。注意，loose 与 baggy 意义相近。<br>loose - tight    宽松的 - 紧贴的</p><p>形容设计仿造某种材料或品牌、但实际上不是的衣服，使用形容词 fake。该词常用于修饰并非来自动物的 fur。如果一件衣服是正品，使用形容词 real。<br>fake - real                                      伪造的 - 非伪造的          </p><p>形容特殊场合穿着的衣服，比如婚礼或工作面试，使用 formal。使用形容词 casual 形容日常服装。注意，在该语境中，两个形容词 casual 和 informal 意思极为相近。<br>formal - casual                               正式的 - 休闲的          </p><p>寻求和表示赞美</p><p>用look +形容词来恭维某人的外貌。</p><p>You look fantastic!    你看起来很美！</p><p>That shirt looks great on you.    你穿那件衬衫很好看。</p><p>That color looks good with your hair.    那个颜色和你的发色很配。</p><p>您也可以用good at +动词 + -ing 来恭维他人。</p><p>You’re good at putting together an outfit.    你很擅长搭配衣服。</p><p>You’re great at creating new styles.    你很擅长创造新的风格。</p><p>赞美别人的另一种方式是夸张。</p><p>You’re just the sweetest man in the world!    你是世界上最可爱的男人！</p><p>You’re 35 years old? You look 29!    你 35 岁吗？你看起来像 29 岁！</p><p>要得到恭维，用like提问。</p><p>A: Do you like my outfit?<br>B: Absolutely. You know clothes better than anyone!    你喜欢我的衣服吗？<br>当然喜欢。你比任何人都懂衣服。</p><p>A: How do you like my hair?<br>B: It looks gorgeous!    你觉得我的头发怎么样？<br>看起来非常漂亮！</p><p>注意：频繁要人赞美你，可能会让人产生厌烦，或给人感觉自我。</p><p>形容词顺序</p><p>描述中使用形容词超过一个时，一般按照观点、大小、年龄、颜色、来源、材料的顺序依次排列。</p><p>Look at this fabulous, long, old, navy blue, Chinese, silk jacket.    看看这件极棒的海军蓝中式长款旧丝绸上衣。</p><p>观点    大小    年龄    颜色    来源    材料<br>fabulous    long    old    navy blue    Chinese    silk</p><p>注意这些例子中的形容词顺序：</p><p>Heidi’s carrying a stylish, beige, leather handbag.    海蒂拿着一只时尚的米黄色皮质手提包。</p><p>Your baseball cap is way too nasty, small and old.    你的棒球帽实在是太脏了，而且又小又旧。</p><p>How about your new, gray, Italian, wool suit?    你那新的灰色意大利羊毛西服怎么样？</p><p>I look for brands that use classic, Egyptian, cotton fabrics.    我在找采用埃及传统棉纺面料的品牌。</p><p>表达喜好</p><p>使用动词 prefer 表达喜好。</p><p>I prefer cotton to wool in the summer.    我夏天喜欢全棉而不是羊毛衣服。</p><p>你也可以使用 prefer，不用说明相比较不喜欢的东西。</p><p>I prefer cotton.    我喜欢全棉质地。</p><p>另一种表达喜好的方法是使用表达 would rather。注意，I would 常常缩写成 I’d。</p><p>I’d rather wear light colors in the summer.    我夏天更喜欢穿浅色。</p><p>你也可以将rather与than合用，表示与…相比而更喜欢…。</p><p>I’d rather wear wool clothes than cotton in the winter.    我冬天更喜欢穿羊毛衣服，而不是全棉的衣服。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English-Level3-Unit5</title>
      <link href="/2017/10/10/English-Level3-Unit5/"/>
      <url>/2017/10/10/English-Level3-Unit5/</url>
      
        <content type="html"><![CDATA[<h3 id="带有’one-of-the’-和-‘some-of-the’-的表达"><a href="#带有’one-of-the’-和-‘some-of-the’-的表达" class="headerlink" title="带有’one of the’ 和 ‘some of the’ 的表达"></a>带有’one of the’ 和 ‘some of the’ 的表达</h3><p><strong><em>用one of the + 最高级 +复数名词表达某物是某一组的以一部分，是无法超越的。</em></strong></p><p>‘The Birds’ has one of the most exciting plots I’ve ever seen.    ‘The Birds’里有我从来没见过的最令人振奋的情节。</p><p><strong><em>用 some of the + 最高级 +复数名词来表达未被超过的一组中的两个或更多个东西。</em></strong></p><p>‘Avatar’ has some of the best special effects ever.    ‘Avatar’有一些前所未有最好的的特殊效果。</p><p><strong><em>您可以用诸如of all time 和 ever的表达来加重强调.</em></strong></p><p>Amelie is one of the greatest characters of all time.    Amelie是有史以来最伟大的人物之一。</p><p>‘The Terminator’ is one of the coolest movies ever.    ‘The Terminator’ 是有史以来最酷的电影之一。</p><h2 id="询问电影的情况"><a href="#询问电影的情况" class="headerlink" title="询问电影的情况"></a>询问电影的情况</h2><p>以下是一些你可以询问影片的常见问题。<strong><em>注意，movie 和 film 所指相同，但 film 更正式一点。</em></strong></p><p>A: What did you think of the film?    你觉得这部影片怎么样？<br>B: I loved it!    我非常喜欢！</p><p>A: How did you like it?    你喜欢它吗？<br>B: I didn’t like it at all!    我一点也不喜欢。</p><p>A: How would you describe it?    你要怎么形容它？<br>B: It’s a romantic comedy.    这是一部浪漫喜剧。</p><p>A: What’s your favorite movie?    你最喜欢哪部电影？<br>B: My favorite movie is ‘Chinatown.’    我最喜欢的电影是 ‘Chinatown。’</p><p><strong><em>你可以使用短语 all-time favorite，谈论你最爱的电影。</em></strong></p><p>My all-time favorite movie is ‘Casablanca.’    我最喜爱的电影是 ‘Casablanca。’</p><h2 id="使用以下问题，询问电影的细节。"><a href="#使用以下问题，询问电影的细节。" class="headerlink" title="使用以下问题，询问电影的细节。"></a>使用以下问题，询问电影的细节。</h2><p>A: What’s it about?    它是关于什么的？<br>B: It’s about a boy and his dog.    它是关于一个男孩和他的狗的故事。</p><p>A: Who directed it?    谁导演的？<br>B: It was directed by Woody Allen.    由 Woody Allen 导演的。</p><p>A: Who’s in it?    里面有谁？<br>B: It stars Glenda Smith.    主演是 Glenda Smith。</p><p>A: How’s the acting?    演技怎么样？<br>B: It’s really good.    演技非常不错。</p><p>A: Where does the film take place?    电影在哪发生？<br>B: It takes place in Paris in 1952.    发生在 1952 年的巴黎。</p><p>A: How does it end?    电影是怎么样结尾的？<br>B: Sheila and Mark get married.    Sheila 和 Mark 结婚了。</p><h2 id="现在时被动语态"><a href="#现在时被动语态" class="headerlink" title="现在时被动语态"></a>现在时被动语态</h2><ul><li><p>一种常见的句型是主语 +动词+宾语。</p><p>   主语    动词    宾语                                  </p></li></ul><p>Ai Jones    directed    this fantastic film.</p><ul><li><p>但是，如果宾语比主语重要，也可置于主语之前。这称为被动语态。</p><p>   主语    be + 过去分词    by-短语</p></li></ul><p>This fantastic film    is directed     by Ai Jones.</p><ul><li>注意以下现在时被动语态例子的结构：</li></ul><p>The movie is directed by George Lucas.    电影由 George Lucas 导演。</p><p>The costumes are designed by Virginia Poole.    服装由 Virginia Poole 设计。</p><p>The main character is played by Bruce Willis.    主角由 Bruce Willis 扮演。</p><ul><li>如果动作的施动者非常明显，则不需要 by-短语。例如在下句中，我们无需提到是一位译者翻译了字幕。</li></ul><p>The subtitles are translated into five languages.    字幕被翻译成五种语言。</p><h2 id="过去时被动语态"><a href="#过去时被动语态" class="headerlink" title="过去时被动语态"></a>过去时被动语态</h2><p>如果您要把焦点放在一个过去的动作，而不是完成该动作的人，用过去被动式。结构与现在被动式相同，除了助动词be 用过去式而不是现在式。</p><p>The special effects were created by 23 people.    特效由 23 个人制作。</p><p>The bank manager was shot by the bad guys.    银行经理被坏人开枪击中了。</p><p>如果完成了事情的人不重要或未知，by +人从句可以省略。</p><p>A: Guess what? The producer was fired.<br>B: Why?<br>A: The actors weren’t paid.<br>B: Oh, no! Was a new producer hired?<br>猜猜怎么着？制片人被解雇了。<br>为什么？<br>演员没收到钱。<br>不是吧！新制片人请好了吗？</p><h2 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h2><p>文本中，事实和观点往往并不直接说明。在这种情况下，你必须做出推断。推断是一种猜测。</p><p>Gene Kelly did a great job in the movie ‘Singin’ in the Rain’! He’s an excellent dancer.    Gene Kelly 在影片 ‘Singin’ in the Rain’ 中表现非常出色！他舞跳得很好。</p><p>作者并没有直接说 Gene Kelly 在影片 ‘Singin’ in the Rain’ 有跳舞，但因为两个关于电影和 Gene Kelly 的句子前后相邻，我们可以推断他在电影中跳过舞。</p><p>‘The Class’ is a great movie. It was made in France.     ‘The Class’ 是一部优秀的影片。影片在法国制作。</p><p>作者并没有直接说影片 ‘The Class’ 中讲哪种语言，但由于影片在法国制作，我们可以推断它是法语影片。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swordOffer</title>
      <link href="/2017/09/03/swordOffer/"/>
      <url>/2017/09/03/swordOffer/</url>
      
        <content type="html"><![CDATA[<h1 id="代码的完整性"><a href="#代码的完整性" class="headerlink" title="代码的完整性"></a>代码的完整性</h1><h2 id="从3方面确保代码的完整性"><a href="#从3方面确保代码的完整性" class="headerlink" title="从3方面确保代码的完整性"></a>从3方面确保代码的完整性</h2><ol><li>功能测试</li><li>边界测试</li><li>负面测试<br>从这3 方面设计测试用例，以保证代码的完整性。<h2 id="3种错误处理的方法"><a href="#3种错误处理的方法" class="headerlink" title="3种错误处理的方法"></a>3种错误处理的方法</h2></li><li>用函数返回值来告诉调用都是否出错。</li><li>当错误发生时设置一个全局变量</li><li>抛出异常<img src="/2017/09/03/swordOffer/threemethodForException.jpg" title="三种异常的对比"> </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>将容器列表视图从控制器分离，做到数据驱动UI</title>
      <link href="/2017/07/21/HookArrayBinder/"/>
      <url>/2017/07/21/HookArrayBinder/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 命令</title>
      <link href="/2017/07/20/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/07/20/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>移除本地仓库的远程git<br>使用 <code>git remote rm</code>命令解除本地创建与远程git的绑定关系<br><code>git remote rm</code>命令需要传入一个参数 <code>远程仓库名</code><br>示例：<pre><code>$git remote -v origingit@192.168.250.71:yuanph&#x2F;HookArray.git (fetch)origingit@192.168.250.71:yuanph&#x2F;HookArray.git (push)</code></pre><pre><code>$ git remote rm origin</code></pre><pre><code>$git remote add origin git@192.168.250.71:shareCode&#x2F;HookArray.git</code></pre><pre><code>$git remote -v origingit@192.168.250.71:shareCode&#x2F;HookArray.git (fetch)origingit@192.168.250.71:shareCode&#x2F;HookArray.git (push)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSPredicate</title>
      <link href="/2017/07/12/NSPredicate/"/>
      <url>/2017/07/12/NSPredicate/</url>
      
        <content type="html"><![CDATA[<h1 id="NSPredicate是什么？"><a href="#NSPredicate是什么？" class="headerlink" title="NSPredicate是什么？"></a>NSPredicate是什么？</h1><p>NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件</p><h1 id="集合中使用NSPredicate"><a href="#集合中使用NSPredicate" class="headerlink" title="集合中使用NSPredicate"></a>集合中使用NSPredicate</h1><p>Foundation提供使用谓词（predicate）来过滤NSArray／NSMutableArray&amp;NSSet／NSMutableSet的方法。</p><p>不可变的集合，NSArray&amp;NSSet，有可以通过评估接收到的predicate来返回一个不可变集合的方法filteredArrayUsingPredicate:和filteredSetUsingPredicate:。</p><p>可变集合，NSMutableArray&amp;NSMutableSet，可以使用方法filterUsingPredicate:，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。</p><p>NSDictionary可以用谓词来过滤它的键和值（两者都为NSArray对象）。NSOrderedSet可以由过滤的NSArray或NSSet生成一个新的有序的集，或者NSMutableSet可以简单的removeObjectsInArray:，来传递通过_否定_predicate过滤的对象。</p><h1 id="Core-Data中使用NSPredicate"><a href="#Core-Data中使用NSPredicate" class="headerlink" title="Core Data中使用NSPredicate"></a>Core Data中使用NSPredicate</h1><p>NSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤</p><pre><code>@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@property NSNumber *age;@end@implementation Person- (NSString *)description {    return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];}@end#pragma mark -NSArray *firstNames = @[ @&quot;Alice&quot;, @&quot;Bob&quot;, @&quot;Charlie&quot;, @&quot;Quentin&quot; ];NSArray *lastNames = @[ @&quot;Smith&quot;, @&quot;Jones&quot;, @&quot;Smith&quot;, @&quot;Alberts&quot; ];NSArray *ages = @[ @24, @27, @33, @31 ];NSMutableArray *people = [NSMutableArray array];[firstNames enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {    Person *person = [[Person alloc] init];    person.firstName = firstNames[idx];    person.lastName = lastNames[idx];    person.age = ages[idx];    [people addObject:person];}];NSPredicate *bobPredicate = [NSPredicate predicateWithFormat:@&quot;firstName = &#39;Bob&#39;&quot;];NSPredicate *smithPredicate = [NSPredicate predicateWithFormat:@&quot;lastName = %@&quot;, @&quot;Smith&quot;];NSPredicate *thirtiesPredicate = [NSPredicate predicateWithFormat:@&quot;age &gt;= 30&quot;];&#x2F;&#x2F; [&quot;Bob Jones&quot;]NSLog(@&quot;Bobs: %@&quot;, [people filteredArrayUsingPredicate:bobPredicate]);&#x2F;&#x2F; [&quot;Alice Smith&quot;, &quot;Charlie Smith&quot;]NSLog(@&quot;Smiths: %@&quot;, [people filteredArrayUsingPredicate:smithPredicate]);&#x2F;&#x2F; [&quot;Charlie Smith&quot;, &quot;Quentin Alberts&quot;]NSLog(@&quot;30&#39;s: %@&quot;, [people filteredArrayUsingPredicate:thirtiesPredicate]);</code></pre><h1 id="谓词语法"><a href="#谓词语法" class="headerlink" title="谓词语法"></a>谓词语法</h1><h2 id="替换（占位符）"><a href="#替换（占位符）" class="headerlink" title="替换（占位符）"></a>替换（占位符）</h2><ul><li>%@是对值为字符串，数字或者日期的对象的替换值。(变量值)</li><li><p>%K是key path的替换值。（变量名）</p><pre><code>NSPredicate *ageIs33Predicate = [NSPredicate predicateWithFormat:@&quot;%K = %@&quot;, @&quot;age&quot;, @33];&#x2F;&#x2F; [&quot;Charlie Smith&quot;]NSLog(@&quot;Age 33: %@&quot;, [people filteredArrayUsingPredicate:ageIs33Predicate]);</code></pre></li><li><p>$VARIABLE_NAME是可以被NSPredicate -predicateWithSubstitutionVariables:替换的值。</p><pre><code>NSPredicate *namesBeginningWithLetterPredicate = [NSPredicate predicateWithFormat:@&quot;(firstName BEGINSWITH[cd] $letter) OR (lastName BEGINSWITH[cd] $letter)&quot;];&#x2F;&#x2F; [&quot;Alice Smith&quot;, &quot;Quentin Alberts&quot;]NSLog(@&quot;&#39;A&#39; Names: %@&quot;, [people filteredArrayUsingPredicate:[namesBeginningWithLetterPredicate predicateWithSubstitutionVariables:@{@&quot;letter&quot;: @&quot;A&quot;}]]);</code></pre></li></ul><h2 id="基本比较"><a href="#基本比较" class="headerlink" title="基本比较"></a>基本比较</h2><ul><li>=, ==：左边的表达式和右边的表达式相等。</li><li>‘&gt;=’, =&gt;：左边的表达式大于或者等于右边的表达式。</li><li>&lt;=, =&lt;：左边的表达式小于等于右边的表达式。</li><li>‘&gt;’：左边的表达式大于右边的表达式。</li><li>&lt;：左边的表达式小于右边的表达式。</li><li>!=, &lt;&gt;：左边的表达式不等于右边的表达式。</li><li>BETWEEN：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。</li></ul><h2 id="基本复合谓词"><a href="#基本复合谓词" class="headerlink" title="基本复合谓词"></a>基本复合谓词</h2><ul><li>AND, &amp;&amp;：逻辑与.</li><li>OR, ||：逻辑或.</li><li>NOT, !：逻辑非.</li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>字符串比较在默认的情况下是<strong>区分大小写和音调</strong>的。你可以在方括号中用关键字符c和d来修改操作符以相应的指定不区分大小写和变音符号，比如firstname BEGINSWITH[cd] $FIRST_NAME。</p><ul><li>BEGINSWITH：左边的表达式以右边的表达式作为开始。</li><li>CONTAINS：左边的表达式包含右边的表达式。</li><li>ENDSWITH：左边的表达式以右边的表达式作为结束。</li><li>LIKE：左边的表达式等于右边的表达式：?和<em>可作为通配符，其中?匹配1个字符，</em>匹配0个或者多个字符。</li><li>MATCHES：左边的表达式根据ICU v3（更多内容请查看ICU User Guide for Regular Expressions）的regex风格比较，等于右边的表达式</li></ul><h2 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h2><ul><li>ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。</li><li>ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。</li><li>NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY …)。</li><li>IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { ‘Ben’, ‘Melissa’, ‘Nick’ }。</li></ul><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ul><li>array[index]：指定数组中特定索引处的元素。</li><li>array[FIRST]：指定数组中的第一个元素。</li><li>array[LAST]：指定数组中的最后一个元素。</li><li>array[SIZE]：指定数组的大小。</li></ul><h2 id="布尔值谓词"><a href="#布尔值谓词" class="headerlink" title="布尔值谓词"></a>布尔值谓词</h2><ul><li>TRUEPREDICATE：结果始终为真的谓词。</li><li>FALSEPREDICATE：结果始终为假的谓词。</li></ul><h2 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h2><p>在谓词表达式中可以使用如下直接量</p><ul><li>FALSE、NO：代表逻辑假</li><li>TRUE、YES：代表逻辑真</li><li>NULL、NIL：代表空值</li><li>SELF：代表正在被判断的对象自身</li><li>“string”或’string’：代表字符串</li><li>数组：和c中的写法相同，如：{‘one’, ‘two’, ‘three’}。</li><li>数值：包括证书、小数和科学计数法表示的形式</li><li>十六进制数：0x开头的数字</li><li>八进制：0o开头的数字</li><li>二进制：0b开头的数字</li></ul><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><blockquote><p>下列单词都是保留字（不论大小写）</p></blockquote><blockquote><p>AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSEPREDICATE</p></blockquote><blockquote><p>注：虽然大小写都可以，但是更推荐使用大写来表示这些保留字</p></blockquote><h1 id="NSCompoundPredicate"><a href="#NSCompoundPredicate" class="headerlink" title="NSCompoundPredicate"></a>NSCompoundPredicate</h1><p>我们见过与&amp;或被用在谓词格式字符串中以创建复合谓词。然而，我们也可以用NSCompoundPredicate来完成同样的工作</p><pre><code>[NSCompoundPredicate andPredicateWithSubpredicates:@[[NSPredicate predicateWithFormat:@&quot;age &gt; 25&quot;], [NSPredicate predicateWithFormat:@&quot;firstName = %@&quot;, @&quot;Quentin&quot;]]];[NSPredicate predicateWithFormat:@&quot;(age &gt; 25) AND (firstName = %@)&quot;, @&quot;Quentin&quot;];</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSPredicate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断言</title>
      <link href="/2017/07/11/%E6%96%AD%E8%A8%80/"/>
      <url>/2017/07/11/%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>断言的定义：</p><blockquote><p>断言（assertion）是指在开发期间使用的、让程序在运行时进行自检的代码（通常是一个子程序或宏）。断言为真，则表明程序运行正常，而断言为假，则意味着它已经在代码中发现了意料之外的错误。断言对于大型的复杂程序或可靠性要求极高的程序来说尤其有用</p></blockquote><p>断言使用的准则与建议：<br><blockquote><ol><li>用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。</li><li>避免把需要执行的代码放到断言中</li><li>用断言来注解并验证前条件和后条件</li><li>对于高健壮性的代码，应该先使用断言再处理错误</li></ol><footer><strong>《代码大全2》</strong><cite>-防御式编程</cite></footer></blockquote></p><h1 id="NSAssert"><a href="#NSAssert" class="headerlink" title="NSAssert()"></a>NSAssert()</h1><p>NSAssert()是一个宏，用于开发阶段调试程序中的Bug，通过为NSAssert()传递条件表达式来断定是否属于Bug，满足条件返回真值，程序继续运行，如果返回假值，则抛出异常，并且可以自定义异常描述。<br><pre><code>#define NSAssert(condition, desc)</code></pre></p><blockquote><ul><li>condition是条件表达式，值为YES或NO；</li><li>desc为异常描述，通常为NSString。</li><li>当conditon为YES时程序继续运行，为NO时，则抛出带有desc描述的异常信息。NSAssert()可以出现在程序的任何一个位置。</li></ul></blockquote><h1 id="NSAssert和assert-区别"><a href="#NSAssert和assert-区别" class="headerlink" title="NSAssert和assert 区别"></a>NSAssert和assert 区别</h1><p>NSAssert和assert都是断言,主要的差别是assert在断言失败的时候只是简单的终止程序,而NSAssert会报告出错误信息并且打印出来.所以只使用NSAssert就好,可以不去使用assert。</p><h1 id="断言何时运行？"><a href="#断言何时运行？" class="headerlink" title="断言何时运行？"></a>断言何时运行？</h1><p>通常在debug情况下（真机中会自动忽略），所有NSAssert都会被执行。在release下系统会自动将断言设置为禁用。如果release下断言仍可执行的话，则需要我们手动设置为，设置方式如下：Preprocessor Macros 的Release值为 NS_BLOCK_ASSERTIONS。</p><p>小延伸：如何切换Debug和Release呢？</p><p>自答吧：<br>1、点击工程名，点这里。选择Edit Scheme<br>2、选择Run，在Info 中将Build Configuration 修改为release</p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><ol><li>使用NSAssert的时候，每个NSAssert只检验一个条件，因为同事检验多个条件时，如果断言失败，无法直观地判断是那个条件失败</li><li><p>Block中使用NSAssert要特别注意循环引用。<br> 有没有搞错，用断言也会出现循环引用,不信，那我们看看宏定义展开后是啥样的？：</p> <pre><code>   #define NSAssert(condition, desc, ...)\   do {\__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \if (!(condition)) {\           NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \           __assert_file__ = __assert_file__ ? __assert_file__ : @&quot;&lt;Unknown File&gt;&quot;; \    [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \object:self file:__assert_file__ \    lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \}\       __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \   } while(0)   </code></pre><p> 看到没，宏定义展开后会出现对self的持有，容易导致循环引用！！！。有没有解决方法，必须呀，使用  <code>NSCAssert</code>！，你确信吗？不信，展开看看：</p> <pre><code>   #define NSCAssert(condition, desc, ...) \   do {\__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \if (!(condition)) {\           NSString *__assert_fn__ = [NSString stringWithUTF8String:__PRETTY_FUNCTION__]; \           __assert_fn__ = __assert_fn__ ? __assert_fn__ : @&quot;&lt;Unknown Function&gt;&quot;; \           NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \           __assert_file__ = __assert_file__ ? __assert_file__ : @&quot;&lt;Unknown File&gt;&quot;; \    [[NSAssertionHandler currentHandler] handleFailureInFunction:__assert_fn__ \file:__assert_file__ \    lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \}\       __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \   } while(0)   </code></pre><p> 宏定义中并没有出现self，所以在block中使用NSCAssert可以避免循环引用的发生。</p></li><li><p>频繁地调用会极大的影响程序的性能，增加额外开销。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>监听NSMutableArray的变化</title>
      <link href="/2017/07/10/NSMutableArray/"/>
      <url>/2017/07/10/NSMutableArray/</url>
      
        <content type="html"><![CDATA[<p>平时工作中我们接触最多的容器，可能就数字典与数组了。有时我们在使用这些容器时有这样一个困惑，容器中的数据改变了，我们却无法立即知道。近日小编因为这个感到有些小苦恼，思来想去发现还是有途径可以做到监听容器的变化。<br>接下来我将会用文字将我的想法叙述出来，供大家参考。<br>要想监听一个容器的变化，首先我们需要对这个容器的属性及方法有着深入的了解。要监听容器的元素改变，那肯定是针对于可变容器。我们先着手于可变数组的监听工作。<br>接下来的工作将分成三部分：</p><ol><li>可变数组容器的分析</li><li>设计一套监听回调机制</li><li>使用runtime机制替换或者交换对应的函数指针IMP</li></ol><p>现在我们开始着手分析可变数组的方法。</p><h1 id="可变数组的分析"><a href="#可变数组的分析" class="headerlink" title="可变数组的分析"></a>可变数组的分析</h1><h2 id="可变数组的定义"><a href="#可变数组的定义" class="headerlink" title="可变数组的定义"></a>可变数组的定义</h2><p><strong>NSMutableArray</strong>定义了一套接口用于管理可变数组对象，该类的添加／插入／删除基础操作继承于不可变数组<strong>NSArray</strong></p><h2 id="可变数组的方法分类"><a href="#可变数组的方法分类" class="headerlink" title="可变数组的方法分类"></a>可变数组的方法分类</h2><p>通过查阅苹果的官方文档，我们大致可以将可变数组的方法分为以下几部分：</p><ol><li>创建和初始化一个可变数组</li><li>数组元素的添加操作</li><li>数组元素的删除操作</li><li>数组元素的替换操作</li><li>数组内容的筛选操作</li><li>数组内容的排序操作</li></ol><p>下面我将各部分的相关函数贴出，以便大家更好的直观了解。</p><h3 id="创建和初始化一个可变数组"><a href="#创建和初始化一个可变数组" class="headerlink" title="创建和初始化一个可变数组"></a>创建和初始化一个可变数组</h3><pre><code>+ arrayWithCapacity:+ arrayWithContentsOfFile:+ arrayWithContentsOfURL:</code></pre><pre><code>- init- initWithCapacity:- initWithContentsOfFile:- initWithContentsOfURL:</code></pre><h3 id="数组元素的添加操作"><a href="#数组元素的添加操作" class="headerlink" title="数组元素的添加操作"></a>数组元素的添加操作</h3><pre><code>- addObject:- addObjectsFromArray:</code></pre><pre><code>- insertObject:atIndex:- insertObjects:atIndexes:</code></pre><blockquote><p>ps:批量元素的插入会调用多次单个元素的插入方法，<strong><em>在以后的监听过程中需要做些特殊的处理</em></strong><br><pre><code>- void insertObjects:(NSArray *)additions atIndexes:(NSIndexSet *)indexes{    NSUInteger currentIndex = [indexes firstIndex];    NSUInteger i, count = [indexes count];    for (i = 0; i &lt; count; i++)    {        [self insertObject:[additions objectAtIndex:i] atIndex:currentIndex];        currentIndex = [indexes indexGreaterThanIndex:currentIndex];    }}</code></pre></p></blockquote><h3 id="数组元素的删除操作"><a href="#数组元素的删除操作" class="headerlink" title="数组元素的删除操作"></a>数组元素的删除操作</h3><pre><code>&#x2F;&#x2F;删除元素的删除- removeLastObject- removeObjectAtIndex:</code></pre><pre><code>&#x2F;&#x2F; 批量元素的删除- removeAllObjects- removeObject:- removeObject:inRange:- removeObjectsAtIndexes:- removeObjectIdenticalTo:- removeObjectIdenticalTo:inRange:- removeObjectsInArray:- removeObjectsInRange:</code></pre><blockquote><p>ps： 以下方法会多次调用<code>- removeObjectAtIndex:</code>方法：,在监听过程中需要处理多次调用问题。<br><pre><code>- removeObject:- removeObject:inRange:- removeObjectIdenticalTo:- removeObjectIdenticalTo:inRange:- removeObjectsInArray:</code></pre></p></blockquote><h3 id="数组元素的替换操作"><a href="#数组元素的替换操作" class="headerlink" title="数组元素的替换操作"></a>数组元素的替换操作</h3><pre><code>- replaceObjectAtIndex:withObject:- setObject:atIndexedSubscript:</code></pre><blockquote><p>ps：<code>- setObject:atIndexedSubscript:</code>这个方法我们最好不要直接使用而是使用语法糖的形式调用。</p><pre><code class="objc">mutableArray[3] = @&quot;someValue&quot;; // equivalent to [mutableArray replaceObjectAtIndex:3 withObject:@&quot;someValue&quot;];</code></pre><p>若替换对象为空会抛出<code>NSInvalidArgumentException</code>异常，若索引下标越界会抛出<code>NSRangeException</code>异常</p></blockquote><pre><code>- replaceObjectsAtIndexes:withObjects:- replaceObjectsInRange:withObjectsFromArray:range:- replaceObjectsInRange:withObjectsFromArray:- setArray:</code></pre><blockquote><p>ps: 以下方法会调用多次<code>- replaceObjectAtIndex:withObject:</code>方法<br><pre><code>- replaceObjectsAtIndexes:withObjects:&#x2F;&#x2F;PS: objects的个数必须与indexes的个数相同，否则会抛出异常</code></pre></p></blockquote><h3 id="数组元素的筛选"><a href="#数组元素的筛选" class="headerlink" title="数组元素的筛选"></a>数组元素的筛选</h3><pre><code>- filterUsingPredicate:</code></pre><blockquote><p>ps： 会在数组中直接筛选出符合条件的数组元素，不符合的会直接删除</p></blockquote><h3 id="数组元素的排序"><a href="#数组元素的排序" class="headerlink" title="数组元素的排序"></a>数组元素的排序</h3><pre><code>- exchangeObjectAtIndex:withObjectAtIndex:</code></pre><pre><code>- sortUsingDescriptors:- sortUsingComparator:- sortWithOptions:usingComparator:- sortUsingFunction:context:- sortUsingSelector:</code></pre><blockquote><p>ps:数组的排序方法会递归调用 <code>- replaceObjectAtIndex:withObject:</code><strong>在监听数组排序时需要处理多次回调的问题</strong></p></blockquote><p>通过对数组方法的分类及分析，我们对数组的方法有了大概的了解。接下来我们来制定一套协议，用来做回调操作。</p><h1 id="监听机制的协议商定"><a href="#监听机制的协议商定" class="headerlink" title="监听机制的协议商定"></a>监听机制的协议商定</h1><h2 id="协议行为的划分"><a href="#协议行为的划分" class="headerlink" title="协议行为的划分"></a>协议行为的划分</h2><p>从数组元素的变化行为来看，协议主要可以划分为以下几部分：</p><ol><li>元素增加<ul><li>单个元素的增加</li><li>多个元素的增加</li></ul></li><li>元素删除<ul><li>单个元素的删除</li><li>多个元素的删除</li></ul></li><li>元素的替换<ul><li>单个元素的替换</li></ul></li><li>数组改变了<ul><li>删除所有元素</li><li>批量元素的替换</li><li>数组的排序操作</li><li>数组元素的筛选</li></ul></li><li>数组元素的交换<ul><li>元素的交换</li></ul></li></ol><h2 id="参数商定"><a href="#参数商定" class="headerlink" title="参数商定"></a>参数商定</h2><p>监听数组变化，哪些数据需要被回调回来呢？<br>通过参考表格协议和同事进行商讨决定</p><p>对于数组元素的添加／删除操作需要将以下数据回调回来：</p><ul><li>监听的数组本身</li><li>添加删除的元素对象</li><li>及对应的索引返回。</li></ul><p>对于数组的替换操作将以下数据回调回来：</p><ul><li>监听数组对象本身</li><li>替换的对象</li><li>替换的新对象</li><li>对象的索引</li></ul><p>对于数组改变了的相关操作，考虑到期复杂度相对较高，先采用较简单的方式处理，简洁明了的告诉协议的遵守者，说数组变了，回调回监听的数组对象本身。<br>对于数组元素的交换，将以下数据回调：</p><ul><li>监听的数组本身</li><li>交换的下标1</li><li>将交的下标2</li></ul><h2 id="协议确认"><a href="#协议确认" class="headerlink" title="协议确认"></a>协议确认</h2><pre><code>@protocol NSmutableArrayOberver &lt;NSObject&gt;@optional#pragma mark - 增加-(void)mutableArray:(NSMutableArray*)array didAddObject:(id)anObject atIndex:(NSInteger)index;-(void)mutableArray:(NSMutableArray*)array didAddObjects:(NSArray *)objects atIndexes:(NSIndexSet*)indexSet;#pragma mark - 删除-(void)mutableArray:(NSMutableArray *)array didDeleteObject:(id)anObject atIndex:(NSInteger)index;-(void)mutableArray:(NSMutableArray *)array didDeleteObjects:(NSArray*)objects atIndexes:(NSIndexSet*)indexes;#pragma mark  - 替换-(void)mutableArray:(NSMutableArray*)array replaceObject:(id )object withObject:(id)anObject atIndex:(NSUInteger)index;#pragma mark  - 改变（排序）-(void)mutableArrayhasChanged:(NSMutableArray*)array;#pragma mark - 位置交换-(void)mutableArray:(NSMutableArray*)array exchangeObjectAtIndex:(NSUInteger)index1 withObjectAtIndex:(NSUInteger)index2;@end</code></pre><h1 id="使用runtime机制替换或者交换对应的函数指针IMP"><a href="#使用runtime机制替换或者交换对应的函数指针IMP" class="headerlink" title="使用runtime机制替换或者交换对应的函数指针IMP"></a>使用runtime机制替换或者交换对应的函数指针IMP</h1><ol><li>创建一个数组的扩展，并添加代理属性（使用<strong>关联属性</strong>添加）</li><li>创建相应的函数指针，并替换数组对应的方法IMP<br>这里以- insertObject:atIndex:为例：<br>创建C函数指针：<pre><code>typedef void (*insertObject_atIndex_IMP)(id self, SEL _cmd ,id anObject ,NSUInteger index);static insertObject_atIndex_IMP origin_insertObject_atIndex = nil;static void replace_insertObject_atIndex(id self, SEL _cmd ,id anObject ,NSUInteger index){    NSMutableArray * array = self;    if ([array.delegate conformsToProtocol:@protocol(NSmutableArrayOberver) ]&amp;&amp; [array.delegate respondsToSelector:@selector(mutableArray:didAddObject:atIndex:)]) {                NSInteger number = addCount();        origin_insertObject_atIndex(self,_cmd,anObject,index);        if (number==1) {            [array.delegate mutableArray:self didAddObject:anObject atIndex:index];        }        decreaseCount();            }else{        origin_insertObject_atIndex(self,_cmd,anObject,index);    }}</code></pre><pre><code>+(void)load{     Method method;    Class  class = NSClassFromString(@&quot;__NSArrayM&quot;);#pragma mark - 添加    method = class_getInstanceMethod(class, @selector(insertObject:atIndex:));    origin_insertObject_atIndex = (insertObject_atIndex_IMP)method_setImplementation(method, (IMP)replace_insertObject_atIndex);}</code></pre></li></ol><blockquote><p>PS:这里使用对一个线程变量用于统计函数的调用次数，进入函数时进行加1操作，退出时进行减1操作。如果当前调用次数为1,则在当前方法中进行回调，如果不在则不回调，由上一级调用函数进行回调。该原理类似于引用计数。</p></blockquote><p>至一个基础版本的数组监听工作已经完成，后续将兼容block的工作模式，以便提高代码的高聚合。</p><p>参考博客：</p><ol><li><a href="http://www.cocoachina.com/ios/20150717/12623.html" target="_blank" rel="noopener">轻松学习之 IMP指针的作用</a></li><li><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">Objective-C Runtime 运行时之三：方法与消息</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSMutableArray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSIndexSet</title>
      <link href="/2017/07/06/NSIndexSet/"/>
      <url>/2017/07/06/NSIndexSet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The NSIndexSet class represents an immutable collection of unique unsigned integers, known as indexes because of the way they are used. This collection is referred to as an index set. Indexes must be in the range 0 .. NSNotFound - 1.</p><footer><strong>苹果官方的定义</strong></footer></blockquote><p>NSIndexSet (以及它的可修改子类, NSMutableIndexSet) 是一个排好序的，无重复元素的整数集合。它看上去有点像 支持离散整数的 NSRange .它能用于快速查找特定范围的值的索引，也能用于快速计算交集, 同时，Foundation collection class 提供了很多好用的方法，方便你使用 NSIndexSet.</p><p>Foundataion framework 里面到处可以看到 NSIndexSet 的影子。 任何从已排序容器(比如 array, 或者 table view 的 data source)里面获取多个元素的方法都会用到 NSIndexSet 做为参数。</p><ul><li><p>NSIndexSet方法可以划分成以下几部分</p><ul><li>创建索引</li><li>查询索引</li><li>枚举索引内容</li><li>比较索引</li><li>获取子索引</li><li>枚举索引</li></ul></li><li><p>NSMutableIndexSet的方法划分：</p><ul><li>增加／删除一个索引集合</li><li>增加／删除单个索引</li><li>增加／删除一个子范围</li></ul></li></ul><h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><pre><code>&#x2F;&#x2F;创建一个空的索引集合。+ (instancetype)indexSet;&#x2F;&#x2F;创建一个索引集合，根据索引值+ (instancetype)indexSetWithIndex:(NSUInteger)value;&#x2F;&#x2F;创建一个索引集合，根据一个NSRange对象+ (instancetype)indexSetWithIndexesInRange:(NSRange)range;&#x2F;&#x2F;创建一个索引集合，根据一个NSRange对象- (instancetype)initWithIndexesInRange:(NSRange)range NS_DESIGNATED_INITIALIZER;&#x2F;&#x2F;用一个已有集合创建一个新的集合- (instancetype)initWithIndexSet:(NSIndexSet *)indexSet NS_DESIGNATED_INITIALIZER;&#x2F;&#x2F;根据索引值创建一个索引集合- (instancetype)initWithIndex:(NSUInteger)value;</code></pre><h1 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h1><pre><code>&#x2F;&#x2F; ndicates whether the index set contains a specific index.- (BOOL)containsIndex:(NSUInteger)value;&#x2F;&#x2F; Indicates whether the receiving index set contains a superset of the indexes in another index set.- (BOOL)containsIndexes:(NSIndexSet *)indexSet;&#x2F;&#x2F; Indicates whether the index set contains the indexes represented by an index range.- (BOOL)containsIndexesInRange:(NSRange)range;&#x2F;&#x2F;判断集合中的索引是否有一个或多个在Range中- (BOOL)intersectsIndexesInRange:(NSRange)range;</code></pre><pre><code>- (NSUInteger)indexPassingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);- (NSUInteger)indexWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);- (NSUInteger)indexInRange:(NSRange)range options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);- (NSIndexSet *)indexesPassingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);- (NSIndexSet *)indexesWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);- (NSIndexSet *)indexesInRange:(NSRange)range options:(NSEnumerationOptions)opts passingTest:(BOOL (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);</code></pre><pre><code>&#x2F;&#x2F; 获取索引集合在某一范围中的个数- (NSUInteger)countOfIndexesInRange:(NSRange)range NS_AVAILABLE(10_5, 2_0);&#x2F;&#x2F;索引集合中元素的个数@property (readonly) NSUInteger count;</code></pre><h1 id="枚举内容"><a href="#枚举内容" class="headerlink" title="枚举内容"></a>枚举内容</h1><pre><code>- (void)enumerateRangesUsingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0);- (void)enumerateRangesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0);- (void)enumerateRangesInRange:(NSRange)range options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSRange range, BOOL *stop))block NS_AVAILABLE(10_7, 5_0);</code></pre><h1 id="两集合的比较"><a href="#两集合的比较" class="headerlink" title="两集合的比较"></a>两集合的比较</h1><pre><code>&#x2F;&#x2F;比较两集合是否相同- (BOOL)isEqualToIndexSet:(NSIndexSet *)indexSet;</code></pre><h1 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h1><pre><code>&#x2F;&#x2F;The following six methods will return NSNotFound if there is no index in the set satisfying the query. @property (readonly) NSUInteger firstIndex;@property (readonly) NSUInteger lastIndex;- (NSUInteger)indexGreaterThanIndex:(NSUInteger)value;- (NSUInteger)indexLessThanIndex:(NSUInteger)value;- (NSUInteger)indexGreaterThanOrEqualToIndex:(NSUInteger)value;- (NSUInteger)indexLessThanOrEqualToIndex:(NSUInteger)value;</code></pre><pre><code>&#x2F;&#x2F;Fills up to bufferSize indexes in the specified range into the buffer and returns the number of indexes actually placed in the buffer;  &#x2F;&#x2F; also modifies the optional range passed in by pointer to be &quot;positioned&quot; after the last index filled into the buffer.  &#x2F;&#x2F; Example: if the index set contains the indexes 0, 2, 4, ..., 98, 100, for a buffer of size 10 and the range (20, 80)   &#x2F;&#x2F; the buffer would contain 20, 22, ..., 38 and the range would be modified to (40, 60).- (NSUInteger)getIndexes:(NSUInteger *)indexBuffer maxCount:(NSUInteger)bufferSize inIndexRange:(nullable NSRangePointer)range;</code></pre><h1 id="枚举索引集合"><a href="#枚举索引集合" class="headerlink" title="枚举索引集合"></a>枚举索引集合</h1><pre><code>- (void)enumerateIndexesUsingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);- (void)enumerateIndexesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);- (void)enumerateIndexesInRange:(NSRange)range options:(NSEnumerationOptions)opts usingBlock:(void (NS_NOESCAPE ^)(NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);</code></pre><h1 id="可变集合的操作"><a href="#可变集合的操作" class="headerlink" title="可变集合的操作"></a>可变集合的操作</h1><h2 id="增加／删除一个索引集合"><a href="#增加／删除一个索引集合" class="headerlink" title="增加／删除一个索引集合"></a>增加／删除一个索引集合</h2><pre><code>- (void)addIndexes:(NSIndexSet *)indexSet;- (void)removeIndexes:(NSIndexSet *)indexSet;- (void)removeAllIndexes;</code></pre><h2 id="增加／删除单个索引"><a href="#增加／删除单个索引" class="headerlink" title="增加／删除单个索引"></a>增加／删除单个索引</h2><pre><code>- (void)addIndex:(NSUInteger)value;- (void)removeIndex:(NSUInteger)value;</code></pre><h2 id="增加／删除一个子范围"><a href="#增加／删除一个子范围" class="headerlink" title="增加／删除一个子范围"></a>增加／删除一个子范围</h2><pre><code>- (void)addIndexesInRange:(NSRange)range;- (void)removeIndexesInRange:(NSRange)range;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSIndexSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protocol的使用及相关事项</title>
      <link href="/2017/06/29/Protocol/"/>
      <url>/2017/06/29/Protocol/</url>
      
        <content type="html"><![CDATA[<p>在iOS开发中，Protocol是一种经常用到的设计模式，苹果的系统框架中也普遍用到了这种方式，比如UITableView中的<uitableviewdelegate>，以及<nscopying>、<nsobject>这样的协议。我想大家也都自定义过协议，一般都用于回调，或者数据传递. 接下来我们来了解下协议使用及相关事项。</nsobject></nscopying></uitableviewdelegate></p><h1 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h1><p>苹果官方给出如下的定义</p><blockquote><p>A protocol declares a programmatic interface that any class may choose to implement. Protocols make it possible for two classes distantly related by inheritance to communicate with each other to accomplish a certain goal. They thus offer an alternative to subclassing. Any class that can provide behavior useful to other classes may declare a programmatic interface for vending that behavior anonymously. Any other class may choose to adopt the protocol and implement one or more of its methods, thereby making use of the behavior. The class that declares a protocol is expected to call the methods in the protocol if they are implemented by the protocol adopter.<br>   <img src="/2017/06/29/Protocol/protocol_2x.png" title="Protocol"></p></blockquote><ul><li>正式协议与非正式协议<blockquote><p>There are two varieties of protocol, formal and informal:</p><ul><li>A formal protocol declares a list of methods that client classes are expected to implement. Formal protocols have their own declaration, adoption, and type-checking syntax. You can designate methods whose implementation is required or optional with the @required and @optional keywords. Subclasses inherit formal protocols adopted by their ancestors. A formal protocol can also adopt other protocols.<br>Formal protocols are an extension to the Objective-C language.</li><li>An informal protocol is a category on NSObject, which implicitly makes almost all objects adopters of the protocol. (A category is a language feature that enables you to add methods to a class without subclassing it.) Implementation of the methods in an informal protocol is optional. Before invoking a method, the calling object checks to see whether the target object implements it. Until optional protocol methods were introduced in Objective-C 2.0, informal protocols were essential to the way Foundation and AppKit classes implemented delegation.</li></ul></blockquote></li></ul><h1 id="协议的定义"><a href="#协议的定义" class="headerlink" title="协议的定义"></a>协议的定义</h1><ol><li>协方式的定义<br><code>`</code>objc<br>@protocol Protocolname <nsobject><br>@required<br>//一系列必选方法<br>@optional<br>//一系列可选方法</nsobject></li></ol><p>//属性的声明<br>@end</p><pre><code>2. 协议里可以定义哪些东西：  &gt;Protocols can include declarations for both instance methods and class methods, as well as properties. 协议可以定义实例方法，类方法以及属性  3. 协议的继承  &gt;In the same way that an Objective-C class can inherit from a superclass, you can also specify that one protocol conforms to another.  It’s best practice to define your protocols to conform to the **NSObject** protocol (some of the **NSObject** behavior is split from its class interface into a separate protocol; the **NSObject** class adopts the **NSObject** protocol)    协议默认继承 ***&lt; NSObject &gt;*** 协议 ,你也可以指定一个其他协议进行继承4. 协议中定义属性    协议里是支持定义属性的，但这只是定义了getter和setter方法，并没有具体的实现。所以当协议属性修饰符为@required时，如果遵守协议的类不实现这两方法，编译器会报出警告。最简单的方式是加上属性同步语句@synthesize propertyName;# 协议的关键字1. @required&gt; By default, all methods declared in a protocol are required methods. This means that any class that conforms to the protocol must implement those methods.    @required修改的协议方法为必要方法，任何遵守该协议的类都必须实现这些方法2. @optional&gt; It’s also possible to specify optional methods in a protocol. These are methods that a class can implement only if it needs to.     @optional修饰的方法为可选方法，这些方法可以根据类的需要进行实现。# 遵守协议1. 设置代理属性    ```objc    @interface Object : NSObject&lt;Protocolname&gt;    @property(nonatomic,weak)id&lt;Protocolname&gt;delegate;    ...    @end</code></pre><pre><code>* &lt;协议列表&gt;    若需要遵守多个协议，将协议用逗号隔开，并放在尖括号&lt;&gt;中 * 添加代理属性    代理属性通常用**weak**修饰，避免强引用</code></pre><ol start="2"><li>实现协议方法<ul><li>@required修饰的协议方法，需要在.m文件中对这些方法进行实现 </li><li>@optional修饰的协议方法，可根据需要在.m文件中进行实现    </li></ul></li></ol><h1 id="检测对象是否遵守协议"><a href="#检测对象是否遵守协议" class="headerlink" title="检测对象是否遵守协议"></a>检测对象是否遵守协议</h1><ol><li>检测某对象是否遵守该协议<br>使用 <code>- (BOOL)conformsToProtocol:(Protocol *)aProtocol;</code>进行检测<pre><code class="objc">[delegate conformsToProtocol:@protocol(Protocolname)];</code></pre></li><li>检测对象是否实现了某方法<br>使用 <code>- (BOOL)respondsToSelector:(SEL)aSelector;</code>进行检测<pre><code class="objc">[delegate respondsToSelector:@selector(methodname)];</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip安装使用详解</title>
      <link href="/2017/06/27/pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/06/27/pip%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本节详细介绍pip的安装以及使用方法</p><h1 id="pip-下载-安装-更新"><a href="#pip-下载-安装-更新" class="headerlink" title="pip 下载/安装/更新"></a>pip 下载/安装/更新</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li>从python官网下载 <a href="https://pypi.python.org/pypi/pip" target="_blank" rel="noopener">pip</a></li><li>使用工具下载<pre><code>wget &#39;https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9&#39;</code></pre><h2 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h2><pre><code>tar -xzvf pip-9.0.1.tar.gz # 解压cd pip-9.0.1 # 切换至目录sudo python setup.py install   # 安装</code></pre><h2 id="pip-更新"><a href="#pip-更新" class="headerlink" title="pip 更新"></a>pip 更新</h2><pre><code>pip install -U pip</code></pre></li></ul><h1 id="pip-使用详解"><a href="#pip-使用详解" class="headerlink" title="pip 使用详解"></a>pip 使用详解</h1><h2 id="pip-安装包"><a href="#pip-安装包" class="headerlink" title="pip 安装包"></a>pip 安装包</h2><pre><code>pip install packagename</code></pre><h2 id="查看已安装的包详情"><a href="#查看已安装的包详情" class="headerlink" title="查看已安装的包详情"></a>查看已安装的包详情</h2><pre><code>pip show  packagename</code></pre><h2 id="pip-列出所有安装的包"><a href="#pip-列出所有安装的包" class="headerlink" title="pip 列出所有安装的包"></a>pip 列出所有安装的包</h2><pre><code>pip list --format=columns</code></pre><h2 id="pip-升级包"><a href="#pip-升级包" class="headerlink" title="pip 升级包"></a>pip 升级包</h2><pre><code>pip install -U  packagename</code></pre><h2 id="pip-卸载包"><a href="#pip-卸载包" class="headerlink" title="pip 卸载包"></a>pip 卸载包</h2><pre><code>pip uninstall packagename</code></pre><h2 id="检查需要更新的包"><a href="#检查需要更新的包" class="headerlink" title="检查需要更新的包"></a>检查需要更新的包</h2><pre><code>pip list --outdate --format=columns</code></pre><h1 id="pip参数解释"><a href="#pip参数解释" class="headerlink" title="pip参数解释"></a>pip参数解释</h1><pre><code> pip --helpUsage:     pip &lt;command&gt; [options]Commands:  install                     安装包.  uninstall                   卸载包.  freeze                      按着一定格式输出已安装包列表  list                        列出已安装包.  show                        显示包详细信息.  search                      搜索包，类似yum里的search.  wheel                       Build wheels from your requirements.  zip                         不推荐. Zip individual packages.  unzip                       不推荐. Unzip individual packages.  bundle                      不推荐. Create pybundles.  help                        当前帮助.General Options:  -h, --help                  显示帮助.  -v, --verbose               更多的输出，最多可以使用3次  -V, --version               现实版本信息然后退出.  -q, --quiet                 最少的输出.  --log-file &lt;path&gt;           覆盖的方式记录verbose错误日志，默认文件：/root/.pip/pip.log  --log &lt;path&gt;                不覆盖记录verbose输出的日志.  --proxy &lt;proxy&gt;             Specify a proxy in the form [user:passwd@]proxy.server:port.  --timeout &lt;sec&gt;             连接超时时间 (默认15秒).  --exists-action &lt;action&gt;    Default action when a path already exists: (s)witch, (i)gnore, (w)ipe, (b)ackup.  --cert &lt;path&gt;               证书.</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真机调试出错问题集</title>
      <link href="/2017/06/22/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>/2017/06/22/%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="证书问题"><a href="#证书问题" class="headerlink" title="证书问题"></a>证书问题</h1><ul><li>问题：<br>  在真机调试安装过程中出现  <code>process launch failed: failed to get the task for XXXX</code>错误信息 <img src="/2017/06/22/真机调试出错问题集/debug_error.png" title="安装出错信息"></li><li>问题原因：<br>  使用的证书不对，  <code>project</code>和<code>targets</code>的 <code>Signing(Debug)</code>证书都必须是开发证书，<code>ADHOC</code>的证书会出现此问题。</li><li>解决方法：<br>  <code>project</code>和<code>targets</code>的<code>Signing(Debug)</code>证书使用开发证书</li></ul>]]></content>
      
      
      <categories>
          
          <category> Xcode8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 日期处理</title>
      <link href="/2017/06/13/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
      <url>/2017/06/13/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，我们经常会遇到一些跟时间处理相关的工作，比如说，时间的比较，加减，格式化，NSString <----> NSDate, NSDate <---> NSCanlendar等等。今天我们来做个整理，理个头绪。方便我们自己记忆。</---></----></p><h1 id="NSDate-介绍"><a href="#NSDate-介绍" class="headerlink" title="NSDate 介绍"></a>NSDate 介绍</h1><ol><li>NSDate对象用来表示一个具体的时间点；</li><li>NSDate是一个类簇。我们所使用的NSDate对象，都是NSDate的私有之类的实体；</li><li>NSDate储存的是GMT时间，使用的时候会根据当前应用指定的时区进行时间上的增减，以供计算或显示。</li></ol><h2 id="方法的使用："><a href="#方法的使用：" class="headerlink" title="方法的使用："></a>方法的使用：</h2><ul><li>类方法初始化</li></ul><pre><code class="objc">//返回当前时间(获取的是GMT时间,需要获取某个时区的时间，看常用方法)+(instancetype)date;//返回以当前时间为基准，然后过了secs秒的时间+(instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;//返回以2001-01-01 GMT为基准，然后过了secs秒的时间+(instancetype)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti;//返回以1970-01-01 GMT为基准，然后过了secs秒的时间+(instancetype)dateWithTimeIntervalSince1970:(NSTimeInterval)secs;//返回以date时间为基准，过了secsToBeAdded秒的时间+(instancetype)dateWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</code></pre><ul><li>实例方法初始化<br><code>`</code>objc<br>//初始化当前时间(获取的是GMT时间,需要获取某个时区的时间，看常用方法)</li></ul><ul><li>(instancetype)init;</li></ul><p>//初始化以当前时间为基准，然后过了secs秒的时间</p><ul><li>(instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</li></ul><p>//初始化以1970-01-01 GMT为基准，然后过了secs秒的时间</p><ul><li>(instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</li></ul><p>//初始化以date时间为基准，过了secsToBeAdded秒的时间</p><ul><li>(instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;<br><code>`</code></li></ul><ul><li>时间之间的比较<br><code>`</code>objc<br>//与anotherDate比较，返回较早的那个日期</li></ul><ul><li>(NSDate <em>)earlierDate:(NSDate </em>)anotherDate;</li></ul><p>//与anotherDate比较，返回较晚的那个日期</p><ul><li>(NSDate <em>)laterDate:(NSDate </em>)anotherDate;</li></ul><p>/<em>该方法用于排序时调用:<br>  当实例保存的日期值与anotherDate相同时返回NSOrderedSame<br>  当实例保存的日期值晚于anotherDate时返回NSOrderedDescending<br>  当实例保存的日期值早于anotherDate时返回NSOrderedAscending </em>/</p><ul><li>(NSComparisonResult)compare:(NSDate *)other;</li></ul><p>//与otherDate比较，相同返回YES</p><ul><li>(BOOL)isEqualToDate:(NSDate *)otherDate;<br><code>`</code></li></ul><ul><li>取回时间间隔<br><code>`</code>objc<br>//以refDate为基准时间，返回实例保存的时间与refDate的时间间隔</li></ul><ul><li>(NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate;</li></ul><p>//以当前时间(Now)为基准时间，返回实例保存的时间与当前时间(Now)的时间间隔</p><ul><li>(NSTimeInterval)timeIntervalSinceNow;</li></ul><p>//以1970/01/01 GMT为基准时间，返回实例保存的时间与1970/01/01 GMT的时间间隔</p><ul><li>(NSTimeInterval)timeIntervalSince1970;</li></ul><p>//以2001/01/01 GMT为基准时间，返回实例保存的时间与2001/01/01 GMT的时间间隔</p><ul><li>(NSTimeInterval)timeIntervalSinceReferenceDate;</li></ul><ul><li>(NSTimeInterval)timeIntervalSinceReferenceDate;<br><code>`</code></li></ul><h1 id="时间的创建"><a href="#时间的创建" class="headerlink" title="时间的创建"></a>时间的创建</h1><ul><li><p>创建当前时间</p><pre><code class="objc">  NSDate * now =  [NSDate date];</code></pre></li><li><p>根据指定的时间差创建时间</p><pre><code class="objc">  NSTimeInterval day = 24*60*60;  NSDate * yesterday = [NSDate dateWithTimeIntervalSinceNow:-day];  NSDate  *tomarror  =[NSDate dateWithTimeIntervalSinceNow:day];</code></pre></li><li>根据已有时间创建日期<pre><code class="objc">  NSTimeInterval day = 24*60*60;  NSDate * now =  [NSDate date];  NSDate * nextDay = [now dateByAddingTimeInterval:day];  NSDate * lastDay = [now dateByAddingTimeInterval:-day];</code></pre></li></ul><h1 id="日期的比较"><a href="#日期的比较" class="headerlink" title="日期的比较"></a>日期的比较</h1><ul><li>两日期是否相同<pre><code class="objc">  BOOL isEqual = [nextDay isEqualToDate:lastDay];</code></pre></li><li><p>比较哪个日期更早</p><pre><code class="objc">  NSDate * earlier_date = [nextDay earlierDate:lastDay];</code></pre></li><li><p>比较哪个日期更晚</p><pre><code class="objc">  NSDate * later_date = [nextDay laterDate:lastDay];</code></pre></li><li><p>求两个时间相同秒数</p><pre><code class="objc">  NSTimeInterval time = [nextDay timeIntervalSinceDate:lastDay];</code></pre></li></ul><h1 id="设置日期格式"><a href="#设置日期格式" class="headerlink" title="设置日期格式"></a>设置日期格式</h1><ul><li>根据系统预设创建日期格式<br><code>`</code>objc</li></ul><ul><li>( NSDateFormatter * )formate{<br>  if (!_formate) {<pre><code>  _formate = [[NSDateFormatter alloc]init];  [_formate setTimeStyle:NSDateFormatterLongStyle];  [_formate setDateStyle:NSDateFormatterLongStyle];</code></pre>  }<br>  return _formate;<br>}<br><code>`</code></li></ul><ul><li><p>根据格式化字符创建日期格式</p><pre><code class="objc">-(NSDateFormatter*)formate{  if (!_formate) {      _formate = [[NSDateFormatter alloc]init];      [_formate setDateFormat:@&quot;yyyy/MM/dd HH/mm/ss Z&quot;];  }  return _formate;}</code></pre><blockquote><p>ps:这里的formate尽量使用一个懒加载的方式，并持有一个实例，有利用节约创建时间。</p></blockquote></li></ul><h1 id="字符串时间"><a href="#字符串时间" class="headerlink" title="字符串时间"></a>字符串<--->时间</---></h1><ul><li><p>字符串转时间</p><pre><code class="objc">  // 1.时间字符串  NSString * datestring = @&quot;2017-06-13 14:44:11 +0800&quot;;  // 2.格式化对象的样式/z大小写都行/格式必须严格和字符串时间一样  [self.formate setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss Z&quot;];  // 3.利用时间格式化对象让字符串转换成时间 (自动转换0时区/东加西减)  NSDate * date = [self.formate dateFromString:datestring];</code></pre></li><li><p>时间转字符串</p></li></ul><pre><code class="objc">    // 1.创建一个时间对象    NSDate * date = [NSDate date];    // 2.设置时间格式化对象的样式    [self.formate setDateFormat:@&quot;yyyy/MM/dd HH:mm:s&quot;];    // 3.利用时间格式化对象对时间进行格式化    NSString * datestring = [self.formate stringFromDate:date];</code></pre><h1 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h1><ul><li>获取当前时区<pre><code class="objc">  NSTimeZone * zone =  [NSTimeZone systemTimeZone];</code></pre></li><li>获取时差<pre><code class="objc">  //时区  NSTimeZone * zone =  [NSTimeZone systemTimeZone];  //时间格式  NSDate * date = [NSDate date];  //时差  NSInteger seconds = [zone secondsFromGMTForDate:date];</code></pre></li></ul><h1 id="NSCalendar"><a href="#NSCalendar" class="headerlink" title="NSCalendar"></a>NSCalendar</h1><p>NSCalendar：日历。对世界上现存的常用历法进行了封装，即提供了不同的历法的时间信息，又支持日历的计算。</p><h1 id="NSDateComponents"><a href="#NSDateComponents" class="headerlink" title="NSDateComponents"></a>NSDateComponents</h1><p>NSDateComponents：时间容器，一个包含了详细的年月日时分秒的容器。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSDate </tag>
            
            <tag> NSCanlendar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English-Level3-Unit3</title>
      <link href="/2017/06/11/English-Level3-Unit3/"/>
      <url>/2017/06/11/English-Level3-Unit3/</url>
      
        <content type="html"><![CDATA[<h1 id="解释你和某个人的相识过程"><a href="#解释你和某个人的相识过程" class="headerlink" title="解释你和某个人的相识过程"></a>解释你和某个人的相识过程</h1><h2 id="过去进行时"><a href="#过去进行时" class="headerlink" title="过去进行时"></a>过去进行时</h2><ul><li>使用过去进行时表示过去发生并持续了一段时间的一个动作或事件。用动词 be 的过去时和动词的 + ing 形式构成过去进行时。<br><code>`</code></li></ul><p>A: I met Elsa in Spain. I was visiting my brother in Madrid. We were eating tapas, and she walked into the restaurant.    我在西班牙碰见了 Elsa。我当时正在马德里看望我的兄弟。我们正在餐馆吃西班牙塔帕，这时她走了进来。<br>B: Were you hoping to find a girlfriend?    你当时想着找女朋友吗？<br>A: No, I was just lucky. I really wasn’t trying to find a girlfriend.    没，我只是走运罢了。我当时真没想着找女朋友。</p><pre><code>**注意，过去进行时态常用于介绍或提供故事的背景信息。**</code></pre><p>So, I was driving in my car. Then I saw the accident.    因此，我当时在开车。然后看到了事故的发生。</p><pre><code>## 讲故事的惯用方法描述过去发生的事情时，使用这些常见的讲故事的惯用方法。### 故事背景中的过去进行时设定故事背景时，使用过去进行时态</code></pre><p>Let me tell you the story about how I met Shane. I was sitting in the movie theater.<br>我告诉你我是怎么遇见 Shane 的故事。我坐在电影院里</p><pre><code>### 开头和结尾你讲的故事应该有头有尾。</code></pre><p>I was sitting in the movie theater. He dropped his pizza on his shoes. I helped him clean up, and we left together.<br>我坐在电影院里。他把披萨掉自己鞋上了，我帮他弄干净，然后一起离开了。</p><pre><code>### 眼神交流和手势在讲故事时，有效运用肢体语言，可以让故事更加吸引人。开始讲时，注视听众的眼睛，尽量保持眼神交流。你还可以使用手势来帮助说明事情。</code></pre><p>I caught a really big fish.<br>（伸出双手放在两旁，展示鱼的长度。）</p><p>I couldn’t believe it!<br>（伸出双手，掌心朝上，表示难以相信。）</p><p>My stomach really hurt.    （把手放在肚子上表示疼痛。）</p><pre><code>## 故事事件的排序</code></pre><p>使用类似表达开始故事。</p><p>At first, I didn’t like him.    起初，我不喜欢他。</p><p>In the beginning, he seemed unfriendly.    刚开始，他看起来不是很友好。</p><p>使用类似表达继续讲述故事。</p><p>Later, we started talking in the break room.    后来，我们在休息室开始交谈。</p><p>After that, we had lunch a couple of times.    之后，我们一起吃过几次午饭。</p><p>Next, we went on a date.    接下来，我们约会了。</p><p>使用类似表达结束故事。<br>Finally, he asked me to marry him.    最后，他要我嫁给他。</p><p>In the end, we got married and had three children.    最后，我们结婚，生了三个孩子。</p><pre><code># 谈论关系## 关系### 个人关系有许多描述个人关系的方法。* Close friends 是指和你关系非常好的人。</code></pre><p>Mary and I are very close friends.         Mary 和我是一对密友。</p><pre><code>* Old friends 是指你认识很长时间的人。</code></pre><p>John and I are old friends. I met him 20 years ago.         John 和我是老朋友。20 年前我们就认识了。</p><pre><code>* Buddy 是表示朋友的非正式用语。注意，该词多为男性使用，指代他们的男性朋友。</code></pre><p>My buddy Harry and I went to college together.         我和我的哥们 Harry 一起上大学。</p><pre><code>* Relatives 是指你家族中的人，比如 cousins 和 aunts。</code></pre><p>For New Year’s Eve, all of my wife’s relatives are coming over for a party.<br>新年前夕，我妻子的全部亲戚都来参加聚会。</p><pre><code>### 职业关系有许多描述职业关系的方法。* Co-workers 和 colleagues 是指和你共事的人。两个词是同义词，意思相同。</code></pre><p>Sarah and I are colleagues.    Sarah 和我是同事。</p><p>Martin is a co-worker.    Martin 是一位同事。</p><pre><code>* boss 和 manager 也表示同一事情，但 boss 正式程度更低。</code></pre><p>Martina is my boss.    Martina 是我的老板。</p><p>My manager is on vacation.    我的经理在度假。</p><pre><code>* 使用 acquaintance 表示你了解一点的人。这可能是个人关系，也可能是职业关系。</code></pre><p>Antonio is an acquaintance of mine. I don’t really know him very well.<br>Antonio 是我的相识。我不是很了解他。<br><code>`</code></p><ul><li>含过去进行时的’While’ 从句</li></ul><p><strong><em>使用 while + 过去进行时，描述被另一动作中断的一个持续动作(While it was raining)。中断的动作使用一般过去时(the electricity went out)</em></strong></p><p>While it was raining, the electricity went out.    下雨的时候停电了。</p><p>While we were sleeping, the electricity came back on.    我们睡觉的时候，又有电了。</p><p><strong><em>当两个过去持续的动作同时发生，你可以把 while 用在任意一个动作上。</em></strong></p><p>While Ken was calling the police, the neighbor’s dog was barking.    当肯在给警方打电话时，邻居的狗在犬叫。</p><p>While I was driving, I was putting on my lip gloss.    开车时，我涂上了润唇膏</p><p><strong><em>如果 while 从句位于句后，不使用逗号。</em></strong></p><p>The electricity came back on while we were sleeping.    我们睡觉时又有电了。</p><p>The neighbor’s dog was barking while Ken was calling the police.    肯在给警察打电话时，邻居的狗在犬叫</p><p>句子重音</p><p>要达到有效的交流，大声说出每个句子里最重要的词以表示强调。注意：terrible 和 accident在句子里是重读的。<br>What a <strong>terrible accident</strong>!</p><p>注意句中的ambulance 和fast要重读：<br>The <strong>ambulance</strong> was going too <strong>fast</strong>.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cocoapods系列教程1</title>
      <link href="/2017/06/02/cocoapods%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/"/>
      <url>/2017/06/02/cocoapods%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<h1 id="cocoapods-打包类库"><a href="#cocoapods-打包类库" class="headerlink" title="cocoapods 打包类库"></a>cocoapods 打包类库</h1><p>需要使用一个cocoapods的插件cocoapods-packager来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。</p><ul><li><p>安装打包插件<br>终端执行以下命令</p><pre><code class="sh">sudo gem install cocoapods-packager</code></pre></li><li><p>打包<br>命令很简单，执行</p><pre><code class="sh">pod package XXXX.podspec --library --force</code></pre><p>命令参数<br><code>`</code>sh<br>//强制覆盖之前已经生成过的二进制库<br>–force</p></li></ul><p>//生成静态.framework<br>–embedded</p><p>//生成静态.a<br>–library</p><p>//生成动态.framework<br>–dynamic</p><p>//动态.framework是需要签名的，所以只有生成动态库的时候需要这个BundleId<br>–bundle-identifier</p><p>//不包含依赖的符号表，生成动态库的时候不能包含这个命令，动态库一定需要包含依赖的符号表。<br>–exclude-deps</p><p>//表示生成的库是debug还是release，默认是release。–configuration=Debug<br>–configuration<br><code>`</code></p><p>参考链接<br><a href="https://www.zybuluo.com/qidiandasheng/note/595740" target="_blank" rel="noopener">pod 二进制化</a></p><p><a href="https://segmentfault.com/a/1190000007076865" target="_blank" rel="noopener">use_frameworks!</a></p>]]></content>
      
      
      <categories>
          
          <category> cocoapods </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODOLIST</title>
      <link href="/2017/06/02/TODOLIST/"/>
      <url>/2017/06/02/TODOLIST/</url>
      
        <content type="html"><![CDATA[<p>GPUImage示例：<br></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-tips</title>
      <link href="/2017/05/22/Python-tips/"/>
      <url>/2017/05/22/Python-tips/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-一些实用技巧知识点集合"><a href="#Python-一些实用技巧知识点集合" class="headerlink" title="Python 一些实用技巧知识点集合"></a>Python 一些实用技巧知识点集合</h1><ol><li>python中的os.system()和os.popen()区别<br>python调用Shell脚本或者是调用系统命令，有两种方法：os.system(cmd)或os.popen(cmd),前者返回值是脚本的退出状态码，后者的返回值返回一个文件描述符号为fd的打开的文件对象。实际使用时视需求情况而选择。</li></ol><ol start="2"><li><p>Python 模块或者包名应该遵守以下的规则:</p><ul><li>全小写</li><li>不要和pypi上已有的包名重复，即使你不想公开发布你的包，因为你的包可能作为其他包的依赖包</li><li>使用下划线分隔单词或者什么都不用(不要使用连字符)</li></ul></li><li><p>python 包的上传 <a href="http://setuptools.readthedocs.io/en/latest/setuptools.html" target="_blank" rel="noopener">setuptools</a><br> <code>python setup.py sdist register upload</code></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 基础入门</title>
      <link href="/2017/05/16/TCP-1/"/>
      <url>/2017/05/16/TCP-1/</url>
      
        <content type="html"><![CDATA[<ul><li>TCP连接的端点是由一个IP地址和一个端口号来唯一标识的 </li><li><p>TCP 是一个可靠的协议，也就是说，除非整个网络出现问题，数据将被完好地按原样正确的传送到另一外一端。这个可靠性是通过以下几个规则来实现的：</p><ul><li><p>为了防止数据在传输过程中被损坏，每个信息包都包含一个<strong>校验码</strong>。这个校验码就是一个用来保证信息包在传输过程中没有被更改的代码。当信息包到达目的地的时候，接收方会对比校验码和收到的信息中的数据，如果校验码不对，该信息包被省略。</p></li><li><p>为了防止信息包丢失，TCP会要求接收方每收到一个信息包都反馈一下，如果接收方没有提供反馈，发送方会自动重发一次。由于系统自动处理这个问题，所以程序的开发者根本不用知道问题的出现。TCP会一直试着发送信息包，一直到接收者收到为止，或者它会判断网络连接断了，并在程序中返回一个错误提示。</p></li><li><p>为了防止信息包重复或顺序列错误，TCP每传送一个信息包都会发送一个序号。接收方会检查这个序号，确保收到该信息包，并把全部信息包按顺序重新合并。同时，如果接收方看到了一个已看过的序号，则该信息包就会被丢弃。</p></li></ul></li></ul><h2 id="TCP-与-UDP-选择："><a href="#TCP-与-UDP-选择：" class="headerlink" title="TCP 与 UDP 选择："></a>TCP 与 UDP 选择：</h2><ul><li><p>用TCP</p><ul><li>您需要一个可靠的数据传输，以确保您的数据完整无缺地到达目的地</li><li>您的协议需要不止一个请求和服务器的回答</li><li>您要发送较多的数据</li><li>初始连接出现短暂的延迟是可以容忍的</li></ul></li><li><p>用UDP</p><ul><li>您不太关心数据包是否到达或者不太在意信息包到达的顺序是否正确，再或者您可以自己察觉这些问题并自己解决</li><li>您的协议只包括基本请求和回答</li><li>您需要尽快建立网络会话</li><li>只传送很少部分数据。UDP 的限制是一个信息包不超过64KB的数所据，通常只用UDP传送1KB以下的数据</li></ul></li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><ul><li>socket 是操作系统中I／O系统的延伸部分，它可以使用进程和机器之间的通信成为可能。</li></ul><h2 id="建立Socket"><a href="#建立Socket" class="headerlink" title="建立Socket"></a>建立Socket</h2><ul><li><p>客户端建立一个socket需要两个步骤：</p><ul><li>建立一个实际的socket对象</li><li>把它连接到远程服务器上。</li></ul></li><li><p>建立Socket对象时，需要告诉系统两件事：</p><ul><li>通信类型<ul><li>指明用什么协议传输数据 （IPV4,IPV6,IPX／SPX，AFP）</li></ul></li><li>协议家族<ul><li>定义数据如何被传输</li></ul></li></ul></li></ul><blockquote><p>通信类型基本上都是AF_INET(IPv4)<br>  协议家族一般表示：</p><ol><li>TCP通信的SOCK_STREAM</li><li>UDP通信的SOCK_DGRAM</li></ol></blockquote><p>建立一个实际的socket对象:<br><code>s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</code><br>连接socket，提供一个tupe（远程主机名／IP地址 , 远程端口）<br><code>s.connect((&#39;www.baidu.com&#39;,80))</code></p><blockquote><p>Ps: C语言的connect()函数需要远程机器的IP地址，在Python中socket对象的connect()函数会根据需要利用DNS把域名自动转换为IP地址，但对端口号则不是这样.</p></blockquote><h2 id="利用socket通信"><a href="#利用socket通信" class="headerlink" title="利用socket通信"></a>利用socket通信</h2><p>利用socket发送和接收数据，python提供了两种方法：socket对象和文件类对象</p><ol><li>socket对象<ul><li>socket对象提供了操作系统的send(),sendto(),recv(),和recvfrom()调用的接口</li><li>使用场景：<ul><li>读写数据、需要协议可以详细的控制时、使用二进制传送固定大小数据时、数据超时需要特殊处理时，</li><li>任何不止需要简单读写时，编写UDP程序时</li></ul></li></ul></li><li><p>文件类对象</p><ul><li>文件类对象提供了read(),write(),readline()接口</li><li><p>文件类对象一般用于面向线性的协议，因为它能够通过提供的readline()函数自动为您处理大多数的解析。</p><blockquote><p>文件类对象一般只对TCP连接工作表现很好，对UDP连接反而不好。原因如下：  </p></blockquote></li></ul><ol><li>TCP连接的行为更像是标准的文件，它们保证数据接收的精确性，并且和文件一样是以字节流形式运转  </li><li>UDP是一种基于信息包的通信。文件类对象没法操作每个基本的信息包，因而建立、接收、发送UDP信息包的基本机制是不能工作的，并且检查也非常困难</li></ol></li></ol><h2 id="socket异常"><a href="#socket异常" class="headerlink" title="socket异常"></a>socket异常</h2><p>socket模块实际上定义了4种可能出现的异常：</p><ol><li>与一般I/O和通信问题有关的socket.error</li><li>与查询地址信息有关的socket.gaierror</li><li>与其他地址错误有关的socket.herror</li><li>与在一个socket上调用settimeout()后，处理超时有关的socket.timeout(需要python2.3或更高版本)</li></ol>]]></content>
      
      
      <categories>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcodebuild 和 altool 工具详解</title>
      <link href="/2017/05/10/xcodebuild/"/>
      <url>/2017/05/10/xcodebuild/</url>
      
        <content type="html"><![CDATA[<h2 id="xcodebuild-是什么？"><a href="#xcodebuild-是什么？" class="headerlink" title="xcodebuild 是什么？"></a>xcodebuild 是什么？</h2><p> xcodebuild 是一款用来打包 Xcode projects 或者 workspaces 的命令行工具</p><blockquote><p>Tips: 在终端输入  <code>man xcodebuild</code> 可以查看具体用法，也可以去查看<a href="https://pewpewthespells.com/blog/migrating_code_signing.html" target="_blank" rel="noopener">官方文档</a></p></blockquote><hr><ol><li><p>查看xcodebuild的简洁用法 <code>xcodebuild -usage</code></p><pre><code class="sh">Usage:     xcodebuild [-project &lt;projectname&gt;] [[-target &lt;targetname&gt;]...|-alltargets] [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...    xcodebuild [-project &lt;projectname&gt;] -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...    xcodebuild -workspace &lt;workspacename&gt; -scheme &lt;schemeName&gt; [-destination &lt;destinationspecifier&gt;]... [-configuration &lt;configurationname&gt;] [-arch &lt;architecture&gt;]... [-sdk [&lt;sdkname&gt;|&lt;sdkpath&gt;]] [-showBuildSettings] [&lt;buildsetting&gt;=&lt;value&gt;]... [&lt;buildaction&gt;]...    xcodebuild -version [-sdk [&lt;sdkfullpath&gt;|&lt;sdkname&gt;] [&lt;infoitem&gt;] ]    xcodebuild -list [[-project &lt;projectname&gt;]|[-workspace &lt;workspacename&gt;]] [-json]    xcodebuild -showsdks    xcodebuild -exportArchive -archivePath &lt;xcarchivepath&gt; -exportPath &lt;destinationpath&gt; -exportOptionsPlist &lt;plistpath&gt;    xcodebuild -exportLocalizations -localizationPath &lt;path&gt; -project &lt;projectname&gt; [-exportLanguage &lt;targetlanguage&gt;...]    xcodebuild -importLocalizations -localizationPath &lt;path&gt; -project &lt;projectname&gt;</code></pre></li></ol><p>参数详解：<br><code>-project projectname</code></p><p>指定工程名，当同一目录下有多个工程时必须指定。</p><p><code>-target tagrgetname</code></p><p>指定编译的target的名称。</p><p><code>-alltargets</code></p><p>编译工程中的所有target。</p><p><code>-worksace workspacename</code></p><p>指定 workspace 的名称。</p><p><code>-scheme schemename</code></p><p>指定 scheme 的名称，编译 workspace 时是必须的。</p><p><code>-destination destinationspecifier</code></p><p>使用 destinationspecifier 指定的设备作为目标设备。默认与 scheme 中选择的兼容。</p><p><code>-destination-timeout timeout</code></p><p>设置搜索目标设备的超时时间，默认是30秒。</p><p><code>-configuration configurationname</code></p><p>当编译每个 target 时使用 configurationname 指定的配置。</p><p><code>-arch architecture</code></p><p>当编译每个 target 时使用 architecture 指定的架构类型。</p><p><code>-sdk [&lt;sdkfullpath&gt; | &lt;sdkname&gt;]</code></p><p>指定编译时所用的 SDK。参数可以是 SDK 的绝对路径，也可以是 SDK 的名称。</p><p><code>-showsdks</code></p><p>列出所有 Xcode 可识别的可用的 SDK，这个参数不会启动编译。</p><p><code>-list</code></p><p>列出工程中的所有 target 和 配置，或者 workspace 的 schemes。不会启动编译。</p><p><code>-derivedDataPath path</code></p><p>覆盖编译 workspace 的 scheme 时的结果数据存放的路径。</p><p><code>-resultBundlePath path</code></p><p>编译 workspace 的 scheme 时把一个 bunndle 写到指定的路径。</p><p><code>-exportArchive</code></p><p>指定一个可以被导出的 archive 文件。需要 -exportFormat，-archivePath和-exportPath` 配合使用，不能在编译时单独使用。</p><p><code>-exportFormat format</code></p><p>指定需要被导出的 archive 文件的格式。可行的格式是 IPA（iOS 包文件），PKG（Mac 包文件）和 APP。如果未指定，则 xcodebuild 则会自动检测使用IPA 或 PKG 格式。</p><p><code>-archivePath xcarchivepath</code></p><p>指定 archive 路径。</p><p><code>-exportPath destinationpath</code></p><p>指定导出的目标文件路径。</p><p><code>-exportProvisioningProfile profilename</code></p><p>指定导出 archive 文件时所使用的 provisioning pofile。</p><p><code>-exportSigningIdentity identityname</code></p><p>指定导出 archive 文件时所使用的应用签名 id。在可能的情况下，这个可以被 -exportProvisioningProfile 自动推导出来。</p><p><code>-exportInstallerIdentity identityname</code></p><p>指定导出 archive 文件时所使用的安装签名 id。如果可能，这个可以被 -exportSigningIdentity 或 -exportProvisioningProfile 自动推导出来。</p><p><code>-exportWithOriginalSigningIdentity</code></p><p>指定创建可被导出的 archive 文件时所使用的签名文件。</p><p><code>buildaction ...</code></p><p>指定一个或多个编译 target 时的编译行为。可行的编译行为有： - build 编译根环境下（SYMROOT）的 target。默认行为。</p><ol><li><p>analyze 编译并且分析根环境（SYMROOT）下的一个 target 或者 scheme。需要指定一个 scheme。</p></li><li><p>archive Archive 根环境（SYMROOT）下的一个 scheme。需要指定一个 scheme。</p></li><li><p>test 测试跟环境（SYMROOT）下的一个 scheme。需要指定一个scheme。需要指定一个 scheme 和一个可选的目标。</p></li><li><p>installsrc 拷贝工程代码到源代码根目录（SRCROOT）。</p></li><li><p>install 编译 target 并且安装到发布目录下的 target 安装目录。</p></li><li><p>clean 从编译根目录下（SYMROOT）移除编译产品和中间文件。</p></li></ol><p><code>-xcconfig filename</code></p><p>当编译所有 targets 的时候从指定的文件加载编译设置。这些设置会覆盖其他的编译设置，包括命令行中单独传递的设置。</p><p><code>-dry-run, -n</code></p><p>打印本来要执行但是未执行的命令。</p><p><code>-skipUnavailableActions</code></p><p>跳过不能执行的编译而不是失败。这个选项仅仅在 -scheme 参数使用了的时候有效。</p><p><code>setting=value</code></p><p>设置编译设置的值为 value。</p><p><code>-userdefault=value</code></p><p>设置用户默认设置为 value。</p><p><code>-version</code></p><p>显示 Xcode 的版本信息。不会启动编译。当和 -sdk 一起使用的时候，将会显示指定的 SDK 的版本信息，或者 -sdk 后面未指定 SDK 则会显示所有的 SDK 版本信息。另外，如果指定了 infoitem 参数则一个单行的版本信息将会显示。</p><p><code>-usage</code></p><h2 id="显示-xcodebuild-的使用信息。"><a href="#显示-xcodebuild-的使用信息。" class="headerlink" title="显示 xcodebuild 的使用信息。"></a>显示 xcodebuild 的使用信息。</h2><ol><li><p>编译工程文件<br><code>xcodebuild -project ActionSheet.xcodeproj  -target ActionSheet -configuration Release build</code></p></li><li><p>编译工作空间文件<br><code>xcodebuild -workspace Emoticon.xcworkspace -scheme Emoticon build</code></p></li></ol><p>总结用法</p><ol><li><p><code>xcodebuild [-project name.xcodeproj] [[-target targetname] ... | -alltargets] build</code><br> build 指定 project，其中 -target 和 -configuration 参数可以使用 xcodebuild -list 获得，-sdk 参数可由 xcodebuild -showsdks 获得，[buildsetting=value …] 用来覆盖工程中已有的配置。 action… 的可用选项如下, 打包的话当然用 build，这也是默认选项</p></li><li><p><code>xcodebuild -workspace name.xcworkspace -scheme schemename build</code><br> build 指定 workspace，当我们使用 CocoaPods 来管理第三方库时，会生成 xcworkspace 文件，这样就会用到这种打包方式.</p></li></ol><blockquote><p>常用的build action有如下：</p><ul><li>build<br>  Build the target in the build root (SYMROOT). This is the default action, and is used if no action is given.</li></ul></blockquote><blockquote><ul><li>analyze<br>  Build and analyze a target or scheme from the build root (SYMROOT). This requires specifying a scheme.</li></ul></blockquote><blockquote><ul><li>archive<br>  Archive a scheme from the build root (SYMROOT). This requires specifying a scheme.</li></ul></blockquote><blockquote><ul><li>test<br>  Test a scheme from the build root (SYMROOT). This requires specifying a scheme and optionally a destination.</li></ul></blockquote><blockquote><ul><li>installsrc<br>  Copy the source of the project to the source root (SRCROOT).</li></ul></blockquote><blockquote><ul><li>install<br>  Build the target and install it into the target’s installation directory in the distribution root (DSTROOT).</li></ul></blockquote><blockquote><ul><li>clean<br>  Remove build products and intermediate files from the build root (SYMROOT).</li></ul></blockquote><ol start="3"><li>编译并生成.xcarchive包xcodebuild archive [-optionName]…</li></ol><pre><code>xcodebuild archive -archivePath /Users/UserName/Desktop/App/archive/XXX -workspace XXX.xcworkspace -scheme XXX -configuration Debug -sdk iphoneos9.3</code></pre><pre><code>命令                                  说明-archivePath PATH                    保存生成.xcarchive包路径-workspace NAME                        指定工作空间文件XXX.xcworkspace-scheme NAME                        指定构建工程名称-configuration [Debug/Release]      选择Debug或者Release构建-sdk NAME                            指定编译时使用的SDK</code></pre><ol start="4"><li>.archive包导出ipa文件xcodebuild -exportArchive [-optionName]…</li></ol><pre><code>xcodebuild -exportArchive -archivePath /Users/UserName/Desktop/App/archive/XXX.xcarchive -exportPath /Users/UserName/Desktop/App/ipa/ -exportOptionsPlist /Users/UserName/Desktop/App/XXX.plist</code></pre><pre><code>命令                      说明-archivePath            选择要导出的.xcarchive包路径-exportPath                导出ipa保存目录-exportOptionsPlist        导出过程中需要的配置文件路径</code></pre><ol start="5"><li>Export Options Plist 打包plist文件method 选项<br>method: (String) The method of distribution, which can be set as any of the following:</li></ol><ul><li>app-store</li><li>enterprise</li><li>ad-hoc</li><li>development</li><li>teamID: (String) The development program team identifier.</li><li>uploadSymbols: (Boolean) Option to include symbols in the generated ipa file.</li><li>uploadBitcode: (Boolean) Option to include Bitcode.<br>生成plist文件中需要包含作上述的 method键值对  其他三个可选</li></ul><p>ps: plist文件格式如下，字段可根据需要增加：(小编就因格式不对，折腾了好久)</p><pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;        &lt;key&gt;teamID&lt;/key&gt;        &lt;string&gt;****&lt;/string&gt;        &lt;key&gt;method&lt;/key&gt;        &lt;string&gt;app-store&lt;/string&gt;        &lt;key&gt;uploadSymbols&lt;/key&gt;        &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt;</code></pre><ol start="6"><li>获取工程的target列表 <code>xcodebuild -list -json</code> 得以一个json字符串<pre><code>{&quot;project&quot; : { &quot;targets&quot; : [   &quot;Mask&quot;,   &quot;MaskTests&quot;,   &quot;MaskUITests&quot;,   &quot;MaskRandomUITests&quot; ], &quot;schemes&quot; : [   &quot;Mask&quot; ], &quot;configurations&quot; : [   &quot;Debug&quot;,   &quot;Release&quot; ], &quot;name&quot; : &quot;Mask&quot;}}%</code></pre></li></ol><h1 id="altool-上传-ipa"><a href="#altool-上传-ipa" class="headerlink" title="altool 上传 ipa"></a>altool 上传 ipa</h1><p>您可用 altool：Application Loader 的命令行工具来验证并上传您的应用程序二进制文件到 App Store。</p><p>若要在上传或自动上传有效的构建版本到 App Store 之前验证您的构建版本，可将 altool 包含进您的持续集成系统中。altool 在 <code>Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/</code> 文件夹中。</p><p>若要运行 altool，请在命令行执行以下一项操作：</p><pre><code class="sh"> altool --validate-app -f file -u username [-p password] [--output-format xml] altool --upload-app -f file -u username [-p password] [--output-format xml]</code></pre><p>参数详解<br>其中                指定<br><code>--validate-app</code>      您要验证的应用程序。<br><code>--upload-app</code>        您要上传的应用程序。<br><code>-f file</code>             您正在验证或上传的应用程序的路径和文件名。<br><code>-u username</code>         您的用户名。<br><code>-p password</code>         您的用户密码。<br><code>--output-format [xml | normal]</code><br>您要 Application Loader 以结构化的 XML 格式还是非结构化的文本格式返回输出信息。Application Loader 默认以文本格式返回输出信息。<br><a href="http://help.apple.com/itc/apploader/#/apdATD1E53-D1E1A1303-D1E53A1126" target="_blank" rel="noopener">Application Loader</a></p><p>另附上小编编写一个便捷的打包工具 <a href="https://github.com/zhipengbird/xcode_archive" target="_blank" rel="noopener">xcodearchive</a>,欢迎各位star^_^</p>]]></content>
      
      
      <categories>
          
          <category> xcode_archive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcodebuild </tag>
            
            <tag> altool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-email</title>
      <link href="/2017/05/05/python-email/"/>
      <url>/2017/05/05/python-email/</url>
      
        <content type="html"><![CDATA[<h1 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h1><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。<br>邮件传送代理 (Mail Transfer Agent，MTA) 程序使用SMTP协议来发送电邮到接收者的邮件服务器。SMTP协议只能用来发送邮件，不能用来接收邮件。<br>大多数的邮件发送服务器 (Outgoing Mail Server) 都是使用SMTP协议。SMTP协议的默认TCP端口号是25。<br>SMTP协议的一个重要特点是它能够接力传送邮件。它工作在两种情况下：一是电子邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。</p><h1 id="POP3-Post-Office-Protocol-amp-IMAP-Internet-Message-Access-Protocol"><a href="#POP3-Post-Office-Protocol-amp-IMAP-Internet-Message-Access-Protocol" class="headerlink" title="POP3 (Post Office Protocol) &amp; IMAP (Internet Message Access Protocol)"></a>POP3 (Post Office Protocol) &amp; IMAP (Internet Message Access Protocol)</h1><p>POP协议和IMAP协议是用于邮件接收的最常见的两种协议。几乎所有的邮件客户端和服务器都支持这两种协议。 </p><p>POP3协议为用户提供了一种简单、标准的方式来访问邮箱和获取电邮。使用POP3协议的电邮客户端通常的工作过程是：连接服务器、获取所有信息并保存在用户主机、从服务器删除这些消息然后断开连接。POP3协议的默认TCP端口号是110。</p><p>IMAP协议也提供了方便的邮件下载服务，让用户能进行离线阅读。使用IMAP协议的电邮客户端通常把信息保留在服务器上直到用户显式删除。这 种特性使得多个客户端可以同时管理一个邮箱。IMAP协议提供了摘要浏览功能，可以让用户在阅读完所有的邮件到达时间、主题、发件人、大小等信息后再决定 是否下载。IMAP协议的默认TCP端口号是143。  </p><h1 id="邮件格式-RFC-2822"><a href="#邮件格式-RFC-2822" class="headerlink" title="邮件格式 (RFC 2822)"></a>邮件格式 (RFC 2822)</h1><p>每封邮件都有两个部分：邮件头和邮件体，两者使用一个空行分隔。<br>邮件头每个字段 (Field) 包括两部分：字段名和字段值，两者使用冒号分隔。有两个字段需要注意：From和Sender字段。  </p><pre><code>* From字段指明的是邮件的作者，  * Sender字段指 明的是邮件的发送者。  </code></pre><p>如果From字段包含多于一个的作者，必须指定Sender字段；如果From字段只有一个作者并且作者和发送者相同，那么不应该再 使用Sender字段，否则From字段和Sender字段应该同时使用。<br>邮件体包含邮件的内容，它的类型由邮件头的Content-Type字段指明。RFC 2822定义的邮件格式中，邮件体只是单纯的ASCII编码的字符序列。</p><h1 id="MIME-Multipurpose-Internet-Mail-Extensions-RFC-1341"><a href="#MIME-Multipurpose-Internet-Mail-Extensions-RFC-1341" class="headerlink" title="MIME (Multipurpose Internet Mail Extensions) (RFC 1341)"></a>MIME (Multipurpose Internet Mail Extensions) (RFC 1341)</h1><p>　　MIME扩展邮件的格式，用以支持非ASCII编码的文本、非文本附件以及包含多个部分 (multi-part) 的邮件体等。</p><h1 id="邮件头"><a href="#邮件头" class="headerlink" title="邮件头"></a>邮件头</h1><p>用python发的整个邮件，每个元素都以/r/n结束（当然如果内容里有/r/n如何就不太清楚了）。其邮件内容都是被一个大的boundary包起来的，Content-Type为multipart/mixed。<br>header部分，大致有MIME-Version、From、To、Subject等，看情况而定（事实上，我观察注意到，很多邮件服务器在处理邮件的时候，都会自动会加上些邮件头，如Received等）</p><ul><li>From表示邮件来源，格式为：显示名 &lt;邮件地址&gt;，记得两个项目之间应使用空格隔开。其中显示名部分可以允许为中文，但如果是中文，就要注意编码的问题</li><li>To里如果只有一个地址的话，就和From里的格式是完全一样的。如果有多个，那么每个之间用逗号及换行（,/r/n)分割就可以了。一般我们在python代码里可以只用逗号分隔就行了，底层库会自动加上/r/n的。</li><li>Subject的内容，其实也和From里的“显示名”的编码方式一样的</li><li>邮件的正文和附件是在一起编码的，只是他们的Content-Type有区别罢了。比如正文的type一般是text/plain或text/html等，而附件的type一般是：application/octet-stream。但type不同，对应的内容头也会略有不同。</li></ul><pre><code class="python">from email.header import  Headerfrm = Header(&#39;平华&#39;,&#39;utf-8&#39;)frm.append(&#39;&lt;yuanph@ushareit.com&gt;&#39;,&#39;ascii&#39;)print frm.encode()# =?utf-8?b?5bmz5Y2O?= &lt;yuanph@ushareit.com&gt;import  base64base64.b64decode(&#39;5bmz5Y2O&#39;,&#39;utf-8&#39;)# &#39;\xe5\xb9\xb3\xe5\x8d\x8e&#39;</code></pre><p>解析：<br>=?utf-8?b?5bmz5Y2O?= <a href="mailto:&#x79;&#x75;&#97;&#x6e;&#112;&#104;&#x40;&#117;&#x73;&#104;&#97;&#x72;&#101;&#x69;&#x74;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x79;&#x75;&#97;&#x6e;&#112;&#104;&#x40;&#117;&#x73;&#104;&#97;&#x72;&#101;&#x69;&#x74;&#x2e;&#99;&#111;&#x6d;</a> 这个内容里本身就有编码信息，因此反过来解析也很简单。因为=?、?、?=属于分隔符，用这三个分隔符简单的split后 。re.split(r’’’=\?|\?=|\?’’’,’’’=?utf-8?b?5bmz5Y2O?=’’’)。  可以得到[‘’, ‘utf-8’, ‘b’, ‘5bmz5Y2O’, ‘’] ，根据python的源码显示，utf-8表示数据编码，b表示base64。那么对内容’5bmz5Y2O’进行base64.b64decode后，就可得到utf-8编码的“平华”二个字。</p><h1 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h1><p><strong>表明传递的信息类型</strong><br>Content-Type表明信息类型，缺省值为” text/plain”。它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video。<br>每一种主要类型下面又有许多种次要类型，常见的有：</p><pre><code class="html">text/plain：纯文本，文件扩展名.txttext/html：HTML文本，文件扩展名.htm和.htmlimage/jpeg：jpeg格式的图片，文件扩展名.jpgimage/gif：GIF格式的图片，文件扩展名.gifaudio/x-wave：WAVE格式的音频，文件扩展名.wavaudio/mpeg：MP3格式的音频，文件扩展名.mp3video/mpeg：MPEG格式的视频，文件扩展名.mpgapplication/zip：PK-ZIP格式的压缩文件，文件扩展名.zip</code></pre><p>“Content-Type: multipart/alternative;”表明这封信的内容，是纯文本和HTML文本的混合。另两个可能的值是<code>multipart/mixed</code>和<code>multipart/related</code>，分别表示<code>信件内容中有二进制内容</code>和<code>信件带有附件</code></p><p>参考链接：<br><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">MIME笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> email </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做决定</title>
      <link href="/2017/05/04/English-Level3-Unit2/"/>
      <url>/2017/05/04/English-Level3-Unit2/</url>
      
        <content type="html"><![CDATA[<h2 id="as…-as-做比较"><a href="#as…-as-做比较" class="headerlink" title="as….as 做比较"></a>as….as 做比较</h2><p>用as+形容词+as 表达在某种情况下，两样东西是一样的</p><pre><code>That dog isn&#39;t as loud as my parrot. 那条狗没我的鹦鹉吵。</code></pre><p>用as +副词 + as 表达两种事物在某种情况下相同</p><pre><code>Tom sings as well as Jack. Tom 歌唱得像Jack一样好。Your brother eats as quickly as my snake. 你的兄弟吃起东西来跟我的蛇一样快。</code></pre><h2 id="形容词的规则最高级"><a href="#形容词的规则最高级" class="headerlink" title="形容词的规则最高级"></a>形容词的规则最高级</h2><ul><li><p>当用一个形容词来表述某物比所有其他东西具有更多某种品质时，形容词变化为最高级。 如果该形容词只有一个音节，最高级就是形容词+est</p></li><li><p>以-y结尾的双音节形容词在构成最高级时，变-y为-i ,加-est .例如funny 的最高级为funiest</p></li><li><p>对于大部分有两个或更多的形容词，用most或least+形容词，形容词保持不变。</p></li></ul><h2 id="不规则比较级和最高级"><a href="#不规则比较级和最高级" class="headerlink" title="不规则比较级和最高级"></a>不规则比较级和最高级</h2><p>Good 和 bad 是两个常用的形容词，都有不规则的比较级和最高级形式。</p><ul><li>good - better - best</li><li>bad - worse - worst</li></ul><h2 id="建议与推荐"><a href="#建议与推荐" class="headerlink" title="建议与推荐"></a>建议与推荐</h2><p>你在询问旅行建议和推荐时，旅行社职员可能会先询问你一些问题。</p><p>A: When are you thinking of going?  您想什么时候去？<br>B: I’m thinking of going in January.    我在考虑一月份去。</p><p>A: What are you looking for, exactly?      您到底在找什么？<br>B: I’m interested in going somewhere beautiful.我想去风景优美的地方。</p><p>A: Are you thinking more of mountains or the ocean? 您更想去山区地带还是去海边呢？<br>B: I’m thinking more of the mountains.  我更想去山区。      </p><p>您可以请代理提出建议或推荐。注意，这些带有would 的句子都很有礼貌。</p><p>What would you suggest?    您想推荐什么？</p><p>What would you recommend?    您想推荐什么？</p><p>旅行社职员可以使用类似表达提出建议和推荐：</p><p>I’d suggest that you go to Hawaii.    我建议您去夏威夷。</p><p>I’d recommend that you go to Hawaii.    我建议你去夏威夷。</p><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><ul><li><p>在系列表达中，用 (,)隔开词句，不要在and前用逗号。</p><p>  I saw dogs, turtles, birds, a snake and fish in the park.</p></li><li><p>当连个从句被but连接时，用逗号。逗号放在but前。</p><p>  I saw an elephant, but I didn’t see a lion.</p></li><li><p>当when 或after 引导的从句放在句首时，用逗号与后面的主句隔开。</p><p>  When I was on vacation in Chile, I saw a lot of wild animals.</p><p>  After I got home, I looked at all my photographs.</p></li><li><p>如果 when 或after 从句放在句尾，不要用逗号与前面的主句隔开。</p><p>  John talked a lot about Africa after he got home.</p><p>  They got a new cat when their old one died.</p></li></ul><ul><li><p>使用逗号分隔城市名称与州或国家。</p><p>  I live in Beijing, China.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让陌生人迅速相爱的36个问题 </title>
      <link href="/2017/04/09/%E8%AE%A9%E9%99%8C%E7%94%9F%E4%BA%BA%E8%BF%85%E9%80%9F%E7%9B%B8%E7%88%B1%E7%9A%8436%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/09/%E8%AE%A9%E9%99%8C%E7%94%9F%E4%BA%BA%E8%BF%85%E9%80%9F%E7%9B%B8%E7%88%B1%E7%9A%8436%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>曼迪·莱恩·卡特隆(Mandy Len Catron)为“现代爱情”专栏写了一篇文章《如何快速与陌生人相爱》，她在文中提到心理学家阿瑟·亚伦(Arthur Aron)等人的研究成果：两个陌生人之间的亲密关系或许可以通过彼此询问一些特别的个人化问题而快速升温。这36个问题分为三组，一组比一组来得寻根究底。</p><p>这个理论的核心是，共同的脆弱能促进亲近感。这项研究的作者们称：“同伴之间发展亲密关系的关键模式在于持续、逐步升级、相互且个人化的袒露自我。”允许自己和另一个人共享脆弱可能非常困难，下面这个练习能迫使你做到这一点。</p><p>卡特隆和她的朋友在文中尝试的最后一件事是彼此对视四分钟，这个过程没有被详细记录（其实可以从两分钟到四分钟不等）。但是卡特隆毫不迟疑地推荐这件事。“两分钟的效果已经很惊人了，”她告诉我，“四分钟真的非常有效。”</p><p> 第一组</p><ol><li><p>如果可以在世界上所有人中任意选择，你想邀请谁共进晚餐？</p></li><li><p>你想成名吗？想以什么方式成名？</p></li><li><p>打电话之前你会先排练一下要说什么吗，为什么？</p></li><li><p>对你来说，“完美”的一天是什么样的？</p></li><li><p>你上次自己唱起歌来是在什么时候，给别人唱呢？</p></li><li><p>如果你能活到90岁，同时可以一直保持30岁时的心智或身体，你会选择保持哪一种呢，心智还是身体？</p></li><li><p>你是否曾经秘密地预感到自己会以怎样的方式死去？</p></li><li><p>说出三件你和你的伴侣看上去相同的特征。</p></li><li><p>人生中的什么东西最令你感激？</p></li><li><p>如果你能改变被抚养成人过程中的一件事，会是哪一件。</p></li><li><p>花四分钟时间，尽可能详细告诉伴侣你的人生经历。</p></li></ol><p>12.如果你明天一觉醒来就能拥有某种才能或能力，你希望那会是什么能力呢？</p><p>第二组</p><ol start="13"><li><p>如果有一个水晶球可以告诉你关于自己、人生，未来乃至任何事情的真相，你会想知道吗？</p></li><li><p>有没有什么事是你一直梦想去做而没有去做的，为什么没有做？</p></li><li><p>你人生中最大的成就是什么？</p></li><li><p>在一段友谊之中你最珍视的是什么？</p></li><li><p>你最宝贵的记忆是什么？</p></li><li><p>你最糟糕的记忆是什么？</p></li><li><p>假如你知道自己在一年内就会突然死去，你会改变现在的生活方式吗？为什么？</p></li><li><p>友谊对于你来说意味着什么？</p></li><li><p>爱与情感在你生活中扮演着什么样的角色？</p></li><li><p>和你的伴侣轮流说出心目中对方的一个好品质，每人说五条。</p></li><li><p>你的家人之间关系是否亲密而温暖，你觉得自己的童年比其他人更快乐吗？</p></li><li><p>你和母亲之间的关系是怎样的？</p></li></ol><p>第三组</p><ol start="25"><li><p>每人用“我们”造三个句子，并含有实际情况，比如“我们俩在屋子里，感觉……”</p></li><li><p>补完这个句子：“我希望和某人在一起，分享……”</p></li><li><p>如果你想和对方成为亲近的朋友，请告诉对方有什么重要的事情是他或她需要知道的。</p></li><li><p>告诉对方你喜欢他或她身上的什么东西，要非常诚实，说些你不会对萍水之交说的东西。</p></li><li><p>和对方分享生命中那些尴尬的时刻。</p></li><li><p>你上次在别人面前哭是什么时候？自己哭呢？</p></li><li><p>告诉对方，你已经喜欢上了他或她身上的什么品质。</p></li><li><p>你觉得什么东西是严肃到不能开玩笑的，假如有的话。</p></li><li><p>如果你今晚就将死去，而且没有机会同任何人联络，你会因为之前没有对别人说什么话而感到遗憾，你为什么到现在都没有对他们说这些话呢？</p></li><li><p>假设你拥有的全部东西都在你的房子里，现在房子着了火，救出家人和宠物之后，你还有机会安全地冲进去最后一次，取出最后一件东西，你会拿什么，为什么？</p></li><li><p>你的家人中，谁去世了会令你最难过，为什么？</p></li><li><p>说出一件你的个人问题，问对方如果遇到此事要如何解决。另外，也要让对方如实告诉你，在他或她眼中，你对于这个问题的感受是怎样的。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计数初步</title>
      <link href="/2017/04/09/%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/"/>
      <url>/2017/04/09/%E8%AE%A1%E6%95%B0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>求和符号（∑）(求和符号）</p><ul><li>英语名称：Sigma</li><li>汉语名称：西格玛（大写Σ，小写σ）</li><li>第十八个希腊字母。在希腊语中，如果一个单字的最末一个字母是小写sigma，要把该字母写成 ς ，此字母又称final sigma（Unicode: U+03C2）。在现代的希腊数字代表6。</li></ul><p>详解</p><ol><li>∑符号表示求和，∑读音为sigma，英文意思为Sum，Summation,就是和。<ul><li>用∑表示求和的方法叫做Sigma Notation，或∑ Notation。它的小写是σ，在物<br>理上经常用来表示面密度。(相应地，ρ表示体密度，η表示线密度)</li></ul></li><li>∑的用法：<ul><li>其中i表示下界，n表示上界， k从i开始取数，一直取到n,全部加起来。</li><li>∑i 这样表达也可以，表示对i求和，i是变数</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期格式</title>
      <link href="/2017/03/23/DateFormate/"/>
      <url>/2017/03/23/DateFormate/</url>
      
        <content type="html"><![CDATA[<h2 id="日期格式："><a href="#日期格式：" class="headerlink" title="日期格式："></a>日期格式：</h2><pre><code class="sh">G:         公元时代，例如AD公元  yy:        年的后2位  yyyy:      完整年  MM:        月，显示为1-12,带前置0  MMM:       月，显示为英文月份简写,如 Jan  MMMM:      月，显示为英文月份全称，如 Janualy  dd:        日，2位数表示，如02  d:         日，1-2位显示，如2，无前置0  EEE:       简写星期几，如Sun   EEEE:      全写星期几，如Sunday  aa:        上下午，AM/PM   H:         时，24小时制，0-23  HH:        时，24小时制，带前置0  h:         时，12小时制，无前置0  hh:        时，12小时制，带前置0  m:         分，1-2位  mm:        分，2位，带前置0  s:         秒，1-2位  ss:        秒，2位，带前置0  S:         毫秒  Z：        GMT（时区）  </code></pre><h1 id="星期："><a href="#星期：" class="headerlink" title="星期："></a>星期：</h1><pre><code class="c"> 星期一：Mon. = Monday 星期二： Tues.=Tuesday  星期三： Wed.=Wednesday  星期四： Thur.=Thursday  星期五： Fri.=Friday  星期六： Sat.=Saturday  星期天： Sun.=Sunday </code></pre><p>#月份</p><pre><code class="c"> 一月份＝ JAN.  Jan.=January  二月份＝ FEB.  Feb.=February  三月份＝ MAR.  Mar.=March  四月份＝ APR.  Apr.=April  五月份＝ MAY  May=May  六月份＝ JUN.  Jun.=June  七月份＝ JUL.  Jul.=July 八月份＝ AUG.  Aug.=August  九月份＝ SEP.  Sept.=September 十月份＝ OCT.  Oct.=October 十一月份＝ NOV.  Nov.=November 十二月份＝ DEC.  Dec.=December</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日期格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CoreLocation</title>
      <link href="/2017/03/22/CoreLocation/"/>
      <url>/2017/03/22/CoreLocation/</url>
      
        <content type="html"><![CDATA[<h1 id="获取定位信息"><a href="#获取定位信息" class="headerlink" title="获取定位信息"></a>获取定位信息</h1><p>iOS开发者使用<code>CoreLocation.framework</code>框架进行定位非常简单<code>CoreLocation</code>框架的常用API主要有如下几个。</p><ul><li><code>CLLocationManager</code>定位管理器类。</li><li><code>CLLocationManagerdelegate</code>该协议代表定位管理器的<code>delegate</code>协议。实现该协议的对象可负责处理<code>CLLocationManager</code>的定位事件。</li><li><code>CLLocation</code>该对象代表位置。该对象包含了当前设备的 <em>经度</em>、<em>纬度</em>、<em>高度</em>、<em>速度</em>、<em>路线</em>等信息还包含了该定位信息的水平精确度、垂直精确度以及时间戳信息。</li><li><code>CLHeading</code>该对象代表设备的移动方向。</li><li><code>CLRegion</code>该对象代表一个区域。一般程序不会直接使用该类而是使用它的两个子类即<code>CLCircularRegion</code>圆形区域和<code>CLBeaconRegion</code>蓝牙信号区。<br>除此之外<code>CoreLocation</code>框架还涉及一个<code>CLLocationCoordinate2D</code>结构体变量该结构体变量包含 <em>经度</em>、<em>纬度</em> 两个值。其中<code>CLLocation</code>对象的<code>coordinate</code>属性就是一个<code>CLLocationCoordinate2D</code>结构体变量。</li></ul><h1 id="获取位置信息"><a href="#获取位置信息" class="headerlink" title="获取位置信息"></a>获取位置信息</h1><p>使用<code>CoreLocation.framework</code>进行定位只要如下3步即可。</p><ul><li>创建<code>CLLocationManager</code>对象该对象负责获取定位相关信息。并为该对象设置一些必要的属性。</li><li>为<code>CLLocationManager</code>指定<code>delegate</code>属性该属性值必须是一个实现<code>CLLocationManagerDelegate</code>协议的对象。实现              <code>CLLocationManagerDelegate</code>协议时可根据需要实现协议中特定的方法。</li><li>调用<code>CLLocationManager</code>的<code>startUpdatingLocation</code>方法获取定位信息。定位结束时可调用<code>stopUpdatingLocation</code>方法结束获取定位信息</li></ul><p>#解析：</p><ul><li><code>LLocationManager</code><em>负责获取定位信息</em> 而<code>delegate</code>则 <em>负责处理定位事件</em> ——通过这些事件即可获取设备所在位置。</li></ul><h2 id="CLLocationManager还提供了如下类方法来判断当前设备的定位相关服务状态。"><a href="#CLLocationManager还提供了如下类方法来判断当前设备的定位相关服务状态。" class="headerlink" title="CLLocationManager还提供了如下类方法来判断当前设备的定位相关服务状态。"></a>CLLocationManager还提供了如下类方法来判断当前设备的定位相关服务状态。</h2><ul><li><p><code>+ locationServicesEnabled</code>返回当前定位服务是否可用。</p></li><li><p><code>+ deferredLocationUpdatesAvailable</code>返回延迟定位更新是否可用。</p></li><li><p><code>+ significantLocationChangeMonitoringAvailable</code>返回重大位置改变监听是否可用。</p></li><li><p><code>+ headingAvailable</code>返回该设备是否支持磁力计计算方向。</p></li><li><p><code>+ isRangingAvailable</code>返回蓝牙信号范围服务是否可用。这是iOS 7新增的方法。</p></li></ul><p>除此之外在使用CLLocationManager开始定位之前还可为该对象设置如下属性。</p><ul><li><code>pausesLocationUpdatesAutomatically</code>设置iOS设备是否可暂停定位来节省电池的电量。如果该属性设为“YES”则当iOS设备不再需要定位数据时iOS设备可以自动暂停定位。</li></ul><ul><li><p><code>distanceFilter</code>设置<code>CLLocationManager</code>的自动过滤距离。也就是说只有当设备在水平方向的位置改变超过该数值以米为单位指定的距离时才会生成一次位置改变的信号。</p></li><li><p><code>desiredAccuracy</code>设置定位服务的精度。该属性值支持</p><ul><li><code>kCLLocationAccuracyBestForNavigation</code>导航级的最佳精确度、</li><li><code>kCLLocationAccuracyBest</code>最佳精确度、</li><li><code>kCLLocationAccuracy NearestTenMeters</code>10米误差、</li><li><code>kCLLocationAccuracyHundredMeters</code>百米误差、</li><li><code>kCLLocationAccuracyKilometer</code>千米误差、</li><li><code>kCLLocationAccuracyThreeKilometers</code>三千米误差等常量值。当然也可直接指定一个浮点数作为定位服务允许的误差。</li></ul></li><li><p><code>activityType</code>设置定位数据的用途。该属性支持</p><ul><li><code>CLActivityTypeOther</code>定位数据作为普通用途、</li><li><code>CLActivityTypeAutomotiveNavigation</code>定位数据作为车辆导航使用、</li><li><code>CLActivityTypeFitness</code>定位数据作为步行导航使用</li><li><code>CLActivityTypeOtherNavigation</code>定位数据作为其他导航使用这几个枚举值之一。</li></ul></li></ul><h2 id="CLLocation对象中包含如下属性这些属性包含了定位相关信息。"><a href="#CLLocation对象中包含如下属性这些属性包含了定位相关信息。" class="headerlink" title="CLLocation对象中包含如下属性这些属性包含了定位相关信息。"></a>CLLocation对象中包含如下属性这些属性包含了定位相关信息。</h2><ul><li><code>altitude</code>该属性表示当前设备的海拔高度单位是米。</li><li><code>coordinate</code>该属性返回一个<code>CLLocationCoordinate2D</code>结构体变量该结构体变量中包含<em>经度</em>、<em>纬度</em>信息。</li><li><code>course</code>该属性表示当前设备前进的方向。该值为0°表示向北90°表示向东180°表示向南270°表示向西。</li><li><p><code>horizontalAccuracy</code>该属性表明定位信息的水平精确度。将返回的坐标作为圆心并将水平精确度视为半径。真正的设备位置落在此圆内的某处。此圆越小位置就越精确此圆越大则位置越不精确。如果精确度为负值则表明测量精确度失败。</p></li><li><p><code>verticalAccuracy</code>该属性表明定位信息的垂直精确度。也就是说iOS设备的实际高度在该定位信息的高度加或减该属性值的范围内。<br>timestamp该属性返回定位信息的返回时间。</p></li><li><code>speed</code>该属性表示返回设备的移动速度单位是米/秒。实际上该属性适用于行车速度而不太适用于步行速度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Location </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 入门</title>
      <link href="/2017/03/18/http/"/>
      <url>/2017/03/18/http/</url>
      
        <content type="html"><![CDATA[<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><h2 id="什么是URL"><a href="#什么是URL" class="headerlink" title="什么是URL"></a>什么是URL</h2><pre><code>* Uniform Resource Location（统一资源定位符）*  网络中每一个资源都对应一个地址--&gt; URL </code></pre><h2 id="URL的基本格式"><a href="#URL的基本格式" class="headerlink" title="URL的基本格式"></a>URL的基本格式</h2><pre><code>* 协议://主机地址:端口号/路径    * 协议 ： 不同协议代表不同的资源获取方式    * 主机地址：主机的唯一标识（IP地址，域名）    * 路径： 资源在主机中的具体位置</code></pre><h2 id="URL的常见协议"><a href="#URL的常见协议" class="headerlink" title="URL的常见协议"></a>URL的常见协议</h2><pre><code>* http ,FTP，Mailto,File,tel://,sms://</code></pre><h1 id="HTTP-协议简介"><a href="#HTTP-协议简介" class="headerlink" title="HTTP 协议简介"></a>HTTP 协议简介</h1><h2 id="什么是-http协议"><a href="#什么是-http协议" class="headerlink" title="什么是 http协议"></a>什么是 http协议</h2><pre><code>* HyperText TransportProtocol(超文本传输协议)* 浏览器和web服务器通讯时遵守的约定* 互联网使用最多的协议* 提供超文本传输协议* 通过浏览器打开网使用的http提供的服务。</code></pre><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IP-1"><a href="#IP-1" class="headerlink" title="IP"></a>IP</h2><ul><li>两个计算机通讯必须要知道的：<ul><li>IP地址和端口号</li></ul></li><li>IP地址<ul><li>IP地址是一个32位的二进制数，通常被分割为8位二进制数，通常用点分隔，10进制表示。<ul><li>192.168.1.1</li><li>127.0.0.1 回路地址 </li><li>255.255.255.255 广播</li><li>0.0.0.0 any </li></ul></li><li>唯一标识互联网上的一台计算机（IP地址不好记忆，所以有了域名）</li><li>一个计算机可能有多个可用IP地址，如两块网卡</li><li>内网的计算机，都通过路由器上网，它们对外的地址都是路由器的IP地址。</li></ul></li></ul><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="端口号-1"><a href="#端口号-1" class="headerlink" title="端口号"></a>端口号</h2><ul><li>标识进程（程序）的逻辑地址，不同进程（程序）的标识</li><li>端口取值范围 ： 0〜65535</li><li>端口的分类：<ul><li>公认端口（Well Know Ports）<ul><li>这类端口也常称之为“常用端口”。端口号从0到1024,它们紧密绑定一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。比如： http: 80 ,ftp:21,pop3:110,smtp:25</li></ul></li><li>注册端口（Registered Ports）<ul><li>端口号从1025到49151。分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好的公认端口的常用程序。</li></ul></li><li>动态和／或私有端口（Dynamic and/or Private Ports）<ul><li>端口号从49152到65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。   </li></ul></li></ul></li></ul><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h2><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层<h1 id="TCP／IP-网络模型"><a href="#TCP／IP-网络模型" class="headerlink" title="TCP／IP 网络模型"></a>TCP／IP 网络模型</h1></li><li><p>应用层</p><ul><li>对应OSI模型的前三层 ，为用户提供所需要的各种服务，例如 ： FTP，Telnet,DNS,SMTP,HTTP等</li></ul></li><li><p>传输层</p><ul><li>为应用层提供端到端的通信功能，保证了数据包的传输顺序及数据完整性。两个主要协议：TCP／UDP</li></ul></li><li>网络层<ul><li>解决主机到主机的通信问题。它所保护的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中和路由。该层有三个重要协议 ：网际协议（IP），互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）</li></ul></li><li>网络接入层<ul><li>负监视数据在主机和网络之间的交换。</li></ul></li></ul><h1 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h1><ul><li>TCP （传输控制协议）<ul><li>TCP 协议提供的是一种可靠的，通过“三次握手”来连接的数据传输服务</li></ul></li><li>UDP（用户数据报协议）<ul><li>UDP 协议提供的则是不保证可靠性，无连接的数据传输服务。</li></ul></li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><ul><li>两个计算机通讯的过程，就像两个人打电话一样</li><li>Socket<ul><li>Socket 又称“套接字”，应用程序通过“套接字”向网络发送请求或向网络做出应答</li><li>网络通信其实就是Socket之间的通信</li><li>数据在两个Socket之间通过I传输数据</li><li>Socket是纯C语言的，是跨平台的</li><li>HTTP协议是基于Socket的，HTTP协议的底层使用的就是Socket</li></ul></li></ul><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><ul><li>创建Socket</li><li>连接到服务器</li><li>发送数据到服务器</li><li>从服务器接收数据</li><li>关闭连接</li></ul><p><strong>socket对应于TCP／IP网络模型中的应用层和传输层之间</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> -http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keyboard_iOS</title>
      <link href="/2017/03/16/keyboard-iOS/"/>
      <url>/2017/03/16/keyboard-iOS/</url>
      
        <content type="html"><![CDATA[<h1 id="一-键盘通知"><a href="#一-键盘通知" class="headerlink" title="一. 键盘通知"></a>一. 键盘通知</h1><p>  当文本<code>View</code>(如<code>UITextField</code>,<code>UITextView</code>, <code>UIWebView</code>内的输入框)进入编辑模式成为first responder时，系统会自动显示键盘。成为firstresponder可能由用户点击触发，也可向文本View发送<code>becomeFirstResponder</code>消息触发。当文本视图退出first responder时，键盘会消失。文本View退出first responder可能由用户点击键盘上的Done或Return键结束输入触发，也可向文本View发送<code>resignFirstResponder</code>消息触发。<br>  当键盘显示或消失时，系统会发送相关的通知:</p><pre><code>1. UIKeyboardWillShowNotification2. UIKeyboardDidShowNotification3. UIKeyboardWillHideNotification4. UIKeyboardDidHideNotification</code></pre><p>  通知消息 <code>NSNotification</code>中的 userInfo字典中包含键盘的位置和大小信息，对应的key为</p><pre><code>1. UIKeyboardFrameBeginUserInfoKey2. UIKeyboardFrameEndUserInfoKey3. UIKeyboardAnimationDurationUserInfoKey4. UIKeyboardAnimationCurveUserInfoKey</code></pre><p>  <code>UIKeyboardFrameBeginUserInfoKey</code>,<code>UIKeyboardFrameEndUserInfoKey</code>对应的<code>Value</code>是个<code>NSValue</code>对象，内部包含<code>CGRect</code>结构，分别为 <strong>键盘起始时和终止时的位置信息</strong>。<br>  <code>UIKeyboardAnimationCurveUserInfoKey</code>对应的<code>Value</code>是<code>NSNumber</code>对象，内部为<code>UIViewAnimationCurve</code>类型的数据，表示键盘显示或消失的 <strong>动画类型</strong>。<br>  <code>UIKeyboardAnimationDurationUserInfoKey</code>对应的<code>Value</code>也是<code>NSNumber</code>对象，内部为<code>double</code>类型的数据，表示键盘显示或消失时动画的持续时间。</p><h1 id="文本对象与WebView键盘设置"><a href="#文本对象与WebView键盘设置" class="headerlink" title="文本对象与WebView键盘设置"></a>文本对象与WebView键盘设置</h1><p> <code>UITextFiled</code>和 <code>UITextView</code>都遵循 <code>[UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits#//apple_ref/occ/intfp/UITextInputTraits/returnKeyType)</code>协议，在<code>UITextInputTraits</code>协议中定义了设置键盘的属性，有</p><ol><li>keyboardType:键盘类型，如UIKeyboardTypeDefault,UIKeyboardTypeURL,UIKeyboardTypeEmailAddress,UIKeyboardTypePhonePad等</li><li>returnKeyType:键盘Return键显示的文本，默认为”Return”,其他可选择的包括Go,Next,Done,Send,Google等。</li><li>keyboardAppearance：键盘外观，默认为 UIKeyboardAppearanceDefault，即上图中的浅兰色不透明背景，另外还有一种为 UIKeyboardAppearanceAlert</li><li>autocapitalizationType:文本大小写样式，见 UITextAutocapitalizationType。</li><li>autocorrectionType:是否自动更正，见 UITextAutocorrectionType。</li><li>spellCheckingType:拼写检查设置，见UITextSpellCheckingType。</li><li>enablesReturnKeyAutomatically：是否在无文本时禁用Return键，默认为NO。若为YES,则用户至少输入一个字符后Return键才被激活。</li><li><p>secureTextEntry：若输入的是密码，可设置此类型为YES,输入字符时可显示最后一个字符，其他字符显示为点。</p><p>UIWebView本身不直接遵循 UITextInputTraits协议，但同样可设置其内部输入部件的键盘属性。如Configuring the Keyboard for Web Views中所述。<br>设置autocorrect, auto-capitalization属性。</p></li></ol><h1 id="使用inputAccessoryView与inputView定制输入视图"><a href="#使用inputAccessoryView与inputView定制输入视图" class="headerlink" title="使用inputAccessoryView与inputView定制输入视图"></a>使用inputAccessoryView与inputView定制输入视图</h1><p>  <code>inputAccessoryView</code>和 <code>inputView</code>属性在 <code>UIResponder</code>中定义，为<code>readonly</code>的属性，但在<code>UITextFiled</code>和 <code>UITextView</code>中重新定义为了·的属性，可以由用户赋值。若 inputView的不为nil,则当文本视图成为first responder时，不会显示系统键盘，而是显示自定义的<code>inputView</code>;若<code>inputAccessoryView</code>不为nil,则<code>inputAccessoryView</code>会显示在系统键盘或定制<code>inputView</code>的上方。当使用<code>inputView</code>时，仍然会有<code>WillShow</code>,<code>DidShow</code>,<code>WillHide</code>,<code>DidHide</code>的键盘通知，通知中的<code>BeginFrame</code>与<code>EndFrame</code>为系统键盘(或<code>inputView</code>)与<code>inputAccessoryView</code>一起的frame。</p><p>  在标准视图中只有<code>UITextField</code>和<code>UITextView</code>将<code>inputView</code>和<code>inputAccessoryView</code>重新定义为了<code>readwrite</code>类型，若想在自定义视图中使用，需要在自定义视图中重新定义<code>inputView</code>和<code>inputAccessoryView</code>属性。见 <a href="https://developer.apple.com/library/content/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/InputViews/InputViews.html#//apple_ref/doc/uid/TP40009542-CH12-SW2" target="_blank" rel="noopener">Input Views and Input Accessory Views</a>。</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>我们可以将键盘看成有两部分组成（当然，键盘还会有其他的部分组成），一部分是inputView，一部分是InputAccessoryView，并且，inputView在系统键盘的下面的部分，我们调用的系统默认键盘的时候，我们看到的部分就是这个InputView（输入视图），而这个InputAccessoryView就是键盘顶部的一个部分，当我Nil的时候则不显示，当我们给这个属性赋值的时候，就会显示这个我们添加的视图。</p><h1 id="键盘中的枚举"><a href="#键盘中的枚举" class="headerlink" title="键盘中的枚举"></a>键盘中的枚举</h1><h2 id="键盘风格"><a href="#键盘风格" class="headerlink" title="键盘风格"></a>键盘风格</h2><p>UIKit框架支持8种风格键盘。</p><pre><code class="objc">typedef enum {      UIKeyboardTypeDefault,                // 默认键盘：支持所有字符      UIKeyboardTypeASCIICapable,           // 支持ASCII的默认键盘      UIKeyboardTypeNumbersAndPunctuation,  // 标准电话键盘，支持+ * # 等符号      UIKeyboardTypeURL,                    // URL键盘，有.com按钮；只支持URL字符      UIKeyboardTypeNumberPad,              //数字键盘      UIKeyboardTypePhonePad,               // 电话键盘      UIKeyboardTypeNamePhonePad,           // 电话键盘，也支持输入人名字      UIKeyboardTypeEmailAddress,           // 用于输入电子邮件地址的键盘  } UIKeyboardType;  </code></pre><p>eg:<br><code>textView.keyboardtype = UIKeyboardTypeNumberPad;</code></p><h2 id="键盘外观"><a href="#键盘外观" class="headerlink" title="键盘外观"></a>键盘外观</h2><pre><code class="objc">typedef enum {      UIKeyboardAppearanceDefault,    // 默认外观：浅灰色      UIKeyboardAppearanceAlert,      //深灰/石墨色  } UIKeyboardAppearance;</code></pre><p>eg :<br><code>textView.keyboardAppearance=UIKeyboardAppearanceDefault;</code></p><h2 id="回车键"><a href="#回车键" class="headerlink" title="回车键"></a>回车键</h2><pre><code class="objc">typedef enum {      UIReturnKeyDefault,  //默认：灰色按钮，标有Return    UIReturnKeyGo,  //标有Go的蓝色按钮    UIReturnKeyGoogle,  //标有Google的蓝色按钮，用于搜索    UIReturnKeyJoin,  //标有Join的蓝色按钮    UIReturnKeyNext,  //标有Next的蓝色按钮    UIReturnKeyRoute,  //标有Route的蓝色按钮    UIReturnKeySearch,  //标有Search的蓝色按钮    UIReturnKeySend,  //标有Send的蓝色按钮    UIReturnKeyYahoo,  //标有Yahoo!的蓝色按钮，用于搜索    UIReturnKeyDone,  //标有Done的蓝色按钮    UIReturnKeyEmergencyCall,  //紧急呼叫按钮} UIReturnKeyType;</code></pre><p>eg:<br><code>textView.returnKeyType=UIReturnKeyGo;</code></p><h2 id="自动大写"><a href="#自动大写" class="headerlink" title="自动大写"></a>自动大写</h2><pre><code class="objc">typedef enum {      UITextAutocapitalizationTypeNone, //不自动大写      UITextAutocapitalizationTypeWords, //单词首字母大写      UITextAutocapitalizationTypeSentences, //句子首字母大写      UITextAutocapitalizationTypeAllCharacters, //所有字母大写  } UITextAutocapitalizationType;  </code></pre><p>eg:<br><code>textField.autocapitalizationType = UITextAutocapitalizationTypeWords;</code></p><h2 id="自动更正"><a href="#自动更正" class="headerlink" title="自动更正"></a>自动更正</h2><pre><code class="objc">typedef enum {      UITextAutocorrectionTypeDefault,//默认      UITextAutocorrectionTypeNo,//不自动更正      UITextAutocorrectionTypeYes,//自动更正  } UITextAutocorrectionType;</code></pre><p>eg:<br><code>textField.autocorrectionType = UITextAutocorrectionTypeYes;</code></p><h2 id="安全文本输入"><a href="#安全文本输入" class="headerlink" title="安全文本输入"></a>安全文本输入</h2><p><code>textView.secureTextEntry=YES;</code><br>开启安全输入主要是用于密码或一些私人数据的输入，此时会禁用自动更正和自此缓存。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 键盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoj</title>
      <link href="/2017/03/16/emoj/"/>
      <url>/2017/03/16/emoj/</url>
      
        <content type="html"><![CDATA[<p>iOS4.0以前emoji采用的是SoftBank的那套编码，叫做SB_Unicode, 而且iOS5时，emoji被放进了Unicode6.0, 此后iOS采用的是Unicode编码</p><p>ps: 字符显示程序的快捷键应该是 Control + Cmd + 空格键</p><p>emoji 的样式就是一个标准化变体序列的例子。许多 emoji 和一些「正常」的字符都有两种风格：一种是彩色的「emoji 风格」，另一种是黑白的，更像是符号的「文本风格」。例如，「有雨滴的伞」这个字符（U+2614）可能是这样：☔️ (U+2614 U+FE0F) ，也可能是这样的： ☔︎ (U+2614 U+FE0E)。</p><p>iOS中可用的表情unicode范围是：0xE001~0xE05A,0xE101~0xE15A, 0xE201~0xE253, 0xE401~0xE44C, 0xE501~0xE537</p><p>参考 <a href="https://www.objccn.io/issue-9-1/" target="_blank" rel="noopener">Unicode</a></p><p><a href="https://my.oschina.net/u/2340880/blog/529078" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动app测试中的基本要求</title>
      <link href="/2017/03/11/%E7%A7%BB%E5%8A%A8app%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82/"/>
      <url>/2017/03/11/%E7%A7%BB%E5%8A%A8app%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="移动app测试中的基本要求"><a href="#移动app测试中的基本要求" class="headerlink" title="移动app测试中的基本要求"></a>移动app测试中的基本要求</h1><p>对移动app测试必须解决的四大问题进行归纳总结：</p><h2 id="App测试问题一：用户体验"><a href="#App测试问题一：用户体验" class="headerlink" title="App测试问题一：用户体验"></a>App测试问题一：用户体验</h2><p>  用户体验是一个app成功与否的关键。App商店中app评分可以反映用户体验，差评说明销售亏损。所以用户体验在移动app测试中是一个重要问题。因为体验具有主观性，所以它无法直接被测出。但你要知道，我们在测试过程中，必须要从一些关键影响因素入手，去解决用户体验问题。</p><p>  而好的用户体验的成功因素包括吸引人的设计，积极的互动性和可用性。</p><p>  而针对这个问题，我们的测试要从真人体验测试、各个功能的深度测试以及Bug探索与崩溃分析这几个方面着重入手，才能够涵盖完善用户体验所需的测试点。</p><h2 id="APP测试问题二：app对于移动设备的兼容性"><a href="#APP测试问题二：app对于移动设备的兼容性" class="headerlink" title="APP测试问题二：app对于移动设备的兼容性"></a>APP测试问题二：app对于移动设备的兼容性</h2><p>  目前，安卓类的移动设备正在急剧增加，手机碎片化异常严重。并且因为显示屏大小和现状、操作系统版本和基本设备特点等限制因素的不一致，致使几乎没有开发者会花费大量金钱去购买市面上存在的主流手机，那么这些因素叠加起来，最终就很大程度上导致普通的质量管理很难进行。而如果不全面地进行兼容性测试，那么app的生存空间又在哪里呢？</p><p>  同时还有一点，设备制造商的（安卓）操作系统的设备特殊定制，应明确地在设备上进行测试。测试时，有必要限制将会被app支持的设备。必须要标明系统组合（硬件/操作系统）和向下兼容性。为了最大化系统组合的覆盖，就必须要有灵活的策略来与足够的机型来执行测试。</p><p>  兼容性问题当然是进行兼容性测试，而在所有的兼容性测试中，使用真机进行测试，是最好的测试方式。但由于上文已提及到众多企业无力购置大量机型，那么，这样的需求就只有委托给第三方的测试机构来完成</p><h2 id="APP测试问题三：app的网络连接情况"><a href="#APP测试问题三：app的网络连接情况" class="headerlink" title="APP测试问题三：app的网络连接情况"></a>APP测试问题三：app的网络连接情况</h2><p>  网络连接是移动app测试的另一大问题。理想状态下，app的网络连接将在单独的线程中实现，这样就不会彼此干扰。此外，一个app必须适当地应对网络中断、延迟、变更和信号弱等情况。如果说不能够将这些测试点进行到底，那么在app在运行过程中将很有可能出现由于网络问题而导致的app运行中断，如果这样的问题出现在金融或证券领域的app中，那么就很可能在当下环境中让用户无法完成挂单、卖出买入或者确认等操作，造成不可挽回的损失。</p><p>  对于网络问题，一般是进行模拟网络情况的测试，比如TestBird提供的弱网模拟测试和它们的中断测试</p><h2 id="APP测试问题四：服务器的承载能力测试"><a href="#APP测试问题四：服务器的承载能力测试" class="headerlink" title="APP测试问题四：服务器的承载能力测试"></a>APP测试问题四：服务器的承载能力测试</h2><p>  任何开发者都不能够拍胸脯确认自己的app能够获取多少用户，并且能够明确指出同时在线的用户能有多少，如果不关注服务器的承载能力，那么很可能在突然的情况下，服务器就被大量涌入的用户给冲爆，导致瘫痪。</p><p>  如此，用户自然会流失，同时服务器的宕机，也会给当时正在进行重要操作的用户造成损失，这样的情境，我们依然可以考虑到金融与证券的方向。</p><p>  服务器的压力测试已经是常见的测试项目了，但是进行全面、专业的压力测试才是保证明确需测服务器承载力的必要条件。</p><blockquote><p>移动app测试中必须考虑很的重要问题就是用户体验，可用移动硬件的覆盖，连接和服务器承载能力。一个移动app测试项目的质量标准是每个项目个体的汇总情况体现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIView中的坐标转换convertPoint </title>
      <link href="/2017/03/11/UIView%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2convertPoint/"/>
      <url>/2017/03/11/UIView%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2convertPoint/</url>
      
        <content type="html"><![CDATA[<p>UIView为我们提供了查找视图所在行的简洁方法,实现视图坐标系间的坐标转换：<br>-convertPoint:toView: 方法</p><p>常用转换方法</p><pre><code class="objc">// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;// 将rect从view中转换到当前视图中，返回在当前视图中的rect- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -坐标转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排列组合</title>
      <link href="/2017/03/10/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2017/03/10/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>#排列组合<br> 排列组合是组合学最基本的概念。所谓 <strong>排列</strong>，就是指从给定个数的元素中取出指定个数的元素进行排序。<br> <strong>组合</strong> 则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p> 排列的定义：从n个不同元素中，任取m(m≤n,m与n均为自然数,下同）个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列；从n个不同元素中取出m(m≤n）个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，用符号 A(n,m）表示。<br>  计算公式： <img src="http://c.hiphotos.baidu.com/baike/s%3D257/sign=97158a763df33a879a6d071ff15d1018/2e2eb9389b504fc2974eb943e2dde71190ef6d66.jpg" alt="计算公式">  </p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>  组合的定义：从n个不同元素中，任取m(m≤n）个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n）个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。用符号 C(n,m) 表示。<br>  计算公式： <img src="http://d.hiphotos.baidu.com/baike/s%3D162/sign=f68c65f4b5b7d0a27fc9009bf9ee760d/5d6034a85edf8db190ab75220e23dd54574e74ea.jpg" alt="公式"><br>C(n,m)=C(n,n-m）。（n≥m)</p><p>#符号<br>  C-Combination 组合数[2]<br>  A-Arrangement 排列数（在旧教材为P-Permutation）<br>  N-元素的总个数<br>  M-参与选择的元素个数<br>  ！-阶乘</p><h1 id="基本计数原理"><a href="#基本计数原理" class="headerlink" title="基本计数原理"></a>基本计数原理</h1><ol><li><p>加法原理和分类计数法</p><ul><li>加法原理：做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有m2种不同的方法，……，在第n类办法中有mn种不同的方法，那么完成这件事共有N=m1+m2+m3+…+mn种不同方法。</li><li>第一类办法的方法属于集合A1，第二类办法的方法属于集合A2，……，第n类办法的方法属于集合An，那么完成这件事的方法属于集合A1UA2U…UAn。</li><li>分类的要求 ：每一类中的每一种方法都可以独立地完成此任务；两类不同办法中的具体方法，互不相同（即分类不重）；完成此任务的任何一种方法，都属于某一类（即分类不漏）。</li></ul></li><li><p>乘法原理和分步计数法</p><ol><li>乘法原理：做一件事，完成它需要分成n个步骤，做第一步有m1种不同的方法，做第二步有m2种不同的方法，……，做第n步有mn种不同的方法，那么完成这件事共有N=m1×m2×m3×…×mn种不同的方法。</li><li>合理分步的要求<br>任何一步的一种方法都不能完成此任务，必须且只须连续完成这n步才能完成此任务；各步计数相互独立；只要有一步中所采取的方法不同，则对应的完成此事的方法也不同。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 取整方式</title>
      <link href="/2017/03/10/iOS-%E5%8F%96%E6%95%B4%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/03/10/iOS-%E5%8F%96%E6%95%B4%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong><em>ios的向上，向下以及四舍五入的取整方式</em></strong></p><pre><code class="swift">import UIKit/**凑整*/ceil(2)//2ceil(2.3)//3ceil(2.5)//3ceil(2.8)//3ceil(-2.1)//-2ceil(-2.9)//-2/**四舍五入取整*///rint(2)//2rint(2.1)//2rint(2.2)//2rint(2.5)//2rint(2.6)//3rint(2.9)//3rint(-2.1)//-2rint(-2.5)//-2rint(-2.8)//-3/**舍掉小数取整*/floor(2.1)//2floor(2)//2floor(2.5)//2floor(2.9)//2floor(-2)//-2floor(-2.3)//-3floor(-2.9)//-3/**四舍五入*/round(2.1)//2round(2.5)//3round(2.8)//3round(-2.1)//-2round(-2.5)//-3round(-2.9)//-3/** floor向下取整，ceil向上取整；round和rint四舍五入，取绝对值后舍入，然后加上符号，遇到.5的时候向绝对值小的方向舍之 */</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数值取整 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoLayout</title>
      <link href="/2017/03/08/AutoLayout/"/>
      <url>/2017/03/08/AutoLayout/</url>
      
        <content type="html"><![CDATA[<p>一.名词解析<br><strong>intrinsicContentSize</strong>：字面意思就是固有的大小。就是说在没有受到约束影响时本来应该有的大小。<br><strong>Content Hugging Priority</strong>：字面意识是内容压缩优先级。就是说阻止view返回的实际尺寸比intrinsicContentSize大的优先级。<br><strong>Content Compression Resistance Priority</strong>：字面意思就是内容抗压缩优先级。就是说阻止View返回的实际尺寸比intrinsicContentSize小的优先级。</p><h2 id="intrinsicContentSize-内在内容大小"><a href="#intrinsicContentSize-内在内容大小" class="headerlink" title="intrinsicContentSize 内在内容大小"></a>intrinsicContentSize 内在内容大小</h2><p>使用AutoLayout 时，视图内容的大小通过每个视图的 intrinsicContentSize 属性表达，它描述了在数据未经压缩或剪裁的情况下表达视图全部内容所需的最小空间。该属性源于每个视图所呈现内容的自然属性。</p><p>对于图像视图，内在内容大小与其呈现的图像大小相符。图像越大，需要的内容大小也越大。<br>对于按钮，内在内容的大小随着按钮的名称而变化（title）。</p><p>通过视图的内在内容大小，Auto Layout将视图框架尽可能地与其自然内容相匹配。无歧义的布局通常需要给每个坐标轴设置两个属性，当视图有一个内在内容大小时，则只需设置两个属性中的一个。</p><p>当改变了视图的内在内容时，需要调用 invalidateIntrinsicContentSize 方法，让AutoLayout 知道在下次布局时重新计算。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>constellation</title>
      <link href="/2017/03/08/constellation/"/>
      <url>/2017/03/08/constellation/</url>
      
        <content type="html"><![CDATA[<pre><code class="objc">- (NSString *) astrology {    NSString *astroString = @&quot;魔羯水瓶双鱼白羊金牛双子巨蟹狮子处女天秤天蝎射手魔羯&quot;;    NSString *astroFormat = @&quot;102123444543&quot;;    NSString *result;    NSDateComponents *components = [[NSCalendar currentCalendar] components:NSCalendarUnitDay | NSCalendarUnitMonth | NSCalendarUnitYear fromDate:self];    long m = [components month];    long d = [components day];    result = [NSString stringWithFormat:@&quot;%@座&quot;,[astroString substringWithRange:NSMakeRange(m * 2-(d &lt; [[astroFormat substringWithRange:NSMakeRange((m-1), 1)] intValue] - (-19)) * 2,2)]];    return result;}</code></pre><pre><code class="objc">/** *  根据月和日的下标获取星座名 * *  @param monthIndex 月的下标 *  @param dayIndex   日的下标 * *  @return 星座名 */- (NSString *)getConstellationNameByMonthIndex:(NSInteger)monthIndex dayIndex:(NSInteger)dayIndex {    NSArray *constellations = @[@&quot;水瓶座&quot;, @&quot;双鱼座&quot;, @&quot;白羊座&quot;, @&quot;金牛座&quot;, @&quot;双子座&quot;, @&quot;巨蟹座&quot;, @&quot;狮子座&quot;, @&quot;处女座&quot;, @&quot;天秤座&quot;, @&quot;天蝎座&quot;, @&quot;射手座&quot;, @&quot;摩羯座&quot;];    NSInteger index;    NSArray *conIndexs = @[@(20),@(19),@(21),@(20),@(21),@(22),@(23),@(23),@(23),@(24),@(23),@(22)];    if ([[conIndexs objectAtIndex:monthIndex] integerValue] &lt;= dayIndex + 1) {        index = monthIndex;    } else index = (monthIndex - 1 + 12) % 12;    return [constellations objectAtIndex:index];}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pod command</title>
      <link href="/2017/03/07/pod-command/"/>
      <url>/2017/03/07/pod-command/</url>
      
        <content type="html"><![CDATA[<h1 id="pod-基础使用命令"><a href="#pod-基础使用命令" class="headerlink" title="pod 基础使用命令"></a>pod 基础使用命令</h1><ol><li>创建Podfile文件<pre><code class="sh"> pod init</code></pre></li><li>使用命令打开Podfile文件<pre><code class="sh">open -a Xcode Podfile</code></pre></li><li>搜索pod 库<pre><code class="sh">pod search 库名</code></pre></li><li>更新本地Repo库<pre><code class="sh">pod repo update</code></pre></li><li><p>安装pod 库</p><pre><code class="sh">pod installpod install --verbose --no-repo-update</code></pre></li><li><p>升级pod 库</p><pre><code class="sh">pod updatepod upadte --verbose --no-repo-update</code></pre><a id="more"></a></li></ol><h1 id="cocoapods库安装命令"><a href="#cocoapods库安装命令" class="headerlink" title="cocoapods库安装命令"></a>cocoapods库安装命令</h1><ul><li><p>检查ruby源</p><pre><code class="sh">gem sources -l</code></pre></li><li><p>删除原有ruby源</p><pre><code class="sh">gem sources -remove https://rubygems.org/</code></pre></li><li><p>添加你找到的可用镜像源</p><pre><code class="sh">gem sources -a http://rubygems-china.oss.aliyuncs.com</code></pre></li><li>安装cocoapods<pre><code class="sh">sudo gem install cocoapodspod  setup</code></pre></li><li><p>查看cocoapods当前版本号</p><pre><code class="sh">pod --version</code></pre></li><li><p>更新gem到最新版本</p><pre><code class="sh">sudo gem update --system</code></pre></li><li><p>更新cocoapods版本<br><code>`</code>sh<br>sudo gem update cocoapods</p></li></ul><pre><code># 查看已安装的cocoapods库&gt;说明Cocoapods在将它的信息下载到 ~/.cocoapods里；&gt;cd 到该目录里14. 查看 repo list```shpod repo list</code></pre><ol start="15"><li>查看文件大小<pre><code class="sh">du -sh</code></pre></li><li>查看安装列表<pre><code class="sh">pod list</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> cocoapods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/2017/02/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/02/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>函数式编程思想</strong>： 把操作尽量写成一系例嵌套的函数或者方法调用。</p><p><strong>函数式编程本质</strong>： 就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</p><p><strong>函数式编程特点</strong>： 每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p><h2 id="代表：ReactiveCocoa。"><a href="#代表：ReactiveCocoa。" class="headerlink" title="代表：ReactiveCocoa。"></a><strong>代表</strong>：ReactiveCocoa。</h2><p><strong>链式编程思想</strong>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p><p><strong>链式编程特点</strong>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p><h2 id="代表：Masonry框架。"><a href="#代表：Masonry框架。" class="headerlink" title="代表：Masonry框架。"></a><strong>代表</strong>：Masonry框架。</h2><p>##ReactiveCocoa常见类</p><blockquote><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类<code>RACSiganl</code>,搞定这个类就能用ReactiveCocoa开发了。</p></blockquote><ol><li><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</li></ol><blockquote><p>注意：</p></blockquote><blockquote><ol><li>信号类(<code>RACSiganl</code>)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</li></ol></blockquote><blockquote><ol start="2"><li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li></ol></blockquote><blockquote><ol start="3"><li>如何订阅信号：调用信号<code>RACSignal</code>的<code>subscribeNext</code>就能订阅</li></ol></blockquote><ol start="2"><li><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。<br><code>`</code>objc<br>-(void)createSimpleSignal{<br>// RACSignal使用步骤：<br>// 1.创建信号 + (RACSignal <em> )createSignal:(RACDisposable </em> (^)(id<racsubscriber> subscriber))didSubscribe<br>// 2.订阅信号,才会激活信号. - (RACDisposable * )subscribeNext:(void (^)(id x))nextBlock<br>// 3.发送信号 - (void)sendNext:(id)value</racsubscriber></li></ol><p>  // RACSignal底层实现：<br>  // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。<br>  // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock<br>  // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。<br>  // 2.1 subscribeNext内部会调用siganl的didSubscribe<br>  // 3.siganl的didSubscribe中调用[subscriber sendNext:@1];<br>  // 3.1 sendNext底层其实就是执行subscriber的nextBlock</p><p>  //    1.创建信息<br>  RACSignal <em> signal =  [RACSignal createSignal:^RACDisposable </em> _Nullable(id<racsubscriber>   subscriber) {<br>    // block调用时刻：每当有订阅者订阅信号，就会调用block。<br>    //        2.发送信号<br>    [subscriber sendNext:@1];<br>    // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</racsubscriber></p><pre><code>[subscriber sendCompleted];return [RACDisposable disposableWithBlock:^{  // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。  // 执行完Block后，当前信号就不在被订阅了。  NSLog(@&quot;信号销毁了&quot;);}];</code></pre><p>  }];<br>  //    3. 订阅信号，才会激活信号<br>  [signal subscribeNext:^(id   x) {<br>     // block调用时刻：每当有信号发出数据，就会调用block.<br>   NSLog(@”接收到数据：%@”,x);<br>  }];<br>}</p><pre><code>3. `RACDisposable`:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。**使用场景**: 不想监听某个信号时，可以通过它主动取消订阅信号。4. `RACSubject`: 信号提供者，自己可以充当信号，又能发送信号。**使用场景**： 通常用来代替代理，有了它，就不必要使用代理了1. `RACReplaySubject`:重复提供信号类，`RACSubject`的子类。&gt; `RACReplaySubject`可以先发送信号，在订阅信号，`RACSubject`就不可以**使用场景一**:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。**使用场景二**:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。```objc-(void)createRACSubject{  // RACSubject使用步骤  // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。  // 2.订阅信号 - (RACDisposable * ) subscribeNext:(void (^)(id x))nextBlock  // 3.发送信号 sendNext:(id)value  // RACSubject:底层实现和RACSignal不一样。  // 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。  // 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock  //1. 创建信号  RACSubject * subject = [RACSubject subject];  //2.订阅信号  [subject subscribeNext:^(id   x) {    // block调用时刻：当信号发出新值，就会调用.    NSLog(@&quot;第一个订阅都:%@&quot;,x);  }];  [subject subscribeNext:^(id   x) {    // block调用时刻：当信号发出新值，就会调用.    NSLog(@&quot;第二个订阅都:%@&quot;,x);  }];  //3. 发送信息  [subject sendNext:@&quot;1&quot;];}</code></pre><pre><code class="objc">-(void)createReplaySubject{  // RACReplaySubject使用步骤:  // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。  // 2.可以先订阅信号，也可以先发送信号。  // 2.1 订阅信号 - (RACDisposable * )subscribeNext:(void (^)(id x))nextBlock  // 2.2 发送信号 sendNext:(id)value  // RACReplaySubject:底层实现和RACSubject不一样。  // 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。  // 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock  // 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。  // 也就是先保存值，在订阅值。  //    1.创建信号  RACReplaySubject * replaySuject = [RACReplaySubject subject];  //    2. 发送信号  [replaySuject sendNext:@1];  [replaySuject sendNext:@2];  //    3.订阅信号  [replaySuject subscribeNext:^(id   x) {    NSLog(@&quot;第一个订阅者接收到的数据%@&quot;,x);  }];  [replaySuject subscribeNext:^(id   x) {    NSLog(@&quot; 第二个订阅者接收到的数据%@&quot;,x);  }];}</code></pre><ol start="5"><li><p><code>RACTuple</code>:元组类,类似<code>NSArray</code>,用来包装值.</p></li><li><p><code>RACSequence</code>:RAC中的集合类，用于代替<code>NSArray</code>,<code>NSDictionary</code>,可以使用它来快速遍历数组和字典。<br><code>`</code>objc<br>-( void )RACIterator{<br> // 1.遍历数组<br> NSArray * numbers = @[@1,@3,@4];<br> // 这里其实是三步<br> // 第一步: 把数组转换成集合RACSequence numbers.rac_sequence<br> // 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal<br> // 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。<br> [numbers.rac_sequence.signal subscribeNext:^(id   x) {</p><pre><code> NSLog(@&quot;%@&quot;,x);</code></pre><p> }];</p><p> // 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)<br> NSDictionary <em> dict = @{@”name”:@”yuanph”,@”age”:@18,@”country”:@”china”};<br> [dict.rac_sequence.signal subscribeNext:^(RACTuple </em>  x) {</p><pre><code> // 解包元组，会把元组的值，按顺序给参数里面的变量赋值 RACTupleUnpack(NSString * key,NSString * value)= x; NSLog(@&quot;%@:%@&quot;,key,value);</code></pre><p> }];<br>}</p></li></ol><p><code>`</code></p><ol start="7"><li><code>RACCommand</code>:<code>RAC</code>中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程<br> <strong>使用场景</strong>:监听按钮点击，网络请求</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UITest 学习笔记</title>
      <link href="/2017/02/27/UITest/"/>
      <url>/2017/02/27/UITest/</url>
      
        <content type="html"><![CDATA[<h2 id="UITest是什么？"><a href="#UITest是什么？" class="headerlink" title="UITest是什么？"></a>UITest是什么？</h2><p>UITest 是一个自动测试UI与交互的Testing组件</p><h2 id="UITest有什么作用？"><a href="#UITest有什么作用？" class="headerlink" title="UITest有什么作用？"></a>UITest有什么作用？</h2><p>它可以通过代编写代码／记录开发者的操作过程并代码化，来实现自动点击某个按钮／视图／自动输入文字等功能</p><h2 id="UI-Test-的重要性"><a href="#UI-Test-的重要性" class="headerlink" title="UI Test 的重要性"></a>UI Test 的重要性</h2><p> 在实际开发过程中，随着项目越做越大，功能越来越多，仅仅靠人功操作的方式来覆盖所有测试用修饰是非常困难的，尤其是加入新功能以后，旧的功能也要重新测试，这导致测试需要花非常多的时间来进行回规性测试。这里产生了大量的重复工作，而这些工作完全可以自动完成。这时UITest就可以帮助解决这个问题。</p><h2 id="XCTest-工具"><a href="#XCTest-工具" class="headerlink" title="XCTest 工具"></a>XCTest 工具</h2><p> XCTest 一共提供了3种UI测试对象</p><ul><li>XCUIApplication 当前测试应用target</li><li>XCUIElementQuery 定位查询当前UI中XCUIElement的一个类</li><li>XCUIElement UI测试中任何一个item项都被抽象成一个XCUIElement类型</li></ul><h3 id="XCUIApplication"><a href="#XCUIApplication" class="headerlink" title="XCUIApplication"></a>XCUIApplication</h3><p> XCUIApplication类是Application的代理，就像我们项目工程中的AppDelegate，这个对象用来启动或者是终止UI测试程序，还可以在启动的时候设置一些启动参数，在获取程序中的UI元素的时候，就是通过这个类的实例。这个类继承自XCUIElement类</p><h3 id="XCUIElement"><a href="#XCUIElement" class="headerlink" title="XCUIElement"></a>XCUIElement</h3><p> XCUIElement类是XCTest.framework对应用中的所有UI 控件的抽象，在UI测试中，没有UIKit中的UI类型，只是用这个类的实例表示所有的UI 控件，以及相应的交互方法，例如：执行手势（tap，press，swipe），滑动控件交互，拾取器交互，这个类采取了 XCUIElementAttributes协议（描述UI元素的属性：Identity，Value，Interaction State，Size），XCUIElementTypeQueryProvider协议(为指定类型的子代元素提供ready-made查询， 子代元素查询包含button，具体实现是:@property(readonly, copy) XCUIElementQuery *buttons; 等一系列对UIKit中元素的映射)</p><h3 id="XCUIElementQuery"><a href="#XCUIElementQuery" class="headerlink" title="XCUIElementQuery"></a>XCUIElementQuery</h3><p>XCUIElementQuery类是定位UI 元素的查询，这个类使用类似key-value的机制得到XCUIElement的实例，使用Type(XCUIElementType枚举)，Predicate， Identifier创建query，使用elementAtIndex:, elementMatchingPredicate,elementMatchingType: identifier:方法访问匹配到的UI元素，此类采用XCUIElementTypeQueryProvider协议</p><h2 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h2><p>为了让UI Testing能够工作，框架需要能够访问UI中的各个元素，这样才能执行它们的动作。你可以定义测试要在哪个特定的点进行点击和轻扫，但是这在不同屏幕大小的设备上就不那么好使了，又或者你换算出UI中元素在不同设备上的位置。</p><p>这时候accessibility就派上用场了。Accessibility是Apple很早之前构建的一个框架，它能帮助一些行动不便的用户来更好地使用你的应用。它为你的UI提供了丰富的语义数据，这能让不同的Accessibility功能给行动不便的用户展现你的应用。有很多功能都是现成的，直接就能在你的应用中使用，但是你可以（也应该）使用Accessibility的API来改进Accessibility关于UI的数据。在很多场景下这都是必需的，比如对一些自定义的控件，Accessibility就不清楚你的API要做什么。</p><p>UI Testing可以通过你的应用提供的Accessibility功能来与你的应用连接，这样就解决了设备大小不一的问题。如果你重新调整了UI中的某些元素，你也不用重写整套测试。实现Accessibility不仅是为了使用UI Testing，也能帮助行动不便的用户更好地使用你的应用</p><h2 id="UI-Recording"><a href="#UI-Recording" class="headerlink" title="UI Recording"></a>UI Recording</h2><p>当设置好可以访问的UI之后，你可能就想创建一些UI测试了。编写UI测试耗时又无聊，如果你的UI比较复杂，那这还有些难度。多亏在Xcode 7中，Apple引入了UI Recording，它能让你创建新的测试，并扩展原有的测试。当UI Recording打开之后，当你在真机或模拟器上与应用交互时，代码会自动生成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UITest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode8 新增扩展</title>
      <link href="/2017/02/14/Xcode8-%E6%96%B0%E5%A2%9E%E6%89%A9%E5%B1%95/"/>
      <url>/2017/02/14/Xcode8-%E6%96%B0%E5%A2%9E%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<ol><li>Xcode8 中新增文档注释功能<br>实现方法：option+cmd+/<pre><code class="swift">/// 创建一个图片视图let imageview = UIImageView(image: #imageLiteral(resourceName: &quot;friend&quot;))</code></pre></li><li>新增颜色选择器<br>实现方法: color+回车<pre><code class="swift">//color+回车v.backgroundColor=#colorLiteral(red: 0.5568627715, green: 0.3529411852, blue: 0.9686274529, alpha: 1)</code></pre><img src="http://7xw3wp.com1.z0.glb.clouddn.com/swift_select_color.png" alt="颜色选择">  </li><li>Xcode8中取消预编译指令,原来的#pragma mark替换为//MARK:<br>实现方法: //MARK: -<br><code>`</code>swift<br>//MARK: - 设置图片的frame<br>img.frame = CGRect(x: 0, y: 0, width: 200, height: 100)</li></ol><p>//MARK: 设置图片的center<br>img.center = view.center</p><pre><code>4. 原来的#warning也相应的替换成 //TODO: 和//FIXME:```swift        //color+回车      v.backgroundColor=#colorLiteral(red: 0.5568627715, green: 0.3529411852, blue: 0.9686274529, alpha: 1) //TODO: 设置需要的颜色    view.addSubview(v)        /// 创建一个图片视图    let imageview = UIImageView(image: #imageLiteral(resourceName: &quot;friend&quot;)) //FIXME: 设置对应的图像</code></pre><ol start="5"><li>图片展示<br><img src="http://7xw3wp.com1.z0.glb.clouddn.com/swift_image_select.png" alt="图片预览"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Xcode8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS常用小技巧</title>
      <link href="/2016/12/20/%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2016/12/20/%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>去除字符串首尾空格<pre><code class="objc">//可以指定字符集[text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</code></pre>常用字符集：<pre><code class="objc">@property (readonly, class, copy) NSCharacterSet *controlCharacterSet; //控制符@property (readonly, class, copy) NSCharacterSet *whitespaceCharacterSet;//空格@property (readonly, class, copy) NSCharacterSet *whitespaceAndNewlineCharacterSet;//空格和换行@property (readonly, class, copy) NSCharacterSet *decimalDigitCharacterSet;//数字@property (readonly, class, copy) NSCharacterSet *letterCharacterSet;//字母@property (readonly, class, copy) NSCharacterSet *lowercaseLetterCharacterSet;//小写字母@property (readonly, class, copy) NSCharacterSet *uppercaseLetterCharacterSet;//大写字母@property (readonly, class, copy) NSCharacterSet *nonBaseCharacterSet;//不知道@property (readonly, class, copy) NSCharacterSet *alphanumericCharacterSet;//字母数字@property (readonly, class, copy) NSCharacterSet *decomposableCharacterSet;//可分解字符集@property (readonly, class, copy) NSCharacterSet *illegalCharacterSet;//非法字符@property (readonly, class, copy) NSCharacterSet *punctuationCharacterSet;//标点符号@property (readonly, class, copy) NSCharacterSet *capitalizedLetterCharacterSet;//大写字符@property (readonly, class, copy) NSCharacterSet *symbolCharacterSet;//符号@property (readonly, class, copy) NSCharacterSet *newlineCharacterSet NS_AVAILABLE(10_5, 2_0);//换行符</code></pre></li></ol><ol start="2"><li><p>修改导航栏返回按钮</p><ul><li><p>自定义返回按钮</p><pre><code class="objc">UIImage * backButtonImage = [[UIImage imageNamed:@&quot;back_bg&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 30, 0, 0)];[[UIBarButtonItem appearance] setBackButtonBackgroundImage:backButtonImage forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];</code></pre></li><li><p>将返回按钮的文字position设置不在屏幕上显示</p><pre><code class="objc">[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(NSIntegerMin, NSIntegerMin) forBarMetrics:UIBarMetricsDefault];</code></pre></li><li><p>用系统的返回按钮的时候 会发现显示的是蓝色的，想要改变成白色的添加下面一句话</p><pre><code class="objc">[[UINavigationBar appearance]setTintColor:[UIColor whiteColor]];</code></pre></li><li>去除导航栏的黑色分隔线<br><code>`</code>objc<br>//    去除导航栏的黑色分隔线<br>[self.navigationController.navigationBar setBackgroundImage:[UIImage imageWithColor:[UIColor whiteColor]] forBarMetrics:UIBarMetricsDefault];<br>self.navigationController.navigationBar.shadowImage = [UIImage imageWithColor:[UIColor clearColor]];</li></ul></li></ol><pre><code>3. 给UITextView设置placehold ```objcUILabel *placeHolderLabel = [[UILabel alloc] init];placeHolderLabel.text = NSLocalizedString(@&quot;edit_signature_alert&quot;, nil);placeHolderLabel.numberOfLines = 0;placeHolderLabel.textColor = UIColorFromRGBA(0xb4b4b4, 1);[placeHolderLabel sizeToFit];placeHolderLabel.textAlignment= NSTextAlignmentLeft;[self.textView addSubview:placeHolderLabel];// same fontplaceHolderLabel.font = [UIFont systemFontOfSize:16.f];[self.textView setValue:placeHolderLabel forKey:@&quot;_placeholderLabel&quot;];</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UITextField</title>
      <link href="/2016/11/22/UITextField/"/>
      <url>/2016/11/22/UITextField/</url>
      
        <content type="html"><![CDATA[<p>思路：<br>使用runtime 获取textfiled的所有属性</p><pre><code class="objc">//获取类的所有属性unsigned int count = 0;Ivar *ivarList = class_copyIvarList([UITextField class], &amp;count);for (int i = 0; i&lt;count; i++) {    Ivar ivar = ivarList[i];    NSLog(@&quot;%s&quot;,ivar_getName(ivar));}free(ivarList);</code></pre><p>修改文本框内的placehold字体颜色</p><ol><li><p>使用runtime // 利用KVC设置它颜色,结果成功 这里有一个问题，可能会出现低版本没有该属性，你需要进行检验下。</p><pre><code class="objc">[textField setValue:[UIColor redColor]forKeyPath:@&quot;_placeholderLabel.textColor&quot;];  [textField setValue: [UIFontboldSystemFontOfSize:16] forKeyPath :@&quot;_placeholderLabel.font&quot;];  </code></pre></li><li><p>设置属性文本</p><pre><code class="objc">NSMutableDictionary *dict = [NSMutableDictionary dictionary];dict[NSForegroundColorAttributeName] = [UIColor redColor];NSAttributedString *attribute = [[NSAttributedString alloc] initWithString:self.placeholder attributes:dict];[self setAttributedPlaceholder:attribute];</code></pre></li><li>设置光标颜色<br>使用<code>@property(null_resettable, nonatomic, strong) UIColor *tintColor</code>属性<pre><code class="objc">textField.tintColor = UIColorFromRGBA(rgbValue,A) </code></pre></li><li>捕捉键盘的return事件<br>遵守UITextFieldDelegate,并设置相关代理。实现如下代理方法<br><code>`</code>objc</li></ol><ul><li>(BOOL)textFieldShouldReturn:(UITextField *)textField;<br>// called when ‘return’ key pressed. return NO to ignore.<br><code>`</code></li></ul><ol start="5"><li>捕捉文本改变事件通知<br>要想获取到文本改变事件通知，需要监听一个通知 <code>UITextFieldTextDidChangeNotification</code><br><code>`</code>objc<br>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFiledDidChange:) name:UITextFieldTextDidChangeNotification object:<code>文本框对象</code>];</li></ol><pre><code>&gt; PS: 文本常用通知```objcUIKIT_EXTERN NSNotificationName const UITextFieldTextDidBeginEditingNotification; //输入框已经开始编辑UIKIT_EXTERN NSNotificationName const UITextFieldTextDidEndEditingNotification;         //输入框已经结束编辑UIKIT_EXTERN NSNotificationName const UITextFieldTextDidChangeNotification;         //输入框已经改变</code></pre><ol start="6"><li>限制文本字数<br>监听<code>UITextFieldTextDidChangeNotification</code>通知，并在方法里做如下操作。下面是我的一个代码片段。</li></ol><pre><code class="objc">#pragma mark - 文本改变通知-(void)textFiledDidChange:(NSNotification*)textChange{    UITextField * field = (UITextField*)textChange.object;    NSString * toBeString = field.text;    UITextRange  * selectedRange =  [field markedTextRange];    UITextPosition* position = [field positionFromPosition:selectedRange.start offset:0];    if (!position) {        //判断文本字符数是否操作最大值        if (toBeString.length&gt;30) {            NSRange  rangeIndex = [toBeString rangeOfComposedCharacterSequenceAtIndex:30];            if (rangeIndex.length==1) {                field.text = [toBeString substringToIndex:30];            }else{                NSRange range = [toBeString rangeOfComposedCharacterSequencesForRange:NSMakeRange(0, 30)];                field.text = [toBeString substringWithRange:range];            }        }        if (toBeString.length==0) {            //没有输入文本处理            _characterNumber.text=[NSString stringWithFormat:@&quot;%d/30&quot;,(int)field.text.length];            [_remark_textfield showUnderLine:UIColorFromRGBA(0xb4b4b4, 1)];            _remark_OK.enabled=NO;        }else{            // 有文本处理            _characterNumber.text=[NSString stringWithFormat:@&quot;%d/30&quot;,(int)field.text.length];            [_remark_textfield showUnderLine:UIColorFromRGBA(0xe62f17, 1)];            if ([CheckInputValid CheckForNicknameWithInString:field.text]) {                _remark_OK.enabled=YES;            }else{                _remark_OK.enabled=NO;            }        }    }}</code></pre><ol start="7"><li><p>个性化定制文本框右边的视图( <code>rightView</code>)<br><code>`</code>objc</p><p> // 初始化一个视图（可以是任一视图（UILabel,UIButton,…）），Ps 需要指定一个框高  ,你可以对这个视图添加你想要的事件<br> _characterNumber = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 50, 30)];<br> _characterNumber.text = @”0/30”;<br> _characterNumber.textAlignment = NSTextAlignmentRight;<br> _characterNumber.font = [UIFont systemFontOfSize:12];<br> _characterNumber.textColor = UIColorFromRGBA(0xb4b4b4, 1);</p><p> // 设置右边视图<br> _remark_textfield.rightView = _characterNumber;</p><p> // 设置右边视图的显示模式<br> _remark_textfield.rightViewMode = UITextFieldViewModeAlways;</p></li></ol><pre><code>8. 当键盘出现时，需要改变输入框的位置，要如何做？  要想实现这个，很简单，同样你需要监听`UIKeyboardDidChangeFrameNotification`这个通知。```objc[[NSNotificationCenter defaultCenter ]addObserver:self selector:@selector(keyBoardFrameChanged:) name:UIKeyboardDidChangeFrameNotification object:nil];-(void)keyBoardFrameChanged:( NSNotification * )notification{    NSDictionary * userInfo = [notification userInfo];    NSValue * value = [userInfo objectForKey:UIKeyboardFrameEndUserInfoKey];    // 获取到键盘的位置    CGRect keyboardRect =  [value CGRectValue];    CGFloat keyboardTop = keyboardRect.origin.y;    //进行你的想要的布局操作}</code></pre><blockquote><p>PS：常见的键盘通知<br> <code>`</code>objc<br>    UIKIT_EXTERN NSNotificationName const UIKeyboardWillChangeFrameNotification  NS_AVAILABLE_IOS(5_0) <strong>TVOS_PROHIBITED; //键盘将要改变通知<br>    UIKIT_EXTERN NSNotificationName const UIKeyboardDidChangeFrameNotification   NS_AVAILABLE_IOS(5_0) </strong>TVOS_PROHIBITED; //键盘已经改变通知</p></blockquote><pre><code>UIKIT_EXTERN NSNotificationName const UIKeyboardWillShowNotification __TVOS_PROHIBITED; //键盘将要显示通知UIKIT_EXTERN NSNotificationName const UIKeyboardDidShowNotification __TVOS_PROHIBITED;  //键盘已经显示UIKIT_EXTERN NSNotificationName const UIKeyboardWillHideNotification __TVOS_PROHIBITED; //键盘将要隐藏UIKIT_EXTERN NSNotificationName const UIKeyboardDidHideNotification __TVOS_PROHIBITED;  //键盘已经隐藏</code></pre><pre><code>9. 给文本框加上一根横线对于这个，你可以给做一个子类，继承自UITextFiled. 重写drawRect方法如下所示```objc@interface TextFieldExtension : UITextField/** 显示下划线 */-(void)showUnderLine:(UIColor* _Nullable)lineColor;@end#import &quot;TextFieldExtension.h&quot;@interface TextFieldExtension ()@property(nonatomic,assign) BOOL showunderline;@property(nonatomic,strong)UIColor * lineColor;@end@implementation TextFieldExtension- (void)drawRect:(CGRect)rect {    if (_showunderline) {        // Drawing code        CGContextRef context = UIGraphicsGetCurrentContext();               [self.lineColor set];//设置下划线颜色 这里是红色 可以自定义                CGFloat y = CGRectGetHeight(self.frame);        CGContextMoveToPoint(context, 0, y);                CGContextAddLineToPoint(context, CGRectGetWidth(self.frame), y);        //设置线的宽度                CGContextSetLineWidth(context, 1);             //渲染 显示到self上              CGContextStrokePath(context);    }}-(void)showUnderLine:(UIColor *)lineColor{    _showunderline=YES;    _lineColor=lineColor;    [self setNeedsDisplay];}-(UIColor *)lineColor{    if (!_lineColor) {        _lineColor =[UIColor grayColor];    }    return _lineColor;}@end</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> UITextField </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English-UNIT6</title>
      <link href="/2016/11/19/English-Level2-UNIT6/"/>
      <url>/2016/11/19/English-Level2-UNIT6/</url>
      
        <content type="html"><![CDATA[<p>#</p><h2 id="谈论天气、季节和温度"><a href="#谈论天气、季节和温度" class="headerlink" title="谈论天气、季节和温度"></a>谈论天气、季节和温度</h2><p>描述一个地方的天气和气候有多种方法。</p><ol><li><p>你可以描述天气和温度。</p><pre><code>It&#39;s often wendy.    常常刮风。It&#39;s so cold and cloudy.    天很阴，又很冷。It gets to 115 degrees Fahrenheit. That&#39;s, like, 46 degrees Celsius!    温度达到华氏 115 度，相当于 46 摄氏度。</code></pre></li><li><p>你可以使用表达感觉和观点的形容词。</p><pre><code>Fall is perfect.    秋天很美。Winter is terrible.    冬天很糟。It&#39;s lovely in spring.    春天真美。</code></pre></li><li>你可以比较时间、地点和环境。<pre><code>It gets cooler at night.    夜晚天气变得更凉爽。It&#39;s nicer here than in the desert.    这里比沙漠更好。It&#39;s hot in summer and cold in winter.    冬冷夏热。</code></pre></li></ol><h2 id="询问和介绍地点的信息"><a href="#询问和介绍地点的信息" class="headerlink" title="询问和介绍地点的信息"></a>询问和介绍地点的信息</h2><ol><li>询问他们是否喜欢自己的家乡，是鼓励他人谈论其家乡的一种方法。<br><code>`</code><br>A: Where are you from?    你来自哪里？<br>B: I’m from Ottawa.    我来自渥太华。<br>A: Do you like it there?    你喜欢那里吗？<br>B: Oh, yeah. There are fantastic museums and festivals.    哦，是的。那里有许多很好的博物馆和节日。</li></ol><pre><code>2. 询问某件具体的事情，你可以使用表达 What&#39;s the + 名词 + like?。记住，这里的 like 不同于 Do you like ...? 中的用法。</code></pre><p>A: What’s the weather like in your hometown?    你的家乡天气什么样子？<br>B: It’s cold and snowy in winter. It gets to -30 degrees. But it’s warm in summer and fall.    冬天寒冷，还会下雪。温度降到零下 30 度。但夏天和秋天很暖和。</p><pre><code></code></pre><p>A: What’s the food like in Ottawa?    在渥太华都吃什么？<br>B: Well, we eat a lot of fish. And poutine is popular. It’s special french fries with cheese.    嗯，我们常常吃鱼，奶酪蘸番茄酱薯条很受欢迎。这种薯条搭配奶酪，很特别。</p><pre><code></code></pre><p>A: What are the people like?    人都怎么样？<br>B: Many people are university graduates and can speak English and French.    许多人读过大学，会讲英语和法语。</p><pre><code>## 表达疑虑1. 使用类似下面的表达表示疑虑。注意语调的变化如何加深说话人的疑虑程度。  </code></pre><p>Are you sure about that?    那你确定吗？<br>If you say so.     既然你这么说。</p><pre><code>2. 表达疑虑还有一种方法，就是重复或反驳某人刚说的话。再次注意表示疑虑的人的语调。</code></pre><p>A: I’ll probably go to the spa tonight.<br>B: The spa?       我今晚很可能会去水疗中心？<br>水疗中心？<br>A: We’re going to travel through Europe this year.<br>B: You’re not going to Asia?    我们今年打算环游欧洲。<br>你不打算去亚洲吗？</p><pre><code>&gt;语言点：注意这些表示疑虑的表达的使用方式和对象。比如，跟老板说 If you say so 可能不大好！## 用 &#39;Will&#39; 表达提议或主动做某事1.  使用 will + 动词提议或自愿在不久或更远的将来做某事。</code></pre><p>Let’s go to Istanbul. I’ll make the plane reservations right now.    （我们去伊斯坦布尔吧。我马上订机票。）<br>I’ll drive you to the airport next week, if you want.    （如果你愿意，下周我开车送你去机场。）</p><pre><code>2. 使用 will + 动词提出非正式请求。</code></pre><p>A: When I go on vacation, will you take care of my dog?<br>B: Sure, I’ll take care of little Sammie.    （我去度假期间，你帮我照顾狗，好吗？）<br>（没问题，我帮你照顾小 Sammie。）</p><pre><code>3. 你可以使用 will not 谢绝请求，但务必谨慎使用：可能显得过于直接，可能会让人不高兴。</code></pre><p>A: Will you get my luggage?<br>B: No, I won’t.    （你帮我拿行李，好吗？）<br>（不，我不行。）</p><pre><code>## 告别语1. 当某人出发旅行时，使用类似这样的表达送别：</code></pre><p>Have a great trip!     旅途愉快！<br>Drive safely!       小心驾驶！<br>Have a good flight.      坐飞机一路愉快！<br>Call me when you get there.     到了打电话给我。<br>Don’t worry about anything.    什么都不要担心。</p><pre><code>2. 当某人出发旅行时，你可以使用短语 Bon voyage!，该短语直接源于法语。</code></pre><p>A: OK, then. I’m going.    好吧。那我走了。<br>B: Bon voyage!     一路平安！</p><pre><code>## 动词 &#39;try&#39;、&#39;remember&#39; 和 &#39;stop&#39;1. 动词 &#39;try&#39;、&#39;remember&#39; 和 &#39;stop&#39; 的意义会根据后接动词的形式而改变。### &#39;Try&#39;1. 当动词 try 后接不定式 （to + 动词） 时，例如 to buy，表示试图做某事。I can&#39;t go to the mall. Maybe I&#39;ll try to buy something online.              （我不能去商场。也许我会试着网上购物。）2. 当动词 try 后接动名词时 （动词 + -ing），例如 swimming，表示第一次做某事，或尝试做不同的事情。I don&#39;t like biking. Maybe I&#39;ll try swimming on my vacation.    （我不喜欢骑自行车。也许假期我会试着游游泳。）### &#39;Remember&#39;1. 当动词 remember 后接不定式时，例如 to call，表示记得去履行一项职责或任务。I always remember to call my mother on Sunday.    我星期天总是记得打电话给我母亲。2. 当动词 remember 后接动名词时，例如 calling，表示记得过去做过某事。I remember calling the neighbors.    （我记得给邻居打电话了。）### &#39;Stop&#39;1. 当动词 stop 后接不定式时，如 to eat，表示停止一个动作，开始另一个动作。在本例中，这个人在工作，但停下工作吃东西。I stopped to eat when I got hungry.     当我饿的时候，我停下来去吃了点东西。2. 当动词 stop 后接动名词时，如 eating，表示一个中止的动作。I stopped eating when I felt sick.    （我感觉恶心，停止了吃东西。）## 省略形式记住，在英语口语中，每个词的每个音并不是总要发出来。尤其是元音常常缩短或是省略。这些形式很少在书面英语中使用，但听到时能够辨识很重要。请听 going to、have to 和 want to 的省略形式。注意它们书写和发音的不同之处。### &#39;Going to&#39;</code></pre><p>We’re going to fly to Hawaii.    我们打算坐飞机去夏威夷。<br>I’m going to call my mom.     我打算打电话给我妈妈。<br>It’s going to rain.     要下雨了。<br>She’s going to play computer games.<br>她打算玩电脑游戏。</p><pre><code>### &#39;Have to&#39;</code></pre><p>I have to go.    我得走了。<br>We have to be quick.    我们不得不快点。<br>She has to leave.    她不得不离开。<br>He has to get up early.<br>他不得不早起。</p><pre><code>### &#39;Want to&#39;</code></pre><p>I want to go to bed.    我想上床睡觉。<br>Do you want to go to the movies?    你想去看电影吗?<br>She wants to eat out.    她想出去吃饭。</p><p>He wants to go home.<br><code>`</code><br>他想回家。</p><blockquote><p>注意，如果主格代词是 he、she 或 it，have to 和 want to 的口语省略形式会改变，但 going to 的省略形式保持不变。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIImagePickerController</title>
      <link href="/2016/11/17/UIImagePickerController/"/>
      <url>/2016/11/17/UIImagePickerController/</url>
      
        <content type="html"><![CDATA[<p>创建对象</p><pre><code class="objc">//去相册选择图片 UIImagePickerController * pickerController =[[UIImagePickerController alloc]init]; pickerController.mediaTypes = @[(NSString *)kUTTypeImage,(NSString *)kUTTypeMovie,(NSString *)kUTTypeVideo];//设置选择的资源类型 if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) {     pickerController.sourceType=UIImagePickerControllerSourceTypePhotoLibrary;     pickerController.delegate=self;     [self.navigationController presentViewController:pickerController animated:YES completion:^{     }]; }</code></pre><p>代理方法实现：</p><pre><code class="objc">-(void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info{    [picker dismissViewControllerAnimated:NO completion:nil];    NSString * file= nil;    NSString *mdeiaTye = [info objectForKey:UIImagePickerControllerMediaType]; //获取媒体类型    if ([mdeiaTye isEqualToString:(NSString*)kUTTypeImage]) {      //获取的是图片资源        UIImage *image = [info objectForKey:UIImagePickerControllerOriginalImage];        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);        NSString *docPath = [paths lastObject];        file = [docPath stringByAppendingPathComponent:@&quot;output.png&quot;];        [[NSFileManager defaultManager]removeItemAtPath:file error:nil];        NSData *imageData = UIImagePNGRepresentation(image);        [imageData writeToFile:file atomically:YES];        NSString* uuid = [[NSString stringWithFormat:@&quot;tmp://%@&quot;, [[NSUUID UUID] UUIDString]] stringByAppendingPathExtension:[file pathExtension]];        [[NSFileManager defaultManager] moveItemAtPath:file toPath:[FileDownloader cacheFileWithUrl:uuid] error:nil];    }else {      // 获取的是视频资源        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);        NSString *docPath = [paths lastObject];        file = [docPath stringByAppendingPathComponent:@&quot;output.mp4&quot;];        [[NSFileManager defaultManager]removeItemAtPath:file error:nil];        NSURL * url =[info objectForKey:UIImagePickerControllerMediaURL];        NSData * data =[NSData dataWithContentsOfURL:url];        [data writeToFile:file atomically:YES];//将视频移到本应用的目录下        NSString* uuid = [[NSString stringWithFormat:@&quot;tmp://%@&quot;, [[NSUUID UUID] UUIDString]] stringByAppendingPathExtension:[file pathExtension]];        [[NSFileManager defaultManager] moveItemAtPath:file toPath:[FileDownloader cacheFileWithUrl:uuid] error:nil];        // 获取视频时长        CGFloat duration = [self getVideoDuration:url];    }}</code></pre><pre><code class="objc">//获取视频时长-(CGFloat) getVideoDuration:(NSURL*) URL {    NSDictionary* opts = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:NO] forKey:AVURLAssetPreferPreciseDurationAndTimingKey];    AVURLAsset *urlAsset = [AVURLAsset URLAssetWithURL:URL options:opts];    float second = 0;    second = urlAsset.duration.value/urlAsset.duration.timescale;    return second;}</code></pre><pre><code class="objc">// 获取文件大小-(NSInteger) getFileSize:(NSString*) path {    NSFileManager *filemanager = [[NSFileManager alloc]init];    if([filemanager fileExistsAtPath:path]){        NSDictionary* attributes = [filemanager attributesOfItemAtPath:path error:nil];        NSNumber *theFileSize;        if ( (theFileSize = [attributes objectForKey:NSFileSize]) )            return [theFileSize intValue]/1024; else return -1;    }    else {        return -1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顶点着色器</title>
      <link href="/2016/11/17/%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8/"/>
      <url>/2016/11/17/%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>顶点着色器实现了顶点操作的通秀可编程方法</p><p>顶点着色器的输入：</p><ul><li>着色器程序 ： 描述顶点上执行操作的顶点着色器程序源代码或可执行文件</li><li>顶点为着色器输入（属性）：用顶点数组提供的每个顶点的数据</li><li>统一变量（uniform）：顶点着色器使用的不变数据</li><li>采样器： 代表顶点着色器使用纹理的特殊统一变量类型</li></ul><p>顶点着色器可以用来通过矩阵变换位置、计算照明公式来生成逐顶点颜色以及生成或者变换纹理坐标等基于顶点的传统操作。此外，顶点着色器由应用程序规定，所以它可以用于执行自定义计算，实施新的变换、照明或者较传统的固定功能管线所不允许的基于顶点的效果。</p><p> <img src="/Users/yuanpinghua/Desktop/screen capture/屏幕快照 2016-11-16 下午2.38.39.png" alt="屏幕快照 2016-11-16 下午2.38.39"></p><h4 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h4><p>顶点着色器之后，OpenGL ES3.0图形管线的下一阶段是图元装配。</p><p>图元（Primitive）是三角形、直线或者精灵等几何对象。图元的每个顶点被发送到顶点着色器的不同拷贝。在图元装配期间，这些顶点被组合成图元。</p><h4 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h4><p>此阶段绘制对应的图元。光栅化是将图元转化为一组二维片段的过程，然后，这些片段由片段着色器处理。这些二维片段代表着可在屏幕上绘制的像素。</p><p> <img src="/Users/yuanpinghua/Desktop/screen capture/屏幕快照 2016-11-16 下午2.38.55.png" alt="屏幕快照 2016-11-16 下午2.38.55"></p><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>片段着色器为片段上的操作实现了通用的可编程方法，对光栅化阶段生成的每个片段执行这个着色器，采用如下输入：</p><ul><li>着色器程序：描述片段上执行操作的片段着色器程序源代码或可执行文件。</li><li>输入变量：光栅化单元用插值为每个片段生成的顶点着色器输出</li><li>统一变量：片段着色器使用不同的不变数据</li><li>采样器：代表片段着色器所用纹理的特殊统一变量类型</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TableView表格学习笔记</title>
      <link href="/2016/11/04/Tableview/"/>
      <url>/2016/11/04/Tableview/</url>
      
        <content type="html"><![CDATA[<h3 id="UITableViewCell学习"><a href="#UITableViewCell学习" class="headerlink" title="UITableViewCell学习"></a>UITableViewCell学习</h3><h4 id="选中状态颜色设置"><a href="#选中状态颜色设置" class="headerlink" title="选中状态颜色设置"></a>选中状态颜色设置</h4><ol><li>系统自带的效果：<br><code>`</code>objc<br>typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) {<br>UITableViewCellSelectionStyleNone,//没有效果<br>UITableViewCellSelectionStyleBlue,//蓝色<br>UITableViewCellSelectionStyleGray,//灰色<br>UITableViewCellSelectionStyleDefault NS_ENUM_AVAILABLE_IOS(7_0)//灰色<br>};</li></ol><pre><code>2. 改变选中时的背景色```objcself.selectionStyle= UITableViewCellSelectionStyleBlue;self.selectedBackgroundView=[[UIView alloc]initWithFrame:self.bounds];self.selectedBackgroundView.backgroundColor=[UIColor purpleColor];self.multipleSelectionBackgroundView =[[UIView alloc]initWithFrame:self.bounds];self.multipleSelectionBackgroundView.backgroundColor=[UIColor cyanColor];</code></pre><ol start="3"><li>选中状态背景设置的常用属性     </li></ol><ul><li><p><code>@property (nonatomic, strong, nullable) UIView *backgroundView;</code><br>当表格的样式处于<code>UITableViewStylePlain</code>时，该属性为空时，处于<code>UITableViewStyleGrouped</code>样式时，为非空。该背景视图将添加到其他视图的底部。</p></li><li><p><code>@property (nonatomic, strong, nullable) UIView *selectedBackgroundView;</code><br>   当表格的样式处于<code>UITableViewStylePlain</code>时，该属性为空时，处于<code>UITableViewStyleGrouped</code>样式时，为非空。当<code>backgroundView</code>不为空时，该视图将作为一个子视图直接添加到<code>backgroundView</code>上面，或者添加到其他视图的底部。只有当cell处于选中状态下才会添加。调用<code>-setSelected:animated:</code>函数，将会使<code>selectedBackgroundView</code>有淡入淡出的动画效果。</p></li><li><p><code>@property (nonatomic, strong, nullable) UIView *multipleSelectionBackgroundView NS_AVAILABLE_IOS(5_0);</code></p><p>  如果不为空，该视图将会替代<code>selectedBackgroundView</code>,在多选状态下。</p><ol start="4"><li>分隔线的样式</li></ol><pre><code class="objective-c"> typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) {     UITableViewCellSeparatorStyleNone,     UITableViewCellSeparatorStyleSingleLine,     UITableViewCellSeparatorStyleSingleLineEtched   // This separator style is only supported for grouped style table views currently } __TVOS_PROHIBITED;</code></pre><pre><code class="objective-c"> //设置分隔线的缩进 @property (nonatomic) UIEdgeInsets                    separatorInset NS_AVAILABLE_IOS(7_0) UI_APPEARANCE_SELECTOR __TVOS_PROHIBITED; // allows customization of the separator frame</code></pre></li></ul><h3 id="表格的相操作"><a href="#表格的相操作" class="headerlink" title="表格的相操作"></a>表格的相操作</h3><h5 id="1-表格的删除操作"><a href="#1-表格的删除操作" class="headerlink" title="1. 表格的删除操作"></a>1. 表格的删除操作</h5><p>实现表格的如下代理方法：</p><pre><code class="objc">-(BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath{    return YES;}-(NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath{  //设置左滑后，显示的操作说明，这里可以换成其操作    return @&quot;delte&quot;;}</code></pre><pre><code class="objc">-(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath{    //点击该操作后的处理，我这里所做的是删除操作，记住若要删除一个cell，同时也要对数据源进行更改  [ _ datasource removeObjectAtIndex:indexPath.row ];  [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];}-(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath * )indexPath{  //设置编辑的样式    return UITableViewCellEditingStyleDelete;}</code></pre><p>如果左滑后要出现多个操作按钮该怎么处理呢，iOS8以后苹果官司方新增加了个类<code>UITableViewRowAction</code> ,这个类该怎么用，用在哪里？</p><h5 id="2-UITableViewRowAction-使用"><a href="#2-UITableViewRowAction-使用" class="headerlink" title="2 . UITableViewRowAction 使用"></a>2 . <code>UITableViewRowAction</code> 使用</h5><pre><code class="objective-c">NS_CLASS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED @interface UITableViewRowAction : NSObject &lt;NSCopying&gt;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(nullable NSString * )title handler:(void (^)(UITableViewRowAction * action, NSIndexPath * indexPath))handler;@property (nonatomic, readonly) UITableViewRowActionStyle style;@property (nonatomic, copy, nullable) NSString *title;@property (nonatomic, copy, nullable) UIColor *backgroundColor; // default background color is dependent on style@property (nonatomic, copy, nullable) UIVisualEffect* backgroundEffect;@end</code></pre><p>​    该类非常简单，事件的响应使用block回调用，事件的名称以及背景色都可以自定义，那么在表格中哪里使用呢？</p><p>   我们只需要简单实现表格的<code>- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0)</code>这个代理方法。</p><pre><code class="objective-c">// 设置显示多个按钮- (NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath {    //    UITableViewRowAction 通过此类创建按钮    /*     * 1. 我们在使用一些应用的时候，在滑动一些联系人的某一行的时候，会出现删除、置顶、更多等等的按钮，在iOS8之前，我们都需要自己去实现。到了iOS8，系统已经写好了，只需要一个代理方法和一个类就搞定了     * 2. iOS8的协议多了一个方法，返回值是数组的tableView:editActionsForRowAtIndexPath:方法，我们可以在方法内部写好几个按钮，然后放到数组中返回，那些按钮的类就是UITableViewRowAction     * 3. 在UITableViewRowAction类，我们可以设置按钮的样式、显示的文字、背景色、和按钮的事件（事件在Block中实现）     * 4. 在代理方法中，我们可以创建多个按钮放到数组中返回，最先放入数组的按钮显示在最右侧，最后放入的显示在最左侧     * 5. 注意：如果我们自己设定了一个或多个按钮，系统自带的删除按钮就消失了...     * /    UITableViewRowAction * deleteRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;删除&quot; handler:^(UITableViewRowAction *  action, NSIndexPath *  indexPath) {            //事件回调用处理    }];    deleteRowAction.backgroundColor = [UIColor redColor];    UITableViewRowAction * topRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;置顶&quot; handler:^(UITableViewRowAction *  action, NSIndexPath * indexPath) {       //事件回调用处理    }];    topRowAction.backgroundColor = [UIColor blueColor];    UITableViewRowAction * moreRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;更多&quot; handler:^(UITableViewRowAction *  action, NSIndexPath * indexPath) {            //事件回调用处理    }];    return @[deleteRowAction,topRowAction,moreRowAction];}</code></pre><h5 id="3-表格的单选与多选的设置"><a href="#3-表格的单选与多选的设置" class="headerlink" title="3. 表格的单选与多选的设置"></a>3. 表格的单选与多选的设置</h5><pre><code class="objective-c">_groupNumberTableview.allowsSelection=YES; // 是否允许选中_groupNumberTableview.editing=YES;//是否处于编辑状态_groupNumberTableview.allowsMultipleSelection=YES;//是否允许多选_groupNumberTableview.allowsMultipleSelectionDuringEditing=YES;//是否允许在编辑状态下多选</code></pre><h3 id="动态添加headerview"><a href="#动态添加headerview" class="headerlink" title="动态添加headerview"></a>动态添加headerview</h3><pre><code class="objc">UIView *headerView = _tableView.tableHeaderView;  headerView.height = 0;  [_tableView beginUpdates];  [_tableView setTableHeaderView:headerView];// 关键是这句话  [_tableView endUpdates];</code></pre><p>这两句话可以让其过渡有动画效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tableview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPUImage 学习笔记</title>
      <link href="/2016/10/23/GPUImage-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/10/23/GPUImage-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="GPUImage介绍"><a href="#GPUImage介绍" class="headerlink" title="GPUImage介绍"></a>GPUImage介绍</h2><ul><li>GPUImage 是一个基于 GPU 图像和视频处理的开源 iOS 框架。由于使用 GPU 来处理图像和视频，所以速度非常快. 除了速度上的优势，GPUImage 还提供了很多很棒的图像处理滤镜，但有时候这些基本功能仍然无法满足实际开发中的需求，GPUImage 还支持自定义滤镜.</li><li>GPUImage 可使用cocoapods集成到项目中.<pre><code class="sh">pod &#39;GPUImage&#39;, &#39;~&gt; 0.1.7&#39;</code></pre></li><li>如果需要对同一张图片添加多个不同的滤镜, 可以一个一个的 添加.</li></ul>]]></content>
      
      
      <categories>
          
          <category> GPUImage </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS-GPUImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English-UNIT5</title>
      <link href="/2016/10/23/English-Level2-UNIT5/"/>
      <url>/2016/10/23/English-Level2-UNIT5/</url>
      
        <content type="html"><![CDATA[<h1 id="欢迎"><a href="#欢迎" class="headerlink" title="欢迎"></a>欢迎</h1><h2 id="使用-just-表示最近的过去"><a href="#使用-just-表示最近的过去" class="headerlink" title="使用 just 表示最近的过去"></a>使用 just 表示最近的过去</h2><p>使用 just + 动词谈论刚刚或最近完成的行动。<br>Zach and I <em>just bought</em> a house.     （我和 Zach 刚买了房子。）<br>Carla <em>just got promoted</em>.    （Carla 刚刚升职。）</p><h2 id="开启和改变对话话题"><a href="#开启和改变对话话题" class="headerlink" title="开启和改变对话话题"></a>开启和改变对话话题</h2><p>你可以使用 Guess what? 来引出或改变话题。</p><p>A: Hey, Daniel. How’s it going?<br>B: Good. <em>Guess what</em>?<br>A: What?<br>B: I just got a promotion.    </p><p>你好，Daniel。最近好吗？<br>还好。猜猜怎么着？<br>怎么了？<br>我刚刚升职了。</p><p><strong>记住，你可以使用 <code>that reminds me</code> 或 <code>by the way</code> 转到与当前话题相关的话题。</strong></p><p>A: I just had my 33rd birthday!<br>B: Well, happy birthday! Hey, <em>that reminds me</em>. Do you want to come to my son’s birthday party?    </p><p>我刚过了 33 岁生日。<br>哦，生日快乐！嗨，这想起来了。你想参加我儿子的生日派对吗？</p><p>A: Wow! This pizza tastes amazing.<br>B: It sure does. <em>By the way</em>, I’m having pizzas and movies at my house on Saturday.    </p><p>哇！这个披萨味道真好。<br>的确不错。对了，星期六我打算在家吃披萨看电影。</p><p>使用 <code>anyway</code> 把跑偏的对话拉回原来的话题。</p><p>A: We just got a new swimming pool.<br>B: Really? Man, how did you pay for that?<br>A: My credit card! <em>Anyway</em>, we’re having a pool party on Sunday.<br>我们刚修了一座游泳池。<br>是吗？老兄，你哪来钱的？<br>信用卡啊！对了，我们星期天会办一个泳池派对。</p><p>谨慎使用这些表达：如果唐突改变话题，可能会让人感到冒犯。</p><h2 id="可能性副词"><a href="#可能性副词" class="headerlink" title="可能性副词"></a>可能性副词</h2><h3 id="可能性副词表示某事发生的相对可能性。"><a href="#可能性副词表示某事发生的相对可能性。" class="headerlink" title="可能性副词表示某事发生的相对可能性。"></a>可能性副词表示某事发生的相对可能性。</h3><blockquote><p>副词通常直接位于其修饰的动词之前，如果是 be 动词，则位于其后。maybe 是例外，常常位于句首。</p></blockquote><ul><li><p>表示百分之百的可能性，使用 <em>definitely</em> 或 <em>absolutely</em>。</p><p>I definitely saw Sheila at the party.（我肯定在派对上看到了 Sheila。）                    </p><p>Lucille absolutely can’t come.（Lucille 绝对不能来。）</p></li><li><p>表示较大的可能性，使用 <em>probably</em>。</p><p>They are probably late.（他们很可能迟到了。）<br>Dylan probably brought drinks.（Dylan 很可能带了酒水。）<br>They probably can’t buy snacks.（他们很可能不能买零食。）</p></li><li><p>表示较小的可能性，使用 <em>maybe</em>。注意该词用于句首。</p><p>Maybe we can have a surprise party.（我们也许可以办一个惊喜派对。）<br>A: Is Rhonda coming?<br>B: Maybe not. She’s still working.Rhonda 来吗？<br>（可能不来，她还在工作。）</p></li><li><p>表示非常小的可能性，你可以使用 <em>unlikely</em>。</p><p>A: Is Grandma coming to the celebration?<br>B: It’s unlikely. She’s not feeling well.    祖母 外婆 来参加庆祝活动吗？<br>（不大可能。她身体不舒服。）</p></li><li><p>你可以在一个单词的回答中使用可能性副词。</p><p>A: Are you inviting Dylan?<br>B: Definitely.    你请 Dylan 吗？<br>（当然！）<br>A: Can I see you tonight?<br>B: Maybe.    我今晚能见你吗？<br>（可能吧。）</p></li></ul><h2 id="提出及回应邀请"><a href="#提出及回应邀请" class="headerlink" title="提出及回应邀请"></a>提出及回应邀请</h2><p>使用类似这些表达提出邀请。提出邀请前，先具体说明邀请的场合是有好处的。     </p><p>We’re having some people over next weekend. Kelsey and I are hoping that you and Cody can come.         我们下周末打算邀请一些人到家里来。Kesley 跟我都希望你和 Cody 能来。     </p><p>I’m having a birthday party for Tyler in two weeks. I’d like you to come.         两周后我要为 Tyler 办生日派对。我希望你能来。     </p><p>Are you free Friday night? Would you like to come to a housewarming?         你周五晚上有空吗？你想来参加暖屋派对吗？     </p><p>We should get together for dinner this week. What does your schedule look like?         我们本周应该聚在一起吃顿饭。你的日程怎么样？     </p><p>接受或讨论邀请，使用类似的表达：     </p><p>Great! I’m definitely coming.         太棒了！我一定来！<br>We can probably come. Let me talk to Dave about it.         我们很有可能来。让我跟 Dave 说说。<br>Thanks – I’d be delighted.         谢谢 – 荣幸之至。     </p><p>谢绝邀请，使用类似这样的表达：     </p><p>Sorry – Chelsea probably can’t come. She has a cold.         抱歉 - Chelsa 很可能来不了。她感冒了。     </p><p>Oh, that weekend’s no good. Sorry!         哦，这个周末不行。对不起！     </p><h2 id="欢迎客人"><a href="#欢迎客人" class="headerlink" title="欢迎客人"></a>欢迎客人</h2><h3 id="使用类似这样的表达欢迎客人："><a href="#使用类似这样的表达欢迎客人：" class="headerlink" title="使用类似这样的表达欢迎客人："></a>使用类似这样的表达欢迎客人：</h3><p>Welcome!     欢迎光临！<br>Hi! It’s so good to see you.    嗨！很高兴见到你。<br>I’ve missed you!    我好想你！</p><h3 id="使用类似这样的表达邀请客人进到你家里："><a href="#使用类似这样的表达邀请客人进到你家里：" class="headerlink" title="使用类似这样的表达邀请客人进到你家里："></a>使用类似这样的表达邀请客人进到你家里：</h3><p>Come in!    请进！<br>Make yourself at home.    不要客气。<br>Please make yourselves comfortable.     请不要拘束。</p><h3 id="使用类似的表达让客人感到自在："><a href="#使用类似的表达让客人感到自在：" class="headerlink" title="使用类似的表达让客人感到自在："></a>使用类似的表达让客人感到自在：</h3><p>Can I take your coat?     我帮你拿外套吧？<br>You can put your things over here.       你可以把你的东西放在这里。<br>Can I get you something to drink?     想喝点什么吗？</p><h3 id="客人落座后，你可以提出类似这样的问题，礼貌地对话："><a href="#客人落座后，你可以提出类似这样的问题，礼貌地对话：" class="headerlink" title="客人落座后，你可以提出类似这样的问题，礼貌地对话："></a>客人落座后，你可以提出类似这样的问题，礼貌地对话：</h3><p>How was your trip?     旅途怎么样？</p><p>How was traffic?    交通状况如何？</p><h2 id="形容词搭配不定式"><a href="#形容词搭配不定式" class="headerlink" title="形容词搭配不定式"></a>形容词搭配不定式</h2><h3 id="你可以使用形容词-to-动词解释情感和状态。"><a href="#你可以使用形容词-to-动词解释情感和状态。" class="headerlink" title="你可以使用形容词 + to + 动词解释情感和状态。"></a>你可以使用形容词 + to + 动词解释情感和状态。</h3><p>I’m happy to hear that you like Korean food.    （我很高兴听到你喜欢韩国菜。）<br>I was surprised to get the promotion.    （我很惊讶获得升职。）<br>So good to see you!    （很高兴见到你！）<br>Amy’s ready to eat dinner.    （Amy 准备好吃饭了。）</p><h2 id="提供东西和提出礼貌的请求"><a href="#提供东西和提出礼貌的请求" class="headerlink" title="提供东西和提出礼貌的请求"></a>提供东西和提出礼貌的请求</h2><h3 id="使用-would-you-like-礼貌向客人提供某物。"><a href="#使用-would-you-like-礼貌向客人提供某物。" class="headerlink" title="使用 would you like 礼貌向客人提供某物。"></a>使用 would you like 礼貌向客人提供某物。</h3><p>Would you like something to drink?    你想喝点什么吗？<br>Would you like to have a seat?    （你想坐下吗？）</p><h3 id="使用-could-或-may-向主人提出礼貌的请求"><a href="#使用-could-或-may-向主人提出礼貌的请求" class="headerlink" title="使用 could 或 may 向主人提出礼貌的请求"></a>使用 could 或 may 向主人提出礼貌的请求</h3><p>May I use the restroom?    我可以用一下厕所吗？<br>Could I have some water?    我能喝点水吗？</p><blockquote><p>语言点：在美式英语中，restroom 是家中厕所非常礼貌的称法，Bathroom 相对礼貌，toilet 不礼貌。在英式英语中，toilet 是家中厕所非常礼貌的称法， Loo 是可以接受的用法，但只限于非正式场合和熟悉的人。</p></blockquote><h2 id="听到好消息和坏消息的反应"><a href="#听到好消息和坏消息的反应" class="headerlink" title="听到好消息和坏消息的反应"></a>听到好消息和坏消息的反应</h2><ul><li><p>听到好消息时，使用类似这样的表达作出反应。</p><p>Congratulations!恭喜！<br>Really? I’m so happy for you!真的吗？我为你感到非常高兴！<br>That’s great news!这消息太棒了！</p></li><li><p>喝酒时，你可以说 to your 和 to your 来祝酒。</p><pre><code>   To your new job! Cheers!（为你的新工作！干杯！）   To your new baby. Cheers!（为你的新生宝宝干杯！）</code></pre></li><li><p>听到坏消息时，使用类似的表达作出反应：</p><pre><code>   A: Sorry – the sofa is not very comfortable.   B: That&#39;s OK.    对不起 - 沙发不是很舒服。   没关系。   A: I just got fired.   B: That&#39;s terrible! I&#39;m so sorry to hear that.    我刚被解雇了。   太糟糕了！听到这个我感到很抱歉。</code></pre></li><li><p>听到好消息和坏消息时，你都可以使用 it’s crazy。</p><pre><code> I was surprised to get this great promotion. It&#39;s crazy.（这次得到升职，我感到很吃惊。不可思议。） It felt terrible to get fired. It&#39;s totally crazy.（遭到解雇感觉糟透了。这简直不可思议。）</code></pre></li></ul><p><strong>形容词同义词</strong></p><p>使用同义词或具有相同意义的单词，可以让你的英文更富于乐趣和变化。学习同义词也是识记新词的一种好办法。 以下是一些有用的形容词同义词：</p><ul><li>great - wonderful - delightful        <em>好的 / 极好的 / 令人高兴的</em></li><li>fun - enjoyable    <em>令人愉快的 / 令人愉快的</em></li><li>happy - glad - pleased     <em>高兴的 / 乐意的 / 喜欢的</em></li><li>beautiful - lovely - gorgeous  <em>美丽的 / 可爱的 / 迷人的</em></li><li>delicious - tasty - yummy    <em>美味的 / 可口的 /好吃的</em></li></ul><p><strong>美式英语和英式英语</strong><br>美式英语和英式英语在发音、词汇、表达、拼写和语言等方面存在诸多不同。这些差异不一定很明确，但碰到时如果能够辨识也很重要。<br><strong>发音</strong><br> 下为美式英语和英式英语中音节重读差异的一个例子。</p><ul><li>American: ca<strong>FE</strong>  咖啡馆</li><li>British:  <strong>CA</strong>fe</li></ul><table><thead><tr><th><strong>词汇</strong></th><th style="text-align:left"></th><th></th></tr></thead><tbody><tr><td>下为一些词汇差异的例子。</td><td style="text-align:left"></td><td></td></tr><tr><td></td><td style="text-align:left">American:<em>gas</em></td><td>（汽油）</td></tr><tr><td></td><td style="text-align:left">British:<em>petrol</em></td><td></td></tr><tr><td></td><td style="text-align:left"></td><td></td></tr><tr><td></td><td style="text-align:left">American:<em>restroom</em></td><td>（厕所）</td></tr><tr><td></td><td style="text-align:left">British:<em>toilet</em></td><td></td></tr><tr><td></td><td style="text-align:left"></td><td></td></tr><tr><td></td><td style="text-align:left">American:<em>cellphone</em></td><td>（手机）</td></tr><tr><td></td><td style="text-align:left">British:<em>mobile</em></td></tr></tbody></table><table><thead><tr><th><strong>表达</strong></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>虽然这些短语中的第一个在美式和英式英语中都可以使用，但 <strong>spot on</strong> 多在英式英语中使用。它们的意思相同。</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>American / British:<em>That’s exactly right!</em></td><td>（确实如此!）</td><td></td></tr><tr><td></td><td>British:<em>Spot on!</em></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><strong>语法</strong></td><td></td><td></td><td></td></tr><tr><td>你在英美两国都能听到这些疑问句结构。但是，<strong>do you have</strong> 多用于美国，<strong>have you got</strong> 则多用于英国。</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>American:<strong><em>Do you have</em></strong> a pen?</td><td>你有笔吗？</td><td></td></tr><tr><td></td><td>British:<strong><em>Have you got</em></strong> a pen?</td><td></td></tr></tbody></table><table><thead><tr><th><strong>离开某人的家</strong></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td>当你离开某人家时，使用类似这样的表达：</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td><em>The party was wonderful.</em></td><td>派对很精彩。</td></tr><tr><td></td><td><em>We had a great time.</em></td><td>我们过得很愉快。</td></tr><tr><td></td><td><em>It was so nice to see you again.</em></td><td>很高兴又见到你。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>你的主人也许会检查确认你没有遗忘东西。</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>A:<em>Do you have everything?</em>B:<em>I think so.</em></td><td>你东西都拿了吗？我想是的。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td>A:<em>Have you got everything?</em>      B:<em>Yes, I have, thanks.</em></td><td>你东西都拿了吗？是的，我都拿了，谢谢。</td></tr></tbody></table><table><thead><tr><th>你可以邀请主人将来到你家拜访。这里的第一个例子更接近美式英语，第二个例子更接近英式英语。</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td><em>Next time, it’s our turn to host.</em></td><td>下次我们来办。</td></tr><tr><td></td><td><em>You must come to us next time.</em></td><td>你下次一定要来我们家。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>人们在听到这些句子后通常会表示感谢。</td><td></td></tr></tbody></table><h5 id="Hope-to-和-hope-that"><a href="#Hope-to-和-hope-that" class="headerlink" title="Hope to 和 hope that"></a><strong>Hope to 和 hope that</strong></h5><p>使用<strong>Hope to</strong> 和 <strong>hope that</strong> 谈论你希望发生的事情。注意，<strong>Hope to</strong> 后接动词原形， <strong>hope that</strong> 后接从句。</p><p>​     I <strong>hope to</strong>see you again soon.                   <em>我希望不久后能再见到你</em>                </p><p>​    <strong>I</strong> hope that <strong>I see you again soon.</strong> 我希望我不久后能再见到你。</p><p>在英语口语和书面语中，单词 <strong>that</strong> 有没有都可以，在句中省略不会影响句子意思。</p><p>​     <em>I</em>  <strong>hope</strong>  I see you again soon. 我希望我不久后能再见到你。</p><p>使用 <strong>I hope so, too</strong> 肯定应答 <strong>hope to</strong> 或 <strong>hope that</strong> 的句子。</p><pre><code> A:   *I hope to see you again soon.*</code></pre><p>​    B:  <em>I  <strong>hope so, too</strong> .</em></p><p>​    我希望不久后能再见到你。<br>​    我也这样希望。</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 学习笔记1</title>
      <link href="/2016/10/11/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/10/11/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节讲解几个基本命令：</p><ul><li>git config：配置相关信息</li><li>git clone：复制仓库</li><li>git init：初始化仓库</li><li>git add：添加更新内容到索引中</li><li>git diff：比较内容</li><li>git status：获取当前项目状况</li><li>git commit：提交</li><li>git branch：分支相关</li><li>git checkout：切换分支</li><li>git merge：合并分支</li><li>git reset：恢复版本</li><li>git log：查看日志<a id="more"></a></li></ul></blockquote><h1 id="git-的初始化"><a href="#git-的初始化" class="headerlink" title="git 的初始化"></a>git 的初始化</h1><ol><li>git 配置<br>使用Git的第一件事就是设置你的名字和<code>email</code>,这些就是你在提交<code>commit</code>时的签名，每次提交记录里都会包含这些信息。使用<code>git config</code>命令进行配置：<pre><code class="sh">bogon:~ yuanpinghua$ git config --global user.name &quot;yuanph&quot;bogon:~ yuanpinghua$ git config --global user.email &quot;yuanph@ushareit.com&quot;</code></pre>执行了上面的命令后,会在家目录(<code>/yuanpinghua</code>)下建立一个叫<code>.gitconfig</code> 的文件（该文件问隐藏文件，需要使用<code>ls -al</code>查看到. 内容一般像下面这样，可以使用vim或cat查看文件内容:</li></ol><pre><code class="sh">bogon:~ yuanpinghua$ cat ~/.gitconfig[core]    excludesfile = /Users/yuanpinghua/.gitignore_global[difftool &quot;sourcetree&quot;]    cmd = opendiff \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;    path =[mergetool &quot;sourcetree&quot;]    cmd = /Applications/SourceTree.app/Contents/Resources/opendiff-w.sh \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; -ancestor \&quot;$BASE\&quot; -merge \&quot;$MERGED\&quot;    trustExitCode = true[user]    name = yuanph    email = yuanph@ushareit.com</code></pre><p>这是个我电脑上的git配置信息.</p><blockquote><p>上面的配置文件就是Git全局配置的文件，一般配置方法是<code>git config --global &lt;配置名称&gt; &lt;配置的值&gt;</code>。<br>如果你想使项目里的某个值与前面的全局设置有区别(例如把私人邮箱地址改为工作邮箱)，你可以在项目中使用<code>git config</code>命令不带<code>--global</code>选项来设置. 这会在你当前的项目目录下创建 <code>.git/config</code>，从而使用针对当前项目的配置。</p></blockquote><h1 id="获得一个Git仓库"><a href="#获得一个Git仓库" class="headerlink" title="获得一个Git仓库"></a>获得一个Git仓库</h1><p>既然我们现在把一切都设置好了，那么我们需要一个Git仓库。有两种方法可以得到它：</p><ul><li>从已有的Git仓库中clone (克隆，复制).</li><li>新建一个仓库，把未进行版本控制的文件进行版本控制.</li></ul><h2 id="Clone一个仓库"><a href="#Clone一个仓库" class="headerlink" title="Clone一个仓库"></a>Clone一个仓库</h2><p>为了得一个项目的拷贝(copy),我们需要知道这个项目仓库的地址(Git URL). Git能在许多协议下使用，所以Git URL可能以<code>ssh://</code>, <code>http(s)://</code>, <code>git://</code>. 有些仓库可以通过不只一种协议来访问<br>我在github上创建一个名为“gittutorial”的仓库。这个仓库用来进行 clone</p><pre><code class="sh">git clone https://github.com/zhipengbird/gittutorial.git</code></pre><p>clone完成后，会在当前目录下多一个gittutorial的文件夹。这个文件夹里的内容就是我们刚才clone下来的代码。</p><h2 id="初始化一个新的仓库"><a href="#初始化一个新的仓库" class="headerlink" title="初始化一个新的仓库"></a>初始化一个新的仓库</h2><p>可以对一个已存在的文件夹用下面的命令让它置于Git的版本控制管理之下。<br>创建工程目录，初始化git仓库：</p><pre><code class="sh">bogon:~ yuanpinghua$ mkdir projectbogon:~ yuanpinghua$ cd projectbogon:project yuanpinghua$ git initInitialized empty Git repository in /Users/yuanpinghua/project/.git/</code></pre><p>通过<code>ls -la</code>命令会发现<code>project</code>目录下会有一个名叫<code>.git</code> 的目录被创建，这意味着一个仓库被初始化了。可以进入到<code>.git</code>目录查看下有哪些内容</p><h1 id="正常的工作流程"><a href="#正常的工作流程" class="headerlink" title="正常的工作流程"></a>正常的工作流程</h1><h2 id="正常的工作流程-1"><a href="#正常的工作流程-1" class="headerlink" title="正常的工作流程"></a>正常的工作流程</h2><p>&emsp; git的基本流程如下：</p><ul><li>创建或修改文件</li><li>使用git add命令添加新创建或修改的文件到本地的缓存区（Index）</li><li>使用git commit命令提交到本地代码库</li><li>（可选，有的时候并没有可以同步的远端代码库）使用git push命令将本地代码库同步到远端代码库</li></ul><p>进入我们刚才建立的project目录，分别创建文件file1，file2，file3：</p><pre><code class="sh">bogon:project yuanpinghua$ touch file1 file2 file3</code></pre><p>修改文件，可以使用vim编辑内容，也可以直接echo添加测试内容。</p><pre><code class="sh">$ echo &quot;testcontent1&quot; &gt;&gt; file1$ echo &quot;testcontent2&quot; &gt;&gt; file2$ echo &quot;testcontent3&quot; &gt;&gt; file3</code></pre><p>此时可以使用<code>git status</code>命令查看当前git仓库的状态：</p><pre><code class="sh">$ git statusOn branch masterInitial commitUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    file1    file2    file3nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><p>可以发现，有三个文件处于<code>untracked</code>状态，下一步我们就需要用<code>git add</code>命令将他们加入到缓存区（Index）。<br>使用git add命令将新建的文件添加到缓存区：</p><pre><code class="sh">$ git add file1 file2 file3</code></pre><p>然后再次执行<code>git status</code>就会发现新的变化：</p><pre><code class="sh">$ git statusOn branch masterInitial commitChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)    new file:   file1    new file:   file2    new file:   file3</code></pre><p>你现在为commit做好了准备，你可以使用 git diff 命令再加上 –cached 参数，看看缓存区中哪些文件被修改了。<br>如果没有–cached参数，git diff 会显示当前你所有已做的但没有加入到索引里的修改。</p><pre><code class="sh">$ git diff --cacheddiff --git a/file1 b/file1new file mode 100644index 0000000..ac65bb3--- /dev/null+++ b/file1@@ -0,0 +1 @@+testcontent1diff --git a/file2 b/file2new file mode 100644index 0000000..a7db157--- /dev/null+++ b/file2@@ -0,0 +1 @@+testcontent2diff --git a/file3 b/file3new file mode 100644index 0000000..be7a7f5--- /dev/null+++ b/file3@@ -0,0 +1 @@+testcontent3</code></pre><p>当所有新建，修改的文件都被添加到了缓存区，我们就要使用<code>git commit</code>提交到本地仓库：</p><pre><code class="sh">$ git commit -m &#39;add three files&#39;[master (root-commit) 2a5cf79] add three files 3 files changed, 3 insertions(+) create mode 100644 file1 create mode 100644 file2 create mode 100644 file3</code></pre><p>需要使用<code>-m</code>添加本次修改的注释，完成后就会记录一个新的项目版本。除了用<code>git add</code>命令，我们还可以用下面的命令将所有没有加到缓存区的修改也一起提交，但<code>-a</code>命令不会添加新建的文件。</p><pre><code class="sh">$ echo &quot;file yet add to cached&quot; &gt;&gt; file1$ git commit -a -m &#39;add yet cached content&#39;[master cabcbbf] add yet cached content 1 file changed, 1 insertion(+)</code></pre><pre><code class="sh">$ touch file4$ echo &quot;edit file2&quot; &gt;&gt; file2git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   file2Untracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    file4no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>此时有工程下有一个新的修改和一个未跟踪的文件，我们使用g<code>it commit -a -m</code>来提交看下最后的效果：</p><pre><code class="sh">$ git commit -a -m &#39;add modify&#39;[master 5888696] add modify 1 file changed, 1 insertion(+)</code></pre><p>使用 <code>git status</code>查询当前状态：</p><pre><code class="sh">$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)    file4nothing added to commit but untracked files present (use &quot;git add&quot; to track)</code></pre><p>我们发现刚才新增的文件没有提交到本地的仓库里。<br>我们使用 <code>git add</code>,<code>git commit -m</code>将其提交到本地仓库中。<br>再次输入git status查看状态，会发现当前的代码库已经没有待提交的文件了，缓存区已经被清空。</p><blockquote><p>至此，我们完成了第一次代码提交，这次提交的代码中我们创建了四个新文件。需要注意的是如果是修改文件，也需要使用<code>git add</code>命令添加到缓存区才可以提交。如果是删除文件，则直接使用<code>git rm</code>命令删除后会自动将已删除文件的信息添加到缓存区，<code>git commit</code>提交后就会将本地仓库中的对应文件删除</p></blockquote><p>这个时候如果本地的仓库连接到了远程Git服务器，可以使用下面的命令将本地仓库同步到远端服务器：</p><pre><code class="sh">$ git push origin master</code></pre><h1 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h1><p>&emsp;Git的分支可以让你在主线（master分支）之外进行代码提交，同时又不会影响代码库主线。分支的作用体现在多人协作开发中，比如一个团队开发软件，你负责独立的一个功能需要一个月的时间来完成，你就可以创建一个分支，只把该功能的代码提交到这个分支，而其他同事仍然可以继续使用主线开发，你每天的提交不会对他们造成任何影响。当你完成功能后，测试通过再把你的功能分支合并到主线</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一个Git仓库可以维护很多开发分支。现在我们来创建一个新的叫 <code>experimental</code>的分支</p><pre><code class="sh">$ git branch experimental</code></pre><p>运行git branch命令可以查看当前的分支列表，已经目前的开发环境处在哪个分支上：</p><pre><code class="sh">$ git branch  experimental* master</code></pre><p><code>experimental</code>分支是你刚才创建的，<code>master</code>分支是<code>Git</code>系统默认创建的主分支。星号标识了你当工作在哪个分支下，输入<code>git checkout</code>分支名可以切换到其他分支：</p><pre><code class="sh">$ git checkout experimentalSwitched to branch &#39;experimental&#39;</code></pre><p>切换到<code>experimental</code>分支，切换完成后，先编辑里面的一个文件，再提交(<code>commit</code>)改动，最后切换回 “<code>master</code>”分支：</p><pre><code class="sh">$ echo &#39;update file1 in experimental branch&#39; &gt;&gt; file1 # 修改文件$ git status # 查看当前状态On branch experimentalChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   file1no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git add file1 # 添加修改$ git commit -m &#39;update file1&#39; # 提交更改[experimental f8d7347] update file1 1 file changed, 1 insertion(+)$ cat file1 # 查看内容testcontent1file yet add to cachedupdate file1 in experimental branch$ git checkout master # 切换回主分支Switched to branch &#39;master&#39;</code></pre><p>查看下file1中的内容会发现刚才做的修改已经看不到了。因为刚才的修改时在<code>experimental</code>分支下，现在切换回了<code>master</code>分支，目录下的文件都是<code>master</code>分支上的文件了。<br>现在可以在<code>master</code>分支下再作一些不同的修改:</p><pre><code class="shell">$ echo &#39;update file2 in master branch&#39; &gt;&gt; file2$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)    modified:   file2no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git add file2$ git  commit -m &#39; update file2 on master&#39;[master b1f2507]  update file2 on master 1 file changed, 1 insertion(+)$ cat file2testcontent2edit file2update file2 in master branch</code></pre><p>这时，两个分支就有了各自不同的修改，分支的内容都已经不同，如何将多个分支进行合并呢？</p><p>可以通过下面的<code>git merge</code>命令来合并<code>experimental</code>到主线分支<code>master</code>:</p><pre><code class="shell">$ git merge -m &#39;merge experimental branch&#39; experimentalMerge made by the &#39;recursive&#39; strategy. file1 | 1 + 1 file changed, 1 insertion(+)</code></pre><p><code>-m</code>参数仍然是需要填写合并的注释信息。<br>由于两个branch修改了两个不同的文件，所以合并时不会有冲突，执行上面的命令后合并就完成了。</p><p>如果有冲突，比如两个分支都改了一个文件file3，则合并时会失败。首先我们在master分支上修改file3文件并提交：</p><pre><code class="sh"># 修改文件3$ echo &#39;update file3 in master branch&#39; &gt;&gt; file3$ git commit -a -m &#39;update file3 on master&#39; # 提交更改[master 042406f] update file3 on master 1 file changed, 1 insertion(+)</code></pre><p>然后切换到<code>experimental</code>，修改<code>file3</code>并提交：</p><pre><code class="sh">$ git checkout experimentalSwitched to branch &#39;experimental&#39;$ echo &#39; update file3 on experimental&#39; &gt;&gt; file3$ git commit -a -m &#39;update file3 on experimental&#39;[experimental b5bdaf6] update file3 on experimental 1 file changed, 1 insertion(+)</code></pre><p>切换到<code>master</code>进行合并：</p><pre><code class="sh">$ git merge experimentalAuto-merging file3CONFLICT (content): Merge conflict in file3Automatic merge failed; fix conflicts and then commit the result.</code></pre><p>合并失败后先用<code>git status</code>查看状态，会发现file3显示为<code>both modified</code>，查看file3内容会发现：</p><pre><code class="sh">$ git statusOn branch masterYou have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)    both modified:   file3no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ cat file3testcontent3&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADupdate file3 in master branch======= update file3 on experimental&gt;&gt;&gt;&gt;&gt;&gt;&gt; experimental</code></pre><p>上面的内容也可以使用<code>git diff</code>查看，先前已经提到<code>git diff</code>不加参数可以显示未提交到缓存区中的修改内容。</p><pre><code class="sh">$ git diffdiff --cc file3index c3d69fe,2d0b022..0000000--- a/file3+++ b/file3@@@ -1,2 -1,2 +1,6 @@@  testcontent3++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD +update file3 in master branch++=======+  update file3 on experimental++&gt;&gt;&gt;&gt;&gt;&gt;&gt; experimental</code></pre><p>可以看到冲突的内容都被添加到了file3中，我们使用vim编辑这个文件，去掉git自动产生标志冲突的<code>&lt;&lt;&lt;&lt;&lt;&lt;</code>等符号后，根据需要只保留我们需要的内容后保存，然后使用<code>git add file3</code>和<code>git commit</code>命令来提交合并后的file3内容，这个过程是手动解决冲突的流程。</p><pre><code class="sh">$ vi file3$ git add file3$ git statusOn branch masterAll conflicts fixed but you are still merging.  (use &quot;git commit&quot; to conclude merge)Changes to be committed:    modified:   file3$ git commit -m &#39;merge file3&#39;[master 9cbeac6] merge file3</code></pre><p>当我们完成合并后，不再需要<code>experimental</code>时，可以使用下面的命令删除：</p><pre><code class="sh">$ git branch -d experimentalDeleted branch experimental (was b5bdaf6).</code></pre><blockquote><p><code>git branch -d</code>只能删除那些已经被当前分支的合并的分支. 如果你要强制删除某个分支的话就用<code>git branch –D</code></p></blockquote><h2 id="撒销一个合并"><a href="#撒销一个合并" class="headerlink" title="撒销一个合并"></a>撒销一个合并</h2><p>如果你觉得你合并后的状态是一团乱麻，想把当前的修改都放弃，你可以用下面的命令回到合并之前的状态：</p><pre><code class="sh">a$ git reset --hard HEAD^HEAD is now at 042406f update file3 on master$ cat file3  # 查看file3的内容，已经恢复到合并前的master上的文件内容testcontent3update file3 in master branch</code></pre><h2 id="快速向前合并"><a href="#快速向前合并" class="headerlink" title="快速向前合并"></a>快速向前合并</h2><p>还有一种需要特殊对待的情况，在前面没有提到。通常，一个合并会产生一个合并提交(commit), 把两个父分支里的每一行内容都合并进来。</p><p>但是，如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。</p><h1 id="Git日志"><a href="#Git日志" class="headerlink" title="Git日志"></a>Git日志</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p><code>git log</code>命令可以显示所有的提交(commit)：</p><pre><code class="sh">$ git log</code></pre><p>如果提交的历史纪录很长，回车会逐步显示，输入<code>q</code>可以退出。<br><code>git log</code>有很多选项，可以使用<code>git help log</code>查看，例如下面的命令就是找出所有从”v2.5“开始在fs目录下的所有Makefile的修改：</p><pre><code class="sh">$ git log v2.5.. Makefile fs/</code></pre><p>Git会根据<code>git log</code>命令的参数，按时间顺序显示相关的提交(commit)。</p><h2 id="日志统计"><a href="#日志统计" class="headerlink" title="日志统计"></a>日志统计</h2><p>如果用–stat选项使用<code>git log</code>,它会显示在每个提交(commit)中哪些文件被修改了, 这些文件分别添加或删除了多少行内容，这个命令相当于打印详细的提交记录：</p><pre><code class="sh">$ git log --stat</code></pre><h2 id="格式化日志"><a href="#格式化日志" class="headerlink" title="格式化日志"></a>格式化日志</h2><p>你可以按你的要求来格式化日志输出。<code>--pretty</code> 参数可以使用若干表现格式，如<code>oneline</code>:</p><pre><code class="sh">$ git log --pretty=oneline</code></pre><p>显示样式如下</p><pre><code class="sh">042406fc594369852da2a708d3c1711d0e06f96e update file3 on master26ecc96e38154b12f13e524a59258ceaf12a1ec8 merge experimental branchb1f2507784fb22ea6e6fcbe94fe3c0f5deafc8e4  update file2 on masterf8d734757042dc5b92f6f1ea5a8cff828c339ef5 update file1ebf80c4a15490f3356f4fd20d602de195bb9841f add file458886962819614df227fc19cfb9148cb286c1865 add modifycabcbbf371f41559e6fefdd4dbc8bc057d1f19e0 add yet cached content2a5cf798589e67b6cc7e6ba26a042e9523b5cd05 add three files</code></pre><p>或者你也可以使用 short 格式:</p><pre><code class="sh">$ git log --pretty=short</code></pre><p>显示结果样式如下：</p><pre><code class="sh">commit 042406fc594369852da2a708d3c1711d0e06f96eAuthor: yuanph &lt;yuanph@ushareit.com&gt;    update file3 on mastercommit 26ecc96e38154b12f13e524a59258ceaf12a1ec8Merge: b1f2507 f8d7347Author: yuanph &lt;yuanph@ushareit.com&gt;    merge experimental branch.....</code></pre><p>你也可用<code>medium</code>,<code>full</code>,<code>fuller</code>,<code>email</code> 或<code>raw</code>。 如果这些格式不完全符合你的相求， 你也可以用<code>--pretty=format</code>参数定义格式。<br>以下是几种格式的显示方式，有兴趣可以看下，没有兴趣的略过</p><ul><li><p><code>git log --pretty=medium</code><br><code>`</code>sh</p><h1 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h1><p>$ git log –pretty=medium<br>commit 042406fc594369852da2a708d3c1711d0e06f96e<br>Author: yuanph <a href="mailto:&#x79;&#x75;&#97;&#110;&#x70;&#104;&#64;&#117;&#x73;&#x68;&#97;&#114;&#x65;&#105;&#x74;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x79;&#x75;&#97;&#110;&#x70;&#104;&#64;&#117;&#x73;&#x68;&#97;&#114;&#x65;&#105;&#x74;&#46;&#99;&#x6f;&#x6d;</a><br>Date:   Tue Oct 11 16:14:03 2016 +0800</p><p>  update file3 on master</p></li></ul><p>commit 26ecc96e38154b12f13e524a59258ceaf12a1ec8<br>Merge: b1f2507 f8d7347<br>Author: yuanph <a href="mailto:&#x79;&#x75;&#97;&#x6e;&#112;&#104;&#64;&#117;&#x73;&#x68;&#x61;&#114;&#101;&#105;&#116;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#x79;&#x75;&#97;&#x6e;&#112;&#104;&#64;&#117;&#x73;&#x68;&#x61;&#114;&#101;&#105;&#116;&#46;&#99;&#111;&#109;</a><br>Date:   Tue Oct 11 16:11:45 2016 +0800</p><pre><code>merge experimental branch</code></pre><pre><code>* `git log --pretty=full````sh$ git log --pretty=fullcommit 042406fc594369852da2a708d3c1711d0e06f96eAuthor: yuanph &lt;yuanph@ushareit.com&gt;Commit: yuanph &lt;yuanph@ushareit.com&gt;    update file3 on mastercommit 26ecc96e38154b12f13e524a59258ceaf12a1ec8Merge: b1f2507 f8d7347Author: yuanph &lt;yuanph@ushareit.com&gt;Commit: yuanph &lt;yuanph@ushareit.com&gt;    merge experimental branch</code></pre><ul><li><code>git log --pretty=fuller</code><br><code>`</code>sh</li></ul><p>$ git log –pretty=fuller<br>commit 042406fc594369852da2a708d3c1711d0e06f96e<br>Author:     yuanph <a href="mailto:&#121;&#x75;&#x61;&#x6e;&#x70;&#x68;&#64;&#117;&#115;&#104;&#97;&#114;&#x65;&#x69;&#x74;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#121;&#x75;&#x61;&#x6e;&#x70;&#x68;&#64;&#117;&#115;&#104;&#97;&#114;&#x65;&#x69;&#x74;&#x2e;&#99;&#111;&#109;</a><br>AuthorDate: Tue Oct 11 16:14:03 2016 +0800<br>Commit:     yuanph <a href="mailto:&#121;&#117;&#x61;&#x6e;&#112;&#x68;&#64;&#117;&#115;&#104;&#x61;&#114;&#101;&#x69;&#116;&#x2e;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#121;&#117;&#x61;&#x6e;&#112;&#x68;&#64;&#117;&#115;&#104;&#x61;&#114;&#101;&#x69;&#116;&#x2e;&#99;&#x6f;&#109;</a><br>CommitDate: Tue Oct 11 16:14:03 2016 +0800</p><pre><code>update file3 on master</code></pre><p>commit 26ecc96e38154b12f13e524a59258ceaf12a1ec8<br>Merge: b1f2507 f8d7347<br>Author:     yuanph <a href="mailto:&#x79;&#x75;&#x61;&#110;&#x70;&#x68;&#64;&#x75;&#x73;&#x68;&#x61;&#x72;&#101;&#x69;&#116;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x79;&#x75;&#x61;&#110;&#x70;&#x68;&#64;&#x75;&#x73;&#x68;&#x61;&#x72;&#101;&#x69;&#116;&#x2e;&#x63;&#111;&#x6d;</a><br>AuthorDate: Tue Oct 11 16:11:45 2016 +0800<br>Commit:     yuanph <a href="mailto:&#x79;&#x75;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#104;&#97;&#114;&#101;&#x69;&#x74;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x79;&#x75;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#104;&#97;&#114;&#101;&#x69;&#x74;&#x2e;&#x63;&#111;&#x6d;</a><br>CommitDate: Tue Oct 11 16:11:45 2016 +0800</p><pre><code>merge experimental branch</code></pre><pre><code>* `git log --pretty=email````sh$ git log --pretty=emailFrom 042406fc594369852da2a708d3c1711d0e06f96e Mon Sep 17 00:00:00 2001From: yuanph &lt;yuanph@ushareit.com&gt;Date: Tue, 11 Oct 2016 16:14:03 +0800Subject: [PATCH] update file3 on masterFrom 26ecc96e38154b12f13e524a59258ceaf12a1ec8 Mon Sep 17 00:00:00 2001From: yuanph &lt;yuanph@ushareit.com&gt;Date: Tue, 11 Oct 2016 16:11:45 +0800Subject: [PATCH] merge experimental branch</code></pre><ul><li><p><code>git log --pretty=raw</code><br><code>`</code>sh<br>$ git log –pretty=raw<br>commit 042406fc594369852da2a708d3c1711d0e06f96e<br>tree f69c2548cf938330507318e36b3e4f72b26a7e69<br>parent 26ecc96e38154b12f13e524a59258ceaf12a1ec8<br>author yuanph <a href="mailto:&#x79;&#x75;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#104;&#97;&#114;&#101;&#x69;&#x74;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x79;&#x75;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#104;&#97;&#114;&#101;&#x69;&#x74;&#46;&#x63;&#111;&#109;</a> 1476173643 +0800<br>committer yuanph <a href="mailto:&#x79;&#117;&#x61;&#x6e;&#x70;&#x68;&#x40;&#117;&#115;&#x68;&#x61;&#x72;&#101;&#105;&#116;&#x2e;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x79;&#117;&#x61;&#x6e;&#x70;&#x68;&#x40;&#117;&#115;&#x68;&#x61;&#x72;&#101;&#105;&#116;&#x2e;&#x63;&#111;&#x6d;</a> 1476173643 +0800</p><p>  update file3 on master</p></li></ul><p>commit 26ecc96e38154b12f13e524a59258ceaf12a1ec8<br>tree 6fe01742a9fc7b236e446a18a6e0171ebe106e19<br>parent b1f2507784fb22ea6e6fcbe94fe3c0f5deafc8e4<br>parent f8d734757042dc5b92f6f1ea5a8cff828c339ef5<br>author yuanph <a href="mailto:&#121;&#117;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#x68;&#97;&#114;&#x65;&#105;&#116;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#121;&#117;&#x61;&#x6e;&#x70;&#104;&#64;&#x75;&#x73;&#x68;&#97;&#114;&#x65;&#105;&#116;&#46;&#99;&#x6f;&#x6d;</a> 1476173505 +0800<br>committer yuanph <a href="mailto:&#x79;&#x75;&#97;&#x6e;&#x70;&#104;&#64;&#117;&#x73;&#x68;&#x61;&#x72;&#101;&#105;&#x74;&#x2e;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x79;&#x75;&#97;&#x6e;&#x70;&#104;&#64;&#117;&#x73;&#x68;&#x61;&#x72;&#101;&#105;&#x74;&#x2e;&#x63;&#x6f;&#x6d;</a> 1476173505 +0800</p><pre><code>merge experimental branch</code></pre><pre><code>* `--graph` 选项可以可视化你的提交图(commit graph)，会用ASCII字符来画出一个很漂亮的提交历史(commit history)线：```sh$ git log --graph --pretty=oneline* 042406fc594369852da2a708d3c1711d0e06f96e update file3 on master*   26ecc96e38154b12f13e524a59258ceaf12a1ec8 merge experimental branch|\  | * f8d734757042dc5b92f6f1ea5a8cff828c339ef5 update file1* | b1f2507784fb22ea6e6fcbe94fe3c0f5deafc8e4  update file2 on master|/  * ebf80c4a15490f3356f4fd20d602de195bb9841f add file4* 58886962819614df227fc19cfb9148cb286c1865 add modify* cabcbbf371f41559e6fefdd4dbc8bc057d1f19e0 add yet cached content* 2a5cf798589e67b6cc7e6ba26a042e9523b5cd05 add three files</code></pre><h2 id="日志排序"><a href="#日志排序" class="headerlink" title="日志排序"></a>日志排序</h2><p>日志记录可以按不同的顺序来显示。如果你要指定一个特定的顺序，可以为git log命令添加顺序参数。<br>按默认情况，提交会按逆时间顺序显示，可以指定<code>--topo-order</code>参数，让提交按拓扑顺序来显示(就是子提交在它们的父提交前显示):</p><pre><code class="sh">$ git log --pretty=format:&#39;%h:%s&#39; --topo-order --graph</code></pre><p>展示效果：</p><pre><code class="sh">* 042406f:update file3 on master*   26ecc96:merge experimental branch|\  | * f8d7347:update file1* | b1f2507: update file2 on master|/  * ebf80c4:add file4* 5888696:add modify* cabcbbf:add yet cached content* 2a5cf79:add three files</code></pre><blockquote><p>你也可以用 –reverse参数来逆向显示所有提交日志。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English-UNIT4</title>
      <link href="/2016/10/08/English-Level2-UNIT4/"/>
      <url>/2016/10/08/English-Level2-UNIT4/</url>
      
        <content type="html"><![CDATA[<h1 id="人生事件"><a href="#人生事件" class="headerlink" title="人生事件"></a>人生事件</h1><h2 id="一生中的大事"><a href="#一生中的大事" class="headerlink" title="一生中的大事"></a>一生中的大事</h2><p>请用这些词来谈谈一生中的大事</p><table><thead><tr><th style="text-align:left">动词</th><th style="text-align:left">名词</th></tr></thead><tbody><tr><td style="text-align:left">be born    出生</td><td style="text-align:left">birth    出生</td></tr><tr><td style="text-align:left">graduate    毕业</td><td style="text-align:left">graduation    毕业</td></tr><tr><td style="text-align:left">marry    结婚</td><td style="text-align:left">marriage    婚姻</td></tr><tr><td style="text-align:left">get promoted    升职</td><td style="text-align:left">promotion    升职</td></tr><tr><td style="text-align:left">retire     退休</td><td style="text-align:left">retirement    退休</td></tr><tr><td style="text-align:left">die    去世</td><td style="text-align:left">death     死亡</td></tr></tbody></table><p>Graduate 也可用作名词，意思是刚刚大学毕业的毕业生。</p><p>其中三个单词具有形容词形式。</p><pre><code>形容词  married    已婚  retired      退休的  dead     过世了</code></pre><h2 id="用于人生事件的过去时动词"><a href="#用于人生事件的过去时动词" class="headerlink" title="用于人生事件的过去时动词"></a>用于人生事件的过去时动词</h2><p>一生中的大事的动词的过去式</p><ul><li>请用这些规则的 <strong>-ed</strong> 动词的过去式来谈谈一生中的大事。</li></ul><pre><code>graduate - graduated     graduate - graduated （毕业）retire - retired           retire - retired （退休）die - died                 die - died （逝世）</code></pre><ul><li>这里有些您可以使用的不规则的动词过去式</li></ul><pre><code>be born - was/were born     be born - was/were born （出生）say my first word - said my first word    say my first word - said my first word（说出我的第一句话）grow up - grew up    grow up - grew up （长大）become an adult - became an adult      become an adult - became an adult （成为成年人）get a job - got a job    get a job - got a job （找到一份工作）</code></pre><ul><li>请用was/were + not + 动词原形, or did + not + 动词原形造一个过去时态的否定句。</li></ul><pre><code>I wasn&#39;t born in a hospital.    我不是在医院出生的。I didn&#39;t get promoted.    我并没有得升职。</code></pre><ul><li>请用was/were + 主语 + 动词原形, 或 did + 主语 + 动词原形造一个过去时态的疑问句。</li></ul><pre><code>A: Where were you born?B: I was born in Seoul.     您是在哪出生的?我出生于首尔。A: Where did you grow up?B: I grew up in Belgium.    您在哪儿长大?我在比利时长大。</code></pre><h1 id="用-‘Get’-表述人生事件"><a href="#用-‘Get’-表述人生事件" class="headerlink" title="用 ‘Get’ 表述人生事件"></a>用 ‘Get’ 表述人生事件</h1><h2 id="一生的大事中所用到的’Get’"><a href="#一生的大事中所用到的’Get’" class="headerlink" title="一生的大事中所用到的’Get’"></a>一生的大事中所用到的’Get’</h2><ul><li>请用get 与这些词语谈谈关系的里程碑。</li></ul><pre><code>get married    结婚get pregnant    怀孕get divorced    离婚get over a relationship    走出一段感情</code></pre><ul><li>请用 get 与这些词谈谈生活及事业的里程碑。</li></ul><pre><code>get a degree    获得学位get a job    得到一份工作get promoted    升职get fired    被解雇get a driver&#39;s license    考取驾照get old    变老</code></pre><h2 id="更多人生事件"><a href="#更多人生事件" class="headerlink" title="更多人生事件"></a>更多人生事件</h2><p>人一生中总会发生各种大事。想想自己人生中发生的大事。这些事情发生了吗？什么时间发生的？如果没有，你认为什么时候会发生？</p><p>I first <strong>traveled abroad</strong> when I was 15.    （15 岁时，我第一次出国旅行。）</p><p>I <strong>got my first car</strong> when I was 17.      （17 岁时，我买了第一辆车。）</p><p>I <strong>moved out</strong> of my parents’ house when I was 18.    （18 岁时，我搬出了父母的房子。）</p><p>I <strong>moved away</strong> from home when I was 18.       （18 岁时，我离开了家乡。）</p><p>I <strong>got my first apartment</strong> with my best friend.     （我和我的好朋友找到了我的第一间公寓。）            </p><p>I <strong>met the love of my life</strong> when I was 22.    （22 岁时，我遇到了一生中的挚爱。）</p><p>We <strong>fell in love</strong> and <strong>got married</strong>.    （我们相恋，然后结婚。）</p><p>We <strong>had our first child</strong> when I was 25.    （在我 25 岁时，我们有了第一个孩子。）</p><p>We <strong>had our first grandchild</strong> when I was 46.    （在我 46 岁时，我们有了第一个孙儿。）</p><h2 id="after’-引导的从句"><a href="#after’-引导的从句" class="headerlink" title="after’ 引导的从句"></a>after’ 引导的从句</h2><p>与 ‘when’ 引导的从句一样，由 ‘after’ 引导的从句也为句子补充有关时间的信息。</p><p><strong>After I moved out of my parents’ house,</strong> I got my first apartment.    （在搬出父母的房子后，我找到了自己的第一间公寓。）<br>I got my first apartment <strong>after I moved out of my parents’ house</strong>.    （在搬出父母的房子后，我找到了自己的第一间公寓。）</p><p>与 ‘when’ 引导的从句一样，如果句子以 ‘after’ 引导的从句起句，则用逗号 (,) 与句子其余部分分隔。如 ‘after’ 引导的从句位于结尾，则无需使用逗号。</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="与采访相关的词汇"><a href="#与采访相关的词汇" class="headerlink" title="与采访相关的词汇"></a>与采访相关的词汇</h2><p>以下是一些谈论工作面试的有用单词。</p><p>Can you send me your <strong>resume</strong>?    你可以把你的简历发给我吗？<br>There are many <strong>candidates</strong> for this job.    申请该职位的求职者有很多。<br>I’m very interested in the <strong>position</strong>.    我对这一职位很感兴趣。<br>I <strong>have an appointment</strong> to talk to the manager.    我和那位经理约好了谈一谈。<br>I <strong>have an interview</strong> on Thursday.    我星期四有一个面试。<br>This is <strong>a really good opportunity</strong> for me.    对我来说，这是一个很好的机会。</p><p>在面试中，你可能会被问及以下事情。</p><p>Do you have any <strong>teaching experience</strong>?    你有过教学经验吗？<br>Could you <strong>talk about</strong> your education?    你可以谈谈你的教育背景吗？<br>What are your <strong>strengths</strong>?    你有什么优点？<br>What is your <strong>greatest weakness</strong>?    你最大的缺点是什么？<br>Tell me about your <strong>work background</strong>.    跟我说说你的工作经历。</p><p>在一次采访结尾处，你可能听到以下内容。</p><p>Could you come back <strong>for a second interview</strong>?    你可以再来参加第二次面试吗？<br>I’d like to <strong>introduce you to</strong> the other people on the team.    我要把你介绍给团队中的其他人认识。<br>How is February 1st <strong>as a start date</strong>?    从二月一日开始怎么样？</p><h2 id="面试相关的表达"><a href="#面试相关的表达" class="headerlink" title="面试相关的表达"></a>面试相关的表达</h2><ul><li>当你到达面试地点时，先表明你来的原因。然后，感谢面试人的接见。</li></ul><p>I have a 3 o’clock job interview with Ken Smith.     我三点钟和 Ken Smith 有一个工作面试。<br>Thank you for seeing me, Mr. Smith.    谢谢您见我，Smith 先生。<br>Thank you for the opportunity to meet with you.    谢谢您给我见您的机会。</p><ul><li>面试人将就你的简历提出一些后续问题。请相应回答。</li></ul><p>Interviewer: I see that you got your MBA from The Wharton School.    我看到你获得了沃顿商学院的 MBA 学位。<br>Candidate: Yes, it was a wonderful program.    是的，这是一个非常好的项目。</p><p>Interviewer: I see that you’re currently working at DBX Systems. Why are you thinking of leaving?    （我看到，你目前在 DBX Systems 公司就职。为什么想离开？）<br>Candidate: Well, to be honest, the work isn’t very challenging.    （哦，坦白来讲，这份工作并不难。）</p><ul><li>谈论你的缺点时，一个策略是从正面角度入手，比如工作太拼命，让缺点不成为缺点。</li></ul><p>Interviewer: What do you think are some of your strengths and weaknesses?<br>（你认为你有什么优点和缺点？）</p><p>Candidate: Well, I am a very hard worker, but sometimes I work too much.<br>（嗯，我工作非常勤奋，但有时候工作太拼命。）</p><p>如果面试人认为你是潜在的人选，他或她可能会讲述之后的步骤，甚至询问你的入职时间。</p><p>Interviewer: I’d like you to talk with some other members of the team. Also, are you OK with the start date?<br>（我想让你和团队的其他成员谈谈。还有，入职时间你觉得可以吗？）     </p><p>Candidate: That sounds great and, yes, the start date works for me. Thank you again for meeting with me.<br>（听起来不错，可以，入职时间我觉得没问题。再次感谢您与我见面。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML 学习 第三天</title>
      <link href="/2016/10/01/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
      <url>/2016/10/01/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天要学习的XML的验证，验证器及流览器 ,初略DOM<br><a id="more"></a></p><h1 id="XML-验证"><a href="#XML-验证" class="headerlink" title="XML 验证"></a>XML 验证</h1><blockquote><p>拥有正确语法的 XML 被称为“形式良好”的 XML.<br>  通过 DTD 验证的 XML 是“合法”的 XML.</p></blockquote><h2 id="形式良好的-XML-文档"><a href="#形式良好的-XML-文档" class="headerlink" title="形式良好的 XML 文档"></a>形式良好的 XML 文档</h2><p>  “形式良好”或“结构良好”的 XML 文档拥有正确的语法。<br>  “形式良好”（Well Formed）的 XML 文档会遵守前面介绍过的 XML 语法规则：</p><pre><code>* XML 文档必须有根元素* XML 文档必须有关闭标签* XML 标签对大小写敏感* XML 元素必须被正确的嵌套* XML 属性必须加引号</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;  &lt;date&gt;2016-10-1&lt;/date&gt;  &lt;weather&gt;sunny &lt;/weather&gt;  &lt;title&gt;Learning xml&lt;/title&gt;  &lt;body&gt;xml is very funny and easy&lt;/body&gt;&lt;/note&gt;</code></pre><h2 id="验证XML文档"><a href="#验证XML文档" class="headerlink" title="验证XML文档"></a>验证XML文档</h2><p>合法的 XML 文档是“形式良好”的 XML 文档，同样遵守文档类型定义 (DTD) 的语法规则：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt;  &lt;date&gt;2016-10-1&lt;/date&gt;  &lt;weather&gt;sunny &lt;/weather&gt;  &lt;title&gt;Learning xml&lt;/title&gt;  &lt;body&gt;xml is very funny and easy&lt;/body&gt;&lt;/note&gt;</code></pre><p>DOCTYPE 声明是对外部 DTD 文件的引用。下面的段落展示了这个文件的内容</p><ul><li><p>XML DTD<br>DTD 的作用是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：</p><pre><code class="xml">&lt;!DOCTYPE note[&lt;!ELEMENT note(date,weather,title,body)&gt;&lt;!ELEMENT date (#PCDATA)&gt;&lt;!ELEMENT weather (#PCDATA)&gt;&lt;!ELEMENT title (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;</code></pre><p><a href="http://www.w3school.com.cn/dtd/index.asp" target="_blank" rel="noopener">DTD教程</a></p></li><li><p>XML Schema<br>W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema：<br><code>`</code>xml<br>&lt;xs:element name=”note”&gt;<br><a href="xs:complexType" target="_blank" rel="noopener">xs:complexType</a><br><a href="xs:sequence" target="_blank" rel="noopener">xs:sequence</a><br>  &lt;xs:element name=”date”      type=”xs:string”/&gt;<br>  &lt;xs:element name=”weather”    type=”xs:string”/&gt;<br>  &lt;xs:element name=”title” type=”xs:string”/&gt;<br>  &lt;xs:element name=”body”    type=”xs:string”/&gt;<br>&lt;/xs:sequence&gt;<br>&lt;/xs:complexType&gt;</p></li></ul><p>&lt;/xs:element&gt;</p><p><code>`</code><br><a href="http://www.w3school.com.cn/schema/index.asp" target="_blank" rel="noopener">XML Schema 教程</a></p><h1 id="XML-验证器"><a href="#XML-验证器" class="headerlink" title="XML 验证器"></a>XML 验证器</h1><h2 id="XML-错误会终止您的程序"><a href="#XML-错误会终止您的程序" class="headerlink" title="XML 错误会终止您的程序"></a>XML 错误会终止您的程序</h2><p>XML 文档中的错误会终止你的 XML 程序。<br>W3C 的 XML 规范声明：如果 XML 文档存在错误，那么程序就不应当继续处理这个文档。理由是，XML 软件应当轻巧，快速，具有良好的兼容性。</p><p>如果使用 HTML，创建包含大量错误的文档是有可能的（比如你忘记了结束标签）。其中一个主要的原因是 HTML 浏览器相当臃肿，兼容性也很差，并且它们有自己的方式来确定当发现错误时文档应该显示为什么样子。<br>注释：只有在 Internet Explorer 中，可以根据 DTD 来验证 XML。Firefox, Mozilla, Netscape 以及 Opera 做不到这一点。</p><h1 id="XML-浏览器支持"><a href="#XML-浏览器支持" class="headerlink" title="XML 浏览器支持"></a>XML 浏览器支持</h1><p>  几乎所有的主流浏览器均支持 XML 和 XSLT。</p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM （Document Object Model，文档对象模型）定义了访问和操作文档的标准方法。</p><h2 id="XML-DOM"><a href="#XML-DOM" class="headerlink" title="XML DOM"></a>XML DOM</h2><p>XML DOM (XML Document Object Model) 定义了访问和操作 XML 文档的标准方法。<br>DOM 把 XML 文档作为树结构来查看。能够通过 DOM 树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。<br><a href="http://www.w3school.com.cn/xmldom/index.asp" target="_blank" rel="noopener">XML DOM 教程</a></p><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><p>HTML DOM (HTML Document Object Model) 定义了访问和操作 HTML 文档的标准方法。<br><a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank" rel="noopener"> HTML DOM 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML 学习 第二天 </title>
      <link href="/2016/10/01/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2016/10/01/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天我们主要学习XML的语法规,元素，属性<br><a id="more"></a></p><h1 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h1><ul><li>所有XML元素都必须有关闭标签<br>&emsp;在hmtl中经常会看到没有关闭标签的元素<pre><code class="HTML">&lt;p&gt;This is a paragraph&lt;p&gt;This is a another paragraph</code></pre>&emsp;在XML中，省略关闭标签是非法的。所有元素都必须有关闭标签<pre><code class="XML">&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is a another paragraph&lt;/p&gt;</code></pre></li><li><p>XML标签对大小写敏感<br>&emsp;XML元素使用XML标签进行定义。<br>XML 标签对大小写敏感。在 XML 中，标签 <letter> 与标签 <letter> 是不同的。</letter></letter></p><pre><code class="XML">&lt;Message&gt;This is a error&lt;/message&gt;&lt;message&gt;This is right&lt;/message&gt;</code></pre><blockquote><p>注释：打开标签和关闭标签通常被称为开始标签和结束标签。不论您喜欢哪种术语，它们的概念都是相同的。</p></blockquote></li><li><p>XML 必须正确地嵌套<br>&emsp;在 HTML 中，常会看到没有正确嵌套的元素：</p><pre><code class="html">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</code></pre><p>&emsp;在 XML 中，所有元素都必须彼此正确地嵌套：</p><pre><code class="XML">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</code></pre><p>&emsp;在上例中，正确嵌套的意思是：由于 <i> 元素是在 <b> 元素内打开的，那么它必须在 <b> 元素内关闭。</b></b></i></p></li></ul><ul><li>XML 文档必须有根元素<br>&emsp;XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。<pre><code class="xml">&lt;root&gt;&lt;child&gt;  &lt;subchild&gt;.....&lt;/subchild&gt;&lt;/child&gt;&lt;/root&gt;</code></pre></li><li><p>XML 的属性值须加引号<br>&emsp;与 HTML 类似，XML 也可拥有属性（名称/值的对）。<br>在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：</p><pre><code class="xml">&lt;note date=08/08/2008&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;</code></pre><pre><code class="xml">&lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt;</code></pre><p>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</p></li><li><p>实体引用<br>在 XML 中，一些字符拥有特殊的意义。<br>在 XML 中，有 5 个预定义的实体引用：</p></li></ul><table><thead><tr><th style="text-align:left">实体引用</th><th style="text-align:left">字符</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td style="text-align:left">&lt;</td></tr><tr><td style="text-align:left">&glt;</td><td style="text-align:left">&gt;</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">&amp;</td></tr><tr><td style="text-align:left">&amp;apos</td><td style="text-align:left">‘</td></tr><tr><td style="text-align:left">&amp;quot</td><td style="text-align:left">“</td></tr></tbody></table><blockquote><p>注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。</p></blockquote><ul><li>XML 中的注释<br>&emsp;在 XML 中编写注释的语法与 HTML 的语法很相似：<pre><code class="XML">&lt;!-- This is a comment --&gt;</code></pre></li><li><p>在 XML 中，空格会被保留<br>&emsp;HTML 会把多个连续的空格字符裁减（合并）为一个：<br>在 XML 中，文档中的空格不会被删节。</p></li><li><p>XML 以 LF 存储换行<br>&emsp;在 Windows 应用程序中，换行通常以一对字符来存储：回车符 (CR) 和换行符 (LF)。这对字符与打字机设置新行的动作有相似之处。在 Unix 应用程序中，新行以 LF 字符存储。而 Macintosh 应用程序使用 CR 来存储新行。</p></li></ul><h1 id="XML-元素"><a href="#XML-元素" class="headerlink" title="XML 元素"></a>XML 元素</h1><h2 id="什么是-XML-元素？"><a href="#什么是-XML-元素？" class="headerlink" title="什么是 XML 元素？"></a>什么是 XML 元素？</h2><p>&emsp;XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。<br>元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;bookstore&gt;  &lt;book category=&#39;child&#39;&gt;    &lt;title&gt;Harry Potter&lt;/title&gt;    &lt;author&gt; J K. Rowling&lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;29.9&lt;/price&gt;  &lt;/book&gt;  &lt;book category=&#39;WEB&#39;&gt;    &lt;title&gt;Learning xml&lt;/title&gt;    &lt;author&gt; Erik T.ray &lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;29.9&lt;/price&gt;  &lt;/book&gt;&lt;/bookstore&gt;</code></pre><h2 id="XML-命名规则"><a href="#XML-命名规则" class="headerlink" title="XML 命名规则"></a>XML 命名规则</h2><p>XML 元素必须遵循以下命名规则：</p><pre><code>* 名称可以含字母、数字以及其他的字符* 名称不能以数字或者标点符号开始* 名称不能以字符 “xml”（或者 XML、Xml）开始* 名称不能包含空格</code></pre><p>可使用任何名称，没有保留的字词。</p><h2 id="最佳命名习惯"><a href="#最佳命名习惯" class="headerlink" title="最佳命名习惯"></a>最佳命名习惯</h2><ul><li><p>使名称具有描述性。使用下划线的名称也很不错。</p></li><li><p>名称应当比较简短，比如：&lt;book_title&gt;，而不是：&lt;the_title_of_the_book&gt;。</p></li><li><p>避免 “-“ 字符。如果您按照这样的方式进行命名：”first-name”，一些软件会认为你需要提取第一个单词。</p></li><li><p>避免 “.” 字符。如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。</p></li><li><p>避免 “:” 字符。冒号会被转换为命名空间来使用（稍后介绍）。</p></li></ul><p>&emsp;XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的名称规则来命名 XML 文档中的元素。</p><p>&emsp;非英语的字母比如 éòá 也是合法的 XML 元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题。</p><h2 id="XML-元素是可扩展的"><a href="#XML-元素是可扩展的" class="headerlink" title="XML 元素是可扩展的"></a>XML 元素是可扩展的</h2><p>  XML 元素是可扩展，以携带更多的信息。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;  &lt;to&gt;George&lt;/to&gt;  &lt;from&gt;John&lt;/from&gt;  &lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><p>  增加字段</p><pre><code class="xml">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;note&gt;      &lt;date&gt;2008-08-08&lt;/date&gt;      &lt;to&gt;George&lt;/to&gt;      &lt;from&gt;John&lt;/from&gt;      &lt;heading&gt;Reminder&lt;/heading&gt;      &lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;&lt;/note&gt;</code></pre><h1 id="XML-属性"><a href="#XML-属性" class="headerlink" title="XML 属性"></a>XML 属性</h1><blockquote><p>XML 元素可以在开始标签中包含属性，类似 HTML。<br>属性 (Attribute) 提供关于元素的额外（附加）信息。</p></blockquote><h2 id="XML属性"><a href="#XML属性" class="headerlink" title="XML属性"></a>XML属性</h2><p> 从 HTML，你会回忆起这个：<code>&lt;img src=&quot;computer.gif&quot;&gt;</code>。<code>&quot;src&quot;</code> 属性提供有关 <code>&lt;img&gt;</code>元素的额外信息。<br> 在 HTML 中（以及在 XML 中），属性提供有关元素的额外信息：</p><pre><code class="HTML"> &lt;img src=&quot;computer.png&quot;&gt; &lt;a href=&quot;index.html&quot;&gt;</code></pre><p> 属性通常提供不属于数据组成部分的信息。在下面的例子中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：</p><pre><code class="XML"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;file type=&#39;gif&#39;&gt;computer.gif&lt;/file&gt;</code></pre><ul><li>XML 属性必须加引号<br>属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;person sex=&#39;man&#39;&gt;tom&lt;/person&gt;&lt;!-- 下面是一样的效果 --&gt;&lt;!-- &lt;person sex=&quot;man&quot;&gt;tom&lt;/person&gt; --&gt;</code></pre><strong>注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：</strong></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;gangster name=&#39;George &quot;Shotgun&quot; Ziegler&#39;&gt;&lt;/gangster&gt;&lt;!-- 同样的效果 --&gt;&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;</code></pre><ul><li><p>XML 元素 vs. 属性</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 属性 --&gt;&lt;person sex=&#39;boy&#39;&gt;&lt;firstname&gt; Alan&lt;/firstname&gt;&lt;lastname&gt;Yuan&lt;/lastname&gt;&lt;/person&gt;&lt;!-- 无素 --&gt;&lt;person&gt;&lt;sex&gt;boy&lt;/sex&gt;&lt;firstname&gt;Alan&lt;/firstname&gt;&lt;lastname&gt;Yuan&lt;/lastname&gt;&lt;/person&gt;</code></pre><blockquote><p>没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用子元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用子元素吧。</p></blockquote></li><li><p>避免 XML 属性？</p></li></ul><p>因使用属性而引起的一些问题：</p><pre><code>* 属性无法包含多重的值（元素可以）* 属性无法描述树结构（元素可以）* 属性不易扩展（为未来的变化）* 属性难以阅读和维护</code></pre><p>请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 错误的使用 --&gt;&lt;note day=&quot;08&quot; month=&quot;08&quot; year=&quot;2008&quot;to=&quot;George&quot; from=&quot;John&quot; heading=&quot;Reminder&quot;body=&quot;Don&#39;t forget the meeting!&quot;&gt;&lt;/note&gt;</code></pre><blockquote><p>在此极力向您传递的理念是：元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML 学习 第一天</title>
      <link href="/2016/09/30/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2016/09/30/XML-%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天主要学习下XML的基础概念，以及XML可以用在哪些地方，以及XML是一种怎样的结构。<br><a id="more"></a></p><h1 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h1><h2 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h2><ul><li>XML是可扩展标记语言(EXtensible Markup Language)</li><li>XML是一种标记语言，很类似HTML</li><li>XML的设计宗旨是传输数据，而非显示数据</li><li>XML标签没有被预定义，需要自行定义</li><li>XML 被设计为具有自我描述性</li><li>XML 是W3C的推荐标准</li></ul><h2 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h2><ul><li>XML 不是 HTML 的替代。</li><li>XML 和 HTML 为不同的目的而设计：</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容。</li><li>HTML 被设计用来显示数据，其焦点是数据的外观。</li><li>HTML 旨在显示信息，而 XML 旨在传输信息。</li></ul><h2 id="XML-仅仅是纯文本"><a href="#XML-仅仅是纯文本" class="headerlink" title="XML 仅仅是纯文本"></a>XML 仅仅是纯文本</h2><p>&emsp;XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。<br>不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。</p><h1 id="XML-不是对-HTML-的替代"><a href="#XML-不是对-HTML-的替代" class="headerlink" title="XML 不是对 HTML 的替代"></a>XML 不是对 HTML 的替代</h1><p>&emsp;XML 是对 HTML 的补充。<br>XML 不会替代 HTML，理解这一点很重要。在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。<br>对 XML 最好的描述是：<br>XML 是独立于软件和硬件的信息传输工具。</p><h1 id="XML的用途"><a href="#XML的用途" class="headerlink" title="XML的用途"></a>XML的用途</h1><p>&emsp;XML 应用于 web 开发的许多方面，常用于简化数据的存储和共享。</p><h2 id="XML-把数据从-HTML-分离"><a href="#XML-把数据从-HTML-分离" class="headerlink" title="XML 把数据从 HTML 分离"></a>XML 把数据从 HTML 分离</h2><p>  &emsp;如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。<br>通过 XML，数据能够存储在独立的 XML 文件中。这样你就可以专注于使用 HTML 进行布局和显示，并确保修改底层数据不再需要对 HTML 进行任何的改变。<br>通过使用几行 JavaScript，你就可以读取一个外部 XML 文件，然后更新 HTML 中的数据内容。</p><h2 id="XML-简化数据共享"><a href="#XML-简化数据共享" class="headerlink" title="XML 简化数据共享"></a>XML 简化数据共享</h2><p>&emsp;在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。<br>XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。<br>这让创建不同应用程序可以共享的数据变得更加容易。</p><h2 id="XML-简化数据传输"><a href="#XML-简化数据传输" class="headerlink" title="XML 简化数据传输"></a>XML 简化数据传输</h2><p>&emsp;通过 XML，可以在不兼容的系统之间轻松地交换数据。<br>对开发人员来说，其中一项最费时的挑战一直是在因特网上的不兼容系统之间交换数据。<br>由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</p><h2 id="XML-简化平台的变更"><a href="#XML-简化平台的变更" class="headerlink" title="XML 简化平台的变更"></a>XML 简化平台的变更</h2><p>&emsp;升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。<br>XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新应用程序或新的浏览器。</p><h2 id="XML-使您的数据更有用"><a href="#XML-使您的数据更有用" class="headerlink" title="XML 使您的数据更有用"></a>XML 使您的数据更有用</h2><p>&emsp;由于 XML 独立于硬件、软件以及应用程序，XML 使您的数据更可用，也更有用。<br>不同的应用程序都能够访问您的数据，不仅仅在 HTML 页中，也可以从 XML 数据源中进行访问。<br>通过 XML，您的数据可供各种阅读设备使用（手持的计算机、语音设备、新闻阅读器等），还可以供盲人或其他残障人士使用。</p><h2 id="XML-用于创建新的-Internet-语言"><a href="#XML-用于创建新的-Internet-语言" class="headerlink" title="XML 用于创建新的 Internet 语言"></a>XML 用于创建新的 Internet 语言</h2><p>&emsp;很多新的 Internet 语言是通过 XML 创建的：<br>其中的例子包括：<br>XHTML - 最新的 HTML 版本<br>WSDL - 用于描述可用的 web service<br>WAP 和 WML - 用于手持设备的标记语言<br>RSS - 用于 RSS feed 的语言<br>RDF 和 OWL - 用于描述资源和本体<br>SMIL - 用于描述针针对 web 的多媒体</p><h1 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h1><p>XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。</p><p>##XML 文档形成一种树结构<br>&emsp;XML 文档必须包含根元素。该元素是所有其他元素的父元素。<br>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有元素均可拥有子元素：</p><pre><code class="xml">&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;</code></pre><p>父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。<br>所有元素均可拥有文本内容和属性（类似 HTML 中）。</p>]]></content>
      
      
      <categories>
          
          <category> XML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bs4学习</title>
      <link href="/2016/09/30/bs4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/09/30/bs4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.</p></blockquote><a id="more"></a><p>#bs4 的安装<br>使用系统软件包管理工具brew/pip来安装</p><pre><code class="sh">brew install beautifulsoup4pip install beautifulsoup4</code></pre><p>安装解析器<br>Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml .根据操作系统不同,可以选择下列方法来安装lxml:</p><pre><code class="sh">$ apt-get install Python-lxml$ easy_install lxml$ pip install lxml</code></pre><p>另一个可供选择的解析器是纯Python实现的 html5lib , html5lib的解析方式与浏览器相同,可以选择下列方法来安装html5lib:</p><pre><code class="sh">$ apt-get install Python-html5lib$ easy_install html5lib$ pip install html5lib</code></pre><table><thead><tr><th style="text-align:left">解析器</th><th style="text-align:left">使用方法</th><th style="text-align:left">优势</th><th style="text-align:left">劣势</th></tr></thead><tbody><tr><td style="text-align:left">Python标准库</td><td style="text-align:left">BeautifulSoup(markup, “html.parser”)</td><td style="text-align:left">Python的内置标准库    执行速度适中  文档容错能力强</td><td style="text-align:left">Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td style="text-align:left">lxml HTML 解析器</td><td style="text-align:left">BeautifulSoup(markup, “lxml”)</td><td style="text-align:left">速度快    文档容错能力强</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td style="text-align:left">lxml XML 解析器</td><td style="text-align:left">BeautifulSoup(markup, [“lxml-xml”])  BeautifulSoup(markup, “xml”)</td><td style="text-align:left">速度快  唯一支持XML的解析器</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td style="text-align:left">html5lib</td><td style="text-align:left">BeautifulSoup(markup, “html5lib”)</td><td style="text-align:left">最好的容错性  以浏览器的方式解析文档  生成HTML5格式的文档</td><td style="text-align:left">速度慢  不依赖外部扩展</td></tr></tbody></table><p><strong>推荐使用lxml作为解析器,因为效率更高. 在Python2.7.3之前的版本和Python3中3.2.2之前的版本,必须安装lxml或html5lib, 因为那些Python版本的标准库中内置的HTML解析方法不够稳定.</strong></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.</p><pre><code class="Python">from bs4 import BeautifulSoupsoup = BeautifulSoup(open(&quot;index.html&quot;))soup = BeautifulSoup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;)</code></pre><p>首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码<br>然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档</p><p>示例内容：</p><pre><code class="Python">html_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;</code></pre><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> .</p><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p><strong>Tag 对象与XML或HTML原生文档中的tag相同:</strong></p><pre><code class="Python">soup =BeautifulSoup(&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;,&quot;lxml&quot;)tag = soup.bprint(type(tag)) # &lt;class &#39;bs4.element.Tag&#39;&gt;</code></pre><h3 id="tag中最重要的属性-name和attributes"><a href="#tag中最重要的属性-name和attributes" class="headerlink" title="tag中最重要的属性: name和attributes"></a>tag中最重要的属性: name和attributes</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>每个tag都有自己的名字,通过 .name 来获取:</p><pre><code class="Python">print(tag.name)# b</code></pre><p>如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档:</p><pre><code class="Python">tag.name=&quot;yph&quot;print(tag)# &lt;yph class=&quot;boldest&quot;&gt;Extremely bold&lt;/yph&gt;</code></pre><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>一个tag可能有很多个属性. tag <b class="boldest"> 有一个 “class” 的属性,值为 “boldest” . tag的属性的操作方法与字典相同:</b></p><pre><code class="Python">tag[&#39;class&#39;]# u&#39;boldest&#39;</code></pre><p>也可以直接”点”取属性, 比如: .attrs :</p><pre><code class="Python">tag.attrs# {u&#39;class&#39;: u&#39;boldest&#39;}</code></pre><p>Tag的属性可以被添加,删除或修改. 再说一次, tag的属性操作方法与字典一样</p><pre><code class="Python">tag[&#39;class&#39;]=&#39;tstclass&#39;#添加tag[&#39;id&#39;]=&#39;yph&#39;print(tag) #&lt;yph class=&quot;tstclass&quot; id=&quot;yph&quot;&gt;Extremely bold&lt;/yph&gt;# 删除del  tag[&#39;class&#39;]del  tag[&#39;id&#39;]print(tag) #&lt;yph&gt;Extremely bold&lt;/yph&gt;</code></pre><h4 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h4><p>HTML 4定义了一系列可以包含多个值的属性.在HTML5中移除了一些,却增加更多.最常见的多值的属性是 <code>class</code> (一个tag可以有多个CSS的class). 还有一些属性 <code>rel</code> , <code>rev</code> , <code>accept-charset</code> , <code>headers</code> , <code>accesskey</code> . 在Beautiful Soup中多值属性的返回类型是<code>list</code>:</p><pre><code class="Python">css_soup=BeautifulSoup(&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;,&#39;lxml&#39;)print(css_soup.p[&#39;class&#39;]) #[&#39;body&#39;, &#39;strikeout&#39;]css_soup=BeautifulSoup(&#39;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#39;,&#39;lxml&#39;)print(css_soup.p[&#39;class&#39;]) #[&#39;body&#39;]</code></pre><p> 如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回</p><pre><code class="Python">id_soup=BeautifulSoup(&#39;&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;&#39;,&#39;lxml&#39;)print(id_soup.p[&#39;id&#39;]) # my id</code></pre><p>将tag转换成字符串时,多值属性会合并为一个值</p><pre><code class="Python">rel_soup = BeautifulSoup(&#39;&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;&#39;,&#39;lxml&#39;)print(rel_soup.a[&#39;rel&#39;])  #[&#39;index&#39;]rel_soup.a[&#39;rel&#39;]=[&#39;index&#39;,&#39;contents&#39;]print(rel_soup.p) #&lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;print(rel_soup.a[&#39;rel&#39;]) #[&#39;index&#39;, &#39;contents&#39;]</code></pre><p><strong>如果转换的文档是XML格式,那么tag中不包含多值属性</strong></p><pre><code class="Python">xml_soup = BeautifulSoup(&#39;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#39;, &#39;xml&#39;)print(xml_soup.p[&#39;class&#39;]) #body strikeout</code></pre><h3 id="可以遍历的字符串"><a href="#可以遍历的字符串" class="headerlink" title="可以遍历的字符串"></a>可以遍历的字符串</h3><p>字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串:</p><pre><code class="Python">soup =BeautifulSoup(&#39;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#39;,&quot;lxml&quot;)tag =soup.bprint(tag.string) #Extremely boldprint(type(tag.string)) #&lt;class &#39;bs4.element.NavigableString&#39;&gt;</code></pre><h3 id="注释及特殊字符串"><a href="#注释及特殊字符串" class="headerlink" title="注释及特殊字符串"></a>注释及特殊字符串</h3><p>Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:</p><pre><code class="Python">markup = &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;soup=BeautifulSoup(markup,&#39;html.parser&#39;)comment=soup.b.string# Comment 对象是一个特殊类型的 NavigableString 对象:print(comment) #Hey, buddy. Want to buy a used parser?print(type(comment)) #&lt;class &#39;bs4.element.Comment&#39;&gt;print(soup.b.prettify())</code></pre><h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.<br><strong>注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点</strong></p><p>tag的名字</p><p>操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 <head> 标签,只要用 soup.head :</head></p><pre><code class="Python">soup.head# &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;soup.title# &lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</code></pre><p>通过点取属性的方式只能获得当前名字的第一个tag:</p><pre><code class="Python">soup.a# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</code></pre><h2 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h2><p>tag的 .contents 属性可以将tag的子节点以列表的方式输出:</p><pre><code class="Python">head_tag= soup.headprint(head_tag) #&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;print(head_tag.contents) #&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;] 返回一个列表title_tag= head_tag.contents[0]print(title_tag) #&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;print(title_tag.contents)</code></pre><p>BeautifulSoup 对象本身一定会包含子节点,也就是说<html>标签也是 BeautifulSoup 对象的子节点:<br>字符串没有 .contents 属性,因为字符串没有子节点:</html></p><pre><code class="Python">text = title_tag.contents[0]text.contents# AttributeError: &#39;NavigableString&#39; object has no attribute &#39;contents&#39;</code></pre><p>通过tag的 .children 生成器,可以对tag的子节点进行循环:</p><pre><code class="Python">for child in title_tag.children:    print(child)    # The Dormouse&#39;s story</code></pre><h2 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h2><p>  .contents  和.children 属性仅包含tag的直接子节点.例如 , &lt; head &gt; 标签只有一个直接子节点 &lt; title &gt;<br>  .descendants 属性可以对所有tag的子孙节点进行递归循环  :</p><pre><code class="Python">for child in head_tag.descendants:    print(child)print(soup.html.head.title.string)</code></pre><h2 id="strings-和-stripped-strings"><a href="#strings-和-stripped-strings" class="headerlink" title=".strings 和 stripped_strings"></a>.strings 和 stripped_strings</h2><p>如果tag中包含多个字符串  ,可以使用 .strings 来循环获取:</p><pre><code class="Python">for string in soup.strings:    print(string)</code></pre><p> 输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容:</p><pre><code class="Python">print(&#39;**************************&#39;)for string in soup.stripped_strings:    print(string)</code></pre><h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><p>继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中</p><h3 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h3><p> 通过 .parent 属性来获取某个元素的父节点.</p><pre><code class="Python">title_tag= soup.titleprint(title_tag.parent) #&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt;print(title_tag.string.parent) #&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;</code></pre><h3 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h3><p> 通过元素的 .parents 属性可以递归得到元素的所有父辈节点,</p><pre><code class="Python">link= soup.aprint(link)for parent in link.parents:    if parent is None:        print(parent)    else:        print(parent.name)</code></pre><h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><pre><code class="Python">sibling_soup= BeautifulSoup(&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;,&#39;html.parser&#39;)print(sibling_soup.prettify())print(sibling_soup.b.next_sibling)print(sibling_soup.c.previous_sibling)</code></pre><h4 id="next-siblings-和-previous-siblings"><a href="#next-siblings-和-previous-siblings" class="headerlink" title=".next_siblings 和 .previous_siblings"></a>.next_siblings 和 .previous_siblings</h4><p> 通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出:</p><pre><code class="Python">print(&#39;*********************&#39;)for sibling in soup.a.next_siblings:    print(repr(sibling))print(&#39;*********************&#39;)for sibling in soup.find(id=&quot;link3&quot;).previous_siblings:    print(repr(sibling))</code></pre><h3 id="next-element-和-previous-element"><a href="#next-element-和-previous-element" class="headerlink" title=".next_element 和 .previous_element"></a>.next_element 和 .previous_element</h3><p> .next_element 属性指向解析过程中下一个被解析的对象(字符串或tag),结果可能与 .next_sibling 相同,但通常是不一样的.</p><pre><code class="Python">last_a_tag= soup.find(&#39;a&#39;,id=&#39;link3&#39;)print(last_a_tag)print(last_a_tag.next_element)print(last_a_tag.previous_element)print(last_a_tag.previous_element.next_element)</code></pre><h3 id="next-elements-和-previous-elements"><a href="#next-elements-和-previous-elements" class="headerlink" title=".next_elements 和 .previous_elements"></a>.next_elements 和 .previous_elements</h3><p> 通过 .next_elements 和 .previous_elements 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样:</p><pre><code class="Python">for element in last_a_tag.next_elements:    print(repr(element))</code></pre><h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h2><p> find() 和 find_all() .其它方法的参数和用法类似,请读者举一反三.</p><h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h3><p><code>find_all( name , attrs , recursive , string , **kwargs )</code><br>find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件.</p><ul><li><p>name参数<br>name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉<br>搜索 name 参数的值可以使任一类型的 过滤器 ,字符窜,正则表达式,列表,方法或是 True .</p><pre><code class="Python">print(soup.find_all(&#39;title&#39;))</code></pre></li><li><p>keyword 参数<br>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性.</p></li></ul><pre><code class="Python">print(soup.find_all(id=&#39;link2&#39;))</code></pre><p> 如果传入 href 参数,Beautiful Soup会搜索每个tag的”href”属性:</p><pre><code class="Python">print(soup.find_all(href=re.compile(&#39;elsie&#39;)))</code></pre><p>搜索指定名字的属性时可以使用的参数值包括 字符串 , 正则表达式 , 列表, True .</p><pre><code class="Python">print(soup.find_all(id=True))print(soup.find_all(href=re.compile(&#39;elsie&#39;),id=&#39;link1&#39;))</code></pre><p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:</p><pre><code class="Python">data_soup = BeautifulSoup(&#39;&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;&#39;,&#39;html.parser&#39;)# print(data_soup.find_all( data-foo=&quot;value&quot;))print(data_soup.find_all(attrs={&#39;data-foo&#39;:&#39;value&#39;}))</code></pre><ul><li><p>按CSS搜索</p><p>按照CSS类名搜索tag的功能非常实用,但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag:</p><pre><code class="Python">print(&#39;*********************&#39;)res =soup.find_all(&#39;a&#39;,class_=&#39;sister&#39;)for alinke  in res :  print(alinke)</code></pre><p>class_ 参数同样接受不同类型的 过滤器 ,字符串,正则表达式,方法或 True</p><pre><code class="Python">print(&#39;*********************&#39;)def has_six_characters(css_class):  return css_class is not None and len(css_class) == 6print(soup.find_all(class_ =has_six_characters))</code></pre><p>tag的 class 属性是 多值属性 .按照CSS类名搜索tag时,可以分别搜索tag中的每个CSS类名:<br><code>`</code>Python<br>css_soup = BeautifulSoup(‘</p><p class="body strikeout"></p>‘)<br>css_soup.find_all(“p”, class_=”strikeout”)<p></p><h1 id=""><a href="#" class="headerlink" title="[]"></a>[<p class="body strikeout"></p>]</h1></li></ul><p>css_soup.find_all(“p”, class_=”body”)</p><h1 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[<p class="body strikeout"></p>]</h1><pre><code>* string 参数通过 string 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, string 参数接受 字符串 , 正则表达式 , 列表, True . 看例子:```Pythonsoup.find_all(string=&quot;Elsie&quot;)# [u&#39;Elsie&#39;]soup.find_all(string=[&quot;Tillie&quot;, &quot;Elsie&quot;, &quot;Lacie&quot;])# [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]soup.find_all(string=re.compile(&quot;Dormouse&quot;))[u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;]def is_the_only_string_within_a_tag(s):    &quot;&quot;Return True if this string is the only child of its parent tag.&quot;&quot;    return (s == s.parent.string)soup.find_all(string=is_the_only_string_within_a_tag)# [u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;, u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;, u&#39;...&#39;]</code></pre><p>虽然 string 参数用于搜索字符串,还可以与其它参数混合使用来过滤tag.Beautiful Soup会找到 .string 方法与 string 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的<a>标签:</a></p><p>实例操作：</p><pre><code class="Python">html= &quot;&quot;&quot;&lt;div id=&quot;pages&quot;&gt;    &lt;a href=&quot;/fenlei/15.html&quot;&gt;&amp;lt;&lt;/a&gt;&lt;a class=&quot;curr&quot;&gt;1&lt;/a&gt;&lt;a href=&quot;/fenlei/15_2.html&quot; target=&quot;_self&quot;&gt;2&lt;/a&gt;&lt;a href=&quot;/fenlei/15_3.html&quot; target=&quot;_self&quot;&gt;3&lt;/a&gt;&lt;a href=&quot;/fenlei/15_4.html&quot; target=&quot;_self&quot;&gt;4&lt;/a&gt;&lt;a href=&quot;/fenlei/15_5.html&quot; target=&quot;_self&quot;&gt;5&lt;/a&gt;&lt;a href=&quot;/fenlei/15_6.html&quot; target=&quot;_self&quot;&gt;6&lt;/a&gt;&lt;a href=&quot;/fenlei/15_7.html&quot; target=&quot;_self&quot;&gt;7&lt;/a&gt;&lt;a href=&quot;/fenlei/15_8.html&quot; target=&quot;_self&quot;&gt;8&lt;/a&gt;&lt;a href=&quot;/fenlei/15_2.html&quot;&gt;&amp;gt;&lt;/a&gt;&lt;/div&gt;&quot;&quot;&quot;page_soup= BeautifulSoup(html,&#39;html.parser&#39;)rs =page_soup.find_all(string=&#39;&gt;&#39;)print(rs[0].previous_element.string )print(page_soup.find(string=&#39;&gt;&#39;).previous_element[&#39;href&#39;])print(&#39;*********************&#39;)for element in page_soup.find(string =&#39;&gt;&#39;).previous_element.previous_elements:    print(element)print(&#39;*********************&#39;)for element in page_soup.find(string =&#39;&gt;&#39;).previous_element.previous_siblings:    print(element)next_page_url = page_soup.find(string=&#39;&gt;&#39;).previous_element[&#39;href&#39;]print(next_page_url)print(&#39;*********************&#39;)for child in page_soup.find(id=&quot;pages&quot;).contents:    print(child)print(&#39;*********************&#39;)for child in page_soup.find(id=&quot;pages&quot;).children:    print(child)print(&#39;*********************&#39;)curr = page_soup.find(class_=&#39;curr&#39;)print(curr)</code></pre><ul><li>limit 参数</li></ul><p>find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果.</p><pre><code class="Python">print(page_soup.find_all(&#39;a&#39;,limit=3))</code></pre><ul><li>recursive 参数<br>调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .<br><code>`</code>Python<br>print(page_soup.find_all(‘a’,recursive=True))</li></ul><pre><code>```Python# 以下两方法等价print(page_soup.find_all(&quot;a&quot;))print(&#39;*********************&#39;)print(page_soup(&quot;a&quot;))</code></pre><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p> Beautiful Soup支持大部分的CSS选择器 <a href="http://www.w3.org/TR/CSS2/selector.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/selector.html</a> [6] , 在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag:</p><pre><code class="Python">print(&#39;*********************&#39;)print(soup.select(&#39;body a&#39;))print(page_soup.select(&#39;a&#39;))</code></pre><ul><li>通过tag标签逐层查找:<pre><code class="Python">print(soup.select(&#39;html head title&#39;))</code></pre></li><li>找到某个tag标签下的直接子标签 [6] :<pre><code class="Python">print(soup.select(&#39;head &gt; title&#39;))print(soup.select(&#39;p &gt; a&#39;))print(soup.select(&#39;p &gt; a:nth-of-type(2)&#39;))print(soup.select(&#39;p &gt; #link1&#39;))print(soup.select(&#39;p &gt; a:nth-of-type(3)&#39;))# print(soup.select(&#39;div &gt; a&#39;))</code></pre></li></ul><ul><li>找到兄弟节点标签:</li></ul><pre><code class="Python">print(soup.select(&#39;#link1 ~ .sister&#39;))print(soup.select(&#39;#link1 + .sister&#39;))</code></pre><ul><li><p>通过CSS的类名查找:</p><pre><code class="Python">print(soup.select(&#39;.sister&#39;))print(soup.select(&#39;[class~=sister]&#39;))</code></pre></li><li><p>通过tag的id查找:</p><pre><code class="Python">print(&#39;*********************&#39;)print(soup.select(&#39;#link1&#39;))print(soup.select(&#39;a#link2&#39;))</code></pre></li><li><p>同时用多种CSS选择器查询元素:<br><code>`</code>Python<br>print(‘<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>‘)<br>print(soup.select(‘#link1,#link2’))</p></li></ul><p>print(‘<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>‘)</p><pre><code>* 通过是否存在某个属性来查找:```Pythonprint(soup.select(&#39;a[href]&#39;))</code></pre><ul><li>通过属性的值来查找:<pre><code class="Python">print(soup.select(&#39;a[href=&quot;http://example.com/elsie&quot;]&#39;))print(soup.select(&#39;a[href^=http://example.com]&#39;))print(soup.select(&#39;a[href$=&quot;tillie&quot;]&#39;))print(soup.select(&#39;a[href*=&quot;.com/el&quot;]&#39;))</code></pre></li><li>返回查找到的元素的第一个<pre><code class="Python">print(soup.select_one(&#39;.sister&#39;))</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安装组件时遇到的一些问题</title>
      <link href="/2016/09/27/%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2016/09/27/%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>安装 mpv 终端播放器时遇到的问题<pre><code class="sh">brew install mpv</code></pre>在终端执行上述命令时遇到如下的提示：<br><code>`</code>sh<br>Error: You must <code>brew link lua</code> before mpv can be installed<br>localhost:~ yuanpinghua$ brew link lua<br>Linking /usr/local/Cellar/lua/5.2.4_4…<br>Error: Could not symlink bin/lua<br>Target /usr/local/bin/lua<br>already exists. You may want to remove it:<br>rm ‘/usr/local/bin/lua’</li></ul><p>To force the link and overwrite all conflicting files:<br>  brew link –overwrite lua</p><p>To list all files that would be deleted:<br>  brew link –overwrite –dry-run lua</p><pre><code>解决方案：```shsudo chown -R $(whoami) /usr/local/brew link lua</code></pre><p>执行上述命令会得到如下的提示：</p><pre><code class="sh">Linking /usr/local/Cellar/lua/5.2.4_4... 55 symlinks created</code></pre><p>再次执行:</p><pre><code class="sh">brew install mpv </code></pre><p>这时就可以安装成功了</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python os 模块学习</title>
      <link href="/2016/09/26/Python-os-%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/09/26/Python-os-%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程相关操作"><a href="#线程相关操作" class="headerlink" title="线程相关操作"></a>线程相关操作</h1><ul><li>获取当前线程的ID<pre><code class="python">os.getpid()</code></pre></li><li>获取父线程的ID<pre><code class="Python">os.getppid()</code></pre></li><li>当前线程的用户ID<pre><code class="python">os.getuid()</code></pre></li></ul><h1 id="用户相关操作"><a href="#用户相关操作" class="headerlink" title="用户相关操作"></a>用户相关操作</h1><ul><li>获取当前登录的用户名<pre><code class="python">os.getlogin()</code></pre></li></ul><h1 id="系统环境相关"><a href="#系统环境相关" class="headerlink" title="系统环境相关"></a>系统环境相关</h1>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的系统资源文件路径</title>
      <link href="/2016/09/26/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
      <url>/2016/09/26/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<ol><li><p>系统字体文件路径：</p><pre><code>/Library/Fonts/</code></pre></li><li><p>xcode 证书路径：</p><pre><code>~/Library/MobileDevice/Provisioning Profiles</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>homebrew 的使用写安装</title>
      <link href="/2016/09/23/brew-useMethod/"/>
      <url>/2016/09/23/brew-useMethod/</url>
      
        <content type="html"><![CDATA[<p>简介：<br>  <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">Homebrew</a></p><blockquote><p>Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebre可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。</p></blockquote><p><strong>Homebrew的安装</strong><br>打开终端窗口, 粘贴以下脚本：</p><pre><code class="sh">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p><strong>Homebrew的使用</strong></p><ul><li>安装软件：<pre><code>  brew install softname(软件名)  brew install python3</code></pre></li><li>搜索软件：<pre><code>  brew search softname(软件名)  brew search python3</code></pre></li><li>卸载软件：<pre><code>  brew uninstall softname(软件名)  brew uninstall python3</code></pre></li><li>更新软件：<ul><li>更新所有软件：<pre><code>brew update</code></pre></li><li>更新具体软件：<pre><code>brew upgrade softname(软件名)brew upgrade git</code></pre></li></ul></li><li>显示已安装软件：<pre><code>brew list</code></pre></li><li><p>查看软件信息：</p><pre><code>  brew info/home softname(软件名)  brew info git /brew home git</code></pre><blockquote><p>brew home指令是用浏览器打开官方网页查看软件信息</p></blockquote></li><li><p>查看那些已安装的程序并且需要更新的：</p><pre><code>brew outdated</code></pre></li><li>显示包依赖：<pre><code>brew reps</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 远程推送</title>
      <link href="/2016/09/20/iOS-remotepush/"/>
      <url>/2016/09/20/iOS-remotepush/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-通知分类："><a href="#iOS-通知分类：" class="headerlink" title="iOS 通知分类："></a>iOS 通知分类：</h1><ol><li><p>remote-notification</p><ul><li>silent remote notifications</li></ul><p>iOS 7在推送方面最大的变化就是允许，应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。<br>Remote Notifications 与之前版本的对比可以参考下面两张 Apple 官方的图片便可一目了然。<br><img src="http://docs.jpush.cn/download/attachments/7865069/iOS6+push.jpg?version=1&amp;modificationDate=1384927835000" alt="iOS6"><br><img src="http://docs.jpush.cn/download/attachments/7865069/iOS7.png?version=1&amp;modificationDate=1384927835000" alt="iOS7"><br>如果只携带content-available: 1 不携带任何badge，sound 和消息内容等参数，则可以不打扰用户的情况下进行内容更新等操作即为“Silent Remote Notifications”。<br><img src="http://docs.jpush.cn/download/attachments/7865069/silent.png?version=1&amp;modificationDate=1384932801000" alt="Slient Remote Notifications"></p><blockquote><p>若有<code>content-available: 1</code> 字段并带有任何badge，sound 和消息内容等参数一个或多个，都会在手机端有一个的表现行式（如声单，提示框，badge 并会调用：<code>[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:]</code>方法<br>若只带<code>content-available: 1</code>字段只会调用<code>[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:]</code>,在手机端没有其他的表现。</p></blockquote></li></ol><ol start="2"><li><p>不同版本的通知注册及回调用情况</p><ol><li>iOS8 以前<pre><code class="objc">[[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert)];</code></pre></li><li><p>iOS8~iOS9</p><pre><code class="objc">UIUserNotificationSettings * settings = [UIUserNotificationSettings settingsForTypes:( UIUserNotificationTypeBadge | UIUserNotificationTypeSound | UIUserNotificationTypeAlert)      categories:nil];[[UIApplication sharedApplication] registerUserNotificationSettings:settings];[[UIApplication sharedApplication] registerForRemoteNotifications];</code></pre><ol start="3"><li><p>iOS10</p><pre><code class="objc">// iOS10.0 register remote notification[[UIApplication sharedApplication]registerForRemoteNotifications];[[UNUserNotificationCenter currentNotificationCenter]requestAuthorizationWithOptions:UNAuthorizationOptionAlert|UNAuthorizationOptionBadge|UNAuthorizationOptionSound completionHandler:^(BOOL granted, NSError * _ Nullable error) {if (granted) {   [UNUserNotificationCenter currentNotificationCenter].delegate= self;}}];}</code></pre><blockquote><p>在iOS10，苹果将用户通知相关操作集合在了<code>UserNotifications.framework</code>中，通知的回调用采用代理方式。</p></blockquote></li></ol></li></ol></li></ol><pre><code>    注册通知成功后，Token的获取回调用：    ```objc    - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0){      NSString * strDeviceToken =[[deviceToken description] stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@&quot;&lt; &gt;&quot;]];      NSLog(@&quot;APNS token:%@&quot;, strDeviceToken);    }    ```    注册通知失败的回调用：    ```objc    - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);    ```    接收到通知的回调用处理方法：    iOS10以前：    ```objc    // 接收到远程通知    - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo;    // 接收到本地通知    - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification ；    ```    iOS10的回调：    实现UNUserNotificationCenterDelegate的代理方法：这些代理方法是可选的。    ```objc    // The method will be called on the delegate only if the application is in the foreground. If the method is not implemented or the handler is not called in a timely manner then the notification will not be presented. The application can choose to have the notification presented as a sound, badge, alert and/or in the notification list. This decision should be based on whether the information in the notification is otherwise visible to the user.    - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);    // The method will be called on the delegate when the user responded to the notification by opening the application, dismissing the notification or choosing a UNNotificationAction. The delegate must be set before the application returns from applicationDidFinishLaunching:.    - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0) __TVOS_PROHIBITED{      NSDictionary * userinfo= response.notification.request.content.userInfo;        [self analysisNotification:userinfo];        // TODO:: 如果有用户操作，可获取到对应的动作类型，并进行相关处理、        // 例如            if ([response.notification.request.content.categoryIdentifier isEqualToString:@&quot;replaymessage&quot;]) {       UNTextInputNotificationResponse * tresponse =(UNTextInputNotificationResponse*)response;       NSLog(@&quot;%@&quot;,tresponse.userText);        //        get the user input text to dosomething   }    }    ```</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcode solutions</title>
      <link href="/2016/09/18/xcode-solutions/"/>
      <url>/2016/09/18/xcode-solutions/</url>
      
        <content type="html"><![CDATA[<ol><li><p>屏蔽系统日志<br><code>Xcode8</code>里边 <code>Edit Scheme</code>-&gt; <code>Run</code> -&gt; <code>Arguments</code>, 在<code>Environment Variables</code>里边添加<br><code>OS_ACTIVITY_MODE = Disable</code></p></li><li><p>Xcode8注释快捷键失效注释快捷键 <code>⌘ `</code>+<code></code> / `失效，在终端输入下面的命令，重启系统即可</p><pre><code class="sh">sudo /usr/libexec/xpccachectl</code></pre></li></ol><p><code>__aaa</code></p><ol start="3"><li><p>ios10相机等权限获取时的崩溃<br>出现的提示信息有：</p><pre><code>This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app&#39;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</code></pre><p>意思是没有获取相机的权限，需要添加在plist文件中添加这项权限</p><pre><code class="json">// 相机权限&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;CameraUsageDescription&lt;/string&gt;</code></pre><p>以下是所有权限的相关键值：</p><pre><code class="js">// 蓝牙权限&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; &lt;string&gt;BluetoothPeripheralUsageDescription&lt;/string&gt;// 日历权限 &lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt; &lt;string&gt;CalendarsUsageDescription&lt;/string&gt;// 相机权限 &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;CameraUsageDescription&lt;/string&gt;// 联系人 &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;ContactsUsageDescription&lt;/string&gt;// 健康分享权限 &lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt; &lt;string&gt;HealthShareUsageDescription&lt;/string&gt;// 健康更新权限 &lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt; &lt;string&gt;HealthUpdateUsageDescription&lt;/string&gt;// HomeKit使用权限 &lt;key&gt;NSHomeKitUsageDescription&lt;/key&gt; &lt;string&gt;HomeKitUsageDescription&lt;/string&gt;//  位置一直使用权限 &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;LocationAlwaysUsageDescription&lt;/string&gt;// 使用位置权限 &lt;key&gt;NSLocationUsageDescription&lt;/key&gt; &lt;string&gt;LocationUsageDescription&lt;/string&gt;// 程序运行时使用位置权限 &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;LocationWhenInUseUsageDescription&lt;/string&gt;// 获取appleMusic权限 &lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt; &lt;string&gt;AppleMusicUsageDescription&lt;/string&gt;// 麦克锋使用权限 &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;MicrophoneUsageDescription&lt;/string&gt;// 陀螺仪使用权限 &lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;MotionUsageDescription&lt;/string&gt;// 相册使用权限 &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;PhotoLibraryUsageDescription&lt;/string&gt;// 提醒权限 &lt;key&gt;NSRemindersUsageDescription&lt;/key&gt; &lt;string&gt;RemindersUsageDescription&lt;/string&gt;// Siri 使用权限 &lt;key&gt;NSSiriUsageDescription&lt;/key&gt; &lt;string&gt;SiriUsageDescription&lt;/string&gt;// 语音识别权限 &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt; &lt;string&gt;SpeechRecognitionUsageDescription&lt;/string&gt;// 视频权限 &lt;key&gt;NSVideoSubscriberAccountUsageDescription&lt;/key&gt; &lt;string&gt;VideoSubscriberAccountUsageDescription&lt;/string&gt;// 音乐库权限 &lt;key&gt;kTCCServiceMediaLibrary&lt;/key&gt; &lt;string&gt;CCServiceMediaLibrary&lt;/string&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Xcode8 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 文件处理</title>
      <link href="/2016/09/13/python-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2016/09/13/python-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h1><ol><li>open()语法<br>函数参数<pre><code>open(file, mode=&#39;r&#39;, buffering=None, encoding=None, errors=None, newline=None, closefd=True)</code></pre>参数解析：<br><code>file</code> :文件位置，需要加引号<br><code>mode</code>:文件打开模式，<br><code>buffering</code>:其可取值有0，1，&gt;1三个，0代表buffer关闭（只适用于二进制模式），1代表line buffer（只适用于文本模式），&gt;1表示初始化的buffer大小；<br><code>encoding</code>:表示的是返回的数据采用何种编码，一般采用utf8或者gbk；<br><code>errors</code>:其取值一般有strict，ignore，当取strict的时候，字符编码出现问题的时候，会报错，当取ignore的时候，编码出现问题，程序会忽略而过，继续执行下面的程序。<br><code>newline</code>:可以取的值有 None, \n, \r, ”, ‘\r\n’，用于区分换行符，但是这个参数只对文本模式有效；<br><code>closefd</code>:其取值，是与传入的文件参数有关，默认情况下为True，传入的file参数为文件的文件名，取值为False的时候，file只能是文件描述符，什么是文件描述符，就是一个非负整数，在Unix内核的系统中，打开一个文件，便会返回一个文件描述符。</li></ol><a id="more"></a><p>参数mode的取值：</p><table><thead><tr><th style="text-align:left">Character</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td style="text-align:left">‘r’</td><td style="text-align:left">open for reading (default)</td></tr><tr><td style="text-align:left">‘w’</td><td style="text-align:left">open for writing, truncating the file first</td></tr><tr><td style="text-align:left">‘a’</td><td style="text-align:left">open for writing, appending to the end of the file if it exists</td></tr><tr><td style="text-align:left">‘b’</td><td style="text-align:left">binary mode</td></tr><tr><td style="text-align:left">‘t’</td><td style="text-align:left">text mode (default)</td></tr><tr><td style="text-align:left">‘+’</td><td style="text-align:left">open a disk file for updating (reading and writing)</td></tr><tr><td style="text-align:left">‘U’</td><td style="text-align:left">universal newline mode (for backwards compatibility; should not be used in new code)</td></tr></tbody></table><blockquote><p>r、w、a为打开文件的基本模式，对应着只读、只写、追加模式；<br>b、t、+、U这四个字符，与以上的文件打开模式组合使用，二进制模式，文本模式，读写模式、通用换行符，根据实际情况组合使用</p></blockquote><blockquote><p>常见的mode取值组合<br>r或rt 默认模式，文本模式读<br>rb   二进制文件</p></blockquote><blockquote><p>w或wt 文本模式写，打开前文件存储被清空<br>wb  二进制写，文件存储同样被清空</p></blockquote><blockquote><p>a  追加模式，只能写在文件末尾<br>a+ 可读写模式，写只能写在文件末尾</p></blockquote><blockquote><p>w+ 可读写，与a+的区别是要清空文件内容<br>r+ 可读写，与a+的区别是可以写到文件任何位置</p></blockquote><h1 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h1><p>1.使用 read() 方法一次性读取整个文件。</p><pre><code class="python">  with open(&#39;text.txt&#39;)as file:    file.read()</code></pre><blockquote><p>read(size) 有一个可选的参数 size，用于指定字符串长度。如果没有指定 size 或者指定为负数，就会读取并返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 size 读取和返回数据。</p></blockquote><ol start="2"><li>readline() 能帮助你每次读取文件的一行<pre><code class="python">with open(&#39;txt.txt&#39;) as file:file.readline()</code></pre></li><li>使用 readlines() 方法读取所有行到一个列表中<br><code>`</code>python<br>with open(‘txt.txt’) as file:<br>file.readlines()</li></ol><pre><code>4. 使用write()方法写入数据```pythonwith open(&#39;txt.txt&#39;,&#39;w&#39;) as writer:  writer.writer(&quot;hello ,welcome the python world&quot;)</code></pre><ol start="5"><li><p>使用writelines()写入多行</p><pre><code class="python">with open(&#39;txt.txt&#39;,&#39;w+&#39;) as writer: writer.writelines([&#39;hello,python&#39;,&#39;hello,c++&#39;,&#39;hello objective-c&#39;]) #这样不会换行，在一行中写入with open(&#39;txt.txt&#39;,&#39;w+&#39;) as write: writer.writelines(&#39;\n&#39;.join( [&#39;hello,python&#39;, &#39;hello,c++&#39;, &#39;hello objective-c&#39;] ))  #这样可以达到换行效果with open(&#39;txt.txt&#39;,&#39;w+&#39;) as writer: for line in [&#39;hello,python&#39;, &#39;hello,c++&#39;, &#39;hello objective-c&#39;]:   writer.write(line)   writer.write(&#39;\n&#39;)  #这样也可以达到换行的效果</code></pre></li><li><p>使用flush()在写入完后，更新缓存</p><pre><code class="python">with open(&#39;txt.txt&#39;,&#39;w&#39;) as writer: writer.writer(&quot;hello ,welcome the python world&quot;) writer.flush() #清理缓存</code></pre></li><li><p>下载网络图片，并写入文件：<br><code>`</code>python<br>from urllib.request import urlopen<br>url = “<a href="https://img3.doubanio.com/lpic/s3885296.jpg&quot;" target="_blank" rel="noopener">https://img3.doubanio.com/lpic/s3885296.jpg&quot;</a></p><h1 id="‘http-www-to404-com-list-uploads-201609-thumb-a0d69ac3b7289b43a3986b423305d17d-jpg-39"><a href="#‘http-www-to404-com-list-uploads-201609-thumb-a0d69ac3b7289b43a3986b423305d17d-jpg-39" class="headerlink" title="‘http://www.to404.com/list/uploads/201609/thumb_a0d69ac3b7289b43a3986b423305d17d.jpg&#39;"></a>‘<a href="http://www.to404.com/list/uploads/201609/thumb_a0d69ac3b7289b43a3986b423305d17d.jpg&#39;" target="_blank" rel="noopener">http://www.to404.com/list/uploads/201609/thumb_a0d69ac3b7289b43a3986b423305d17d.jpg&#39;</a></h1><p>filename = “1.jpg”<br>imagedata = urlopen ( url ).read ( )<br>with open ( filename, ‘wb’ ) as filewriter:<br> filewriter.write ( imagedata )<br> filewriter.flush ( )</p></li></ol><pre><code># 文件的关闭 1. 使用close()方法关闭文件 ```python file = open(&#39;txt.txt&#39;,&#39;w&#39;) file.write(&#39;txt......&#39;) file.close()</code></pre><ol start="2"><li>使用 with 语句处理文件对象，它会文件用完后会自动关闭<pre><code class="python">with open(&#39;txt.txt&#39;,&#39;w&#39;) as writer:writer.writer(&quot;hello ,welcome the python world&quot;)</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEP8代码风格</title>
      <link href="/2016/09/11/PEP8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>/2016/09/11/PEP8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这份文档给出的代码约定适用于主要的 Python 发行版所有标准库中的 Python 代码。请参阅相似的 PEP 信息，其用于描述实现 Python 的 C 代码规范[1]。</p><p>这份文档和 PEP 257(文档字符串约定) 改编自 Guido 的 Python 风格指南原文，从 Barry 的风格指南里添加了一些东西[2]。</p><p>随着时间的推移，这份额外约定的风格指南已经被认可了，过去的约定由于语言自身的发展被淘汰了。</p><p>许多项目有它们自己的编码风格指南。如果有冲突，优先考虑项目规定的编码指南。</p><a id="more"></a><h3 id="愚蠢的一致性就像没脑子的妖怪"><a href="#愚蠢的一致性就像没脑子的妖怪" class="headerlink" title="愚蠢的一致性就像没脑子的妖怪"></a>愚蠢的一致性就像没脑子的妖怪</h3><p>Guido 的一个主要见解是读代码多过写代码。这里提供指南的意图是强调代码可读性的重要性，并且使大多数 Python 代码保持一致性。如 PEP 20 所述，“Readability counts”。</p><p>风格指南是关于一致性的。风格一致对于本指南来说是重要的，对一个项目来说是更重要的，对于一个模块或者方法来说是最重要的。</p><p>但是最最重要的是：知道什么时候应该破例–有时候这份风格指南就是不适用。有疑问时，用你最好的判断力，对比其它的例子来确定这是不是最好的情况，并且不耻下问。</p><p>特别说明：不要为了遵守这份风格指南而破坏代码的向后兼容性。</p><p>这里有一些好的理由去忽略某个风格指南：</p><p>当应用风格指南的时候使代码更难读了，对于严格依循风格指南的约定去读代码的人也是不应该的。<br>为了保持和风格指南的一致性同时也打破了现有代码的一致性（可能是历史原因）–虽然这也是一个整理混乱代码的机会（现实中的 XP 风格）。<br>因为问题代码的历史比较久远，修改代码就没有必要性了。<br>当代码需要与旧版本的 Python 保持兼容，而旧版 Python 又不支持风格指南中提到的特性的时候。</p><h3 id="代码排版"><a href="#代码排版" class="headerlink" title="代码排版"></a>代码排版</h3><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><p>每层缩进使用4个空格。</p><p>续行要么与圆括号、中括号、花括号这样的被包裹元素保持垂直对齐，要么放在 Python 的隐线（注：应该是相对于def的内部块）内部，或者使用悬挂缩进。使用悬挂缩进的注意事项：第一行不能有参数，用进一步的缩进来把其他行区分开。</p><p>好的：</p><pre><code class="Python"># Aligned with opening delimiter.foo = long_function_name(var_one, var_two,                         var_three, var_four)# More indentation included to distinguish this from the rest.def long_function_name(        var_one, var_two, var_three,        var_four):    print(var_one)# Hanging indents should add a level.foo = long_function_name(    var_one, var_two,    var_three, var_four)</code></pre><p>不好的：</p><pre><code class="python"># Arguments on first line forbidden when not using vertical alignment.foo = long_function_name(var_one, var_two,    var_three, var_four)# Further indentation required as indentation is not distinguishable.def long_function_name(    var_one, var_two, var_three,    var_four):    print(var_one)4空格规则是可选的：# Hanging indents *may* be indented to other than 4 spaces.foo = long_function_name(  var_one, var_two,  var_three, var_four)</code></pre><p>当 if 语句的条件部分足够长，需要将它写入到多个行，值得注意的是两个连在一起的关键字（i.e. if），添加一个空格，给后续的多行条件添加一个左括号形成自然地4空格缩进。如果和嵌套在 if 语句内的缩进代码块产生了视觉冲突，也应该被自然缩进4个空格。这份增强建议书对于怎样（或是否）把条件行和 if 语句的缩进块在视觉上区分开来是没有明确规定的。可接受的情况包括，但不限于：</p><pre><code class="python"># No extra indentation.if (this_is_one_thing and    that_is_another_thing):    do_something()# Add a comment, which will provide some distinction in editors# supporting syntax highlighting.if (this_is_one_thing and    that_is_another_thing):    # Since both conditions are true, we can frobnicate.    do_something()# Add some extra indentation on the conditional continuation line.if (this_is_one_thing        and that_is_another_thing):    do_something()</code></pre><p>在多行结构中的右圆括号、右中括号、右大括号应该放在最后一行的第一个非空白字符的正下方，如下所示：</p><pre><code class="python">my_list = [    1, 2, 3,    4, 5, 6,    ]result = some_function_that_takes_arguments(    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,    )</code></pre><p>或者放在多行结构的起始行的第一个字符正下方，如下：</p><pre><code class="python">my_list = [    1, 2, 3,    4, 5, 6,]result = some_function_that_takes_arguments(    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,)</code></pre><h4 id="制表符还是空格？"><a href="#制表符还是空格？" class="headerlink" title="制表符还是空格？"></a>制表符还是空格？</h4><p>空格是首选的缩进方法。</p><p>制表符（Tab）应该被用在那些以前就使用了制表符缩进的地方。</p><p>Python 3 不允许混合使用制表符和空格来缩进代码。</p><p>混合使用制表符和空格缩进的 Python 2 代码应该改为只使用空格。</p><p>当使用-t选项来调用 Python 2 的命令行解释器的时候，会对混合使用制表符和空格的代码发出警告。当使用-tt选项的时候，这些警告会变成错误。这些选项是强烈推荐的！</p><p>3.3. 每行最大长度</p><p>限制每行的最大长度为79个字符。</p><p>对于那些约束很少的文本结构（文档字符串或注释）的长块，应该限制每行长度为72个字符。</p><p>限制编辑窗口的宽度使并排打开两个窗口成为可能，使用通过代码审查工具时，也能很好的通过相邻列展现不同代码版本。</p><p>一些工具的默认换行设置打乱了代码的可视结构，使其更难理解。限制编辑器窗口宽为80来避免自动换行，即使有些编辑工具在换行的时候会在最后一列放一个标识符。一些基于 Web 的工具可能根本就不提供动态换行。</p><p>一些团队更倾向于长的代码行。对于达成了一致意见来统一代码的团队而言，把行提升到80~100的长度是可接受的（实际最大长度为99个字符），注释和文档字符串的长度还是建议在72个字符内。</p><p>Python 标准库是非常专业的，限制最大代码长度为79个字符（注释和文档字符串最大长度为72个字符）。</p><p>首选的换行方式是在括号（小中大）内隐式换行（非续行符\）。长行应该在括号表达式的包裹下换行。这比反斜杠作为续行符更好。</p><p>反斜杠有时仍然适用。例如，多个很长的with语句不能使用隐式续行，因此反斜杠是可接受的。</p><pre><code class="python">with open(&#39;/path/to/some/file/you/want/to/read&#39;) as file_1, \     open(&#39;/path/to/some/file/being/written&#39;, &#39;w&#39;) as file_2:    file_2.write(file_1.read())</code></pre><p>（见前面关于多行if语句的讨论来进一步思考这种多行with语句该如何缩进）</p><p>另一种使用反斜杠续行的案例是assert语句。</p><p>确保续行的缩进是恰到好处的。遇到二元操作符，首选的断行位置是操作符的后面而不是前面。这有一些例子：</p><pre><code class="python">class Rectangle(Blob):    def __init__(self, width, height,                 color=&#39;black&#39;, emphasis=None, highlight=0):        if (width == 0 and height == 0 and                color == &#39;red&#39; and emphasis == &#39;strong&#39; or                highlight &gt; 100):            raise ValueError(&quot;sorry, you lose&quot;)        if width == 0 and height == 0 and (color == &#39;red&#39; or                                           emphasis is None):            raise ValueError(&quot;I don&#39;t think so -- values are %s, %s&quot; %                             (width, height))        Blob.__init__(self, width, height,                      color, emphasis, highlight)</code></pre><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>顶级函数和类定义上下使用两个空行分隔。</p><p>类内的方法定义使用一个空行分隔。</p><p>可以使用额外的空行（有节制的）来分隔相关联的函数组。在一系列相关联的单行代码中空行可以省略（e.g. 一组虚拟的实现）。</p><p>在函数中使用空白行（有节制的）来表明逻辑部分。</p><p>Python 接受使用换页符（i.e. Ctrl+L）作为空格；许多工具都把Ctrl+L作为分页符，因此你可以用它们把你的文件中相似的章节分页。注意，一些编辑器和基于 Web 的代码查看工具可能不把Ctrl+L看做分页符，而是在这个位置放一个其它的符号。</p><h4 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h4><p>在核心 Python 发布版中的代码应该总是使用UTF-8编码（或者在 Python 2 中使用ASCII）。</p><p>使用ASCII(Python 2)或UTF-8(Python 3)的文件不需要有编码声明（注：它们是默认的）。</p><p>在标准库中，非缺省的编码应该仅仅用于测试目的，或者注释或文档字符串中的作者名包含非ASCII码字符；否则，优先使用\x、\u、\U或者\N来转义字符串中的非ASCII数据。</p><p>对于 Python 3.0 和之后的版本，以下是有关标准库的政策（见PEP 3131）：所有 Python 标准库中的标识符必须使用只含ASCII的标识，并且应该使用英语单词只要可行（在多数情况下，缩略语和技术术语哪个不是英语）。此外，字符串和注释也必须是ASCII。仅有的例外是：(a)测试用例测试非ASCII特性时，(b)作者名。作者的名字不是基于拉丁字母的必须提供他们名字的拉丁字母音译。</p><p>面向全球用户的开源项目，鼓励采取相似的政策。</p><h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><p>import不同的模块应该独立一行，如：</p><p>好的:</p><pre><code class="python">import osimport sys</code></pre><p>  不好的:</p><pre><code class="python">import sys, os</code></pre><p>  这样也是可行的：</p><pre><code class="python">from subprocess import Popen, PIPE</code></pre><p>import语句应该总是放在文件的顶部，在模块注释和文档字符串之下，在模块全局变量和常量之前。</p><p>import语句分组顺序如下：</p><p>导入标准库模块<br>导入相关第三方库模块<br>导入当前应用程序/库模块<br>每组之间应该用空行分开。</p><p>然后用<strong>all</strong>声明本文件内的模块。</p><p>绝对导入是推荐的，它们通常是更可读的，并且在错误的包系统配置（如一个目录包含一个以os.path结尾的包）下有良好的行为倾向（至少有更清晰的错误消息）：</p><pre><code class="python">import mypkg.siblingfrom mypkg import siblingfrom mypkg.sibling import example</code></pre><p>  当然，相对于绝对导入，相对导入是个可选替代，特别是处理复杂的包结构时，绝对导入会有不必要的冗余：</p><pre><code class="python">from . import siblingfrom .sibling import example</code></pre><p>  标准库代码应该避免复杂的包结构，并且永远使用绝对导入。</p><p>  应该从不使用隐式的相对导入，而且在 Python 3 中已经被移除。</p><p>从一个包含类的模块导入类时，这样写通常是可行的：</p><pre><code class="python">from myclass import MyClassfrom foo.bar.yourclass import YourClass</code></pre><p>  如果上面的方式会本地导致命名冲突，则这样写：</p><pre><code class="python">import myclassimport foo.bar.yourclass</code></pre><p>  以myclass.MyClass和foo.bar.yourclass.YourClass这样的方式使用。</p><p>应该避免通配符导入<code>（from import *）</code>，这会使名称空间里存在的名称变得不清晰，迷惑读者和自动化工具。这里有一个可辩护的通配符导入用例，，重新发布一个内部接口作为公共 API 的一部分（例如，使用纯 Python 实现一个可选的加速器模块的接口，但并不能预知这些定义会被覆盖）。</p><p>当以这种方式重新发布名称时，下面关于公共和内部接口的指南仍然适用。</p><h3 id="字符串引号"><a href="#字符串引号" class="headerlink" title="字符串引号"></a>字符串引号</h3><p>在 Python 里面，单引号字符串和双引号字符串是相同的。这份指南对这个不会有所建议。选择一种方式并坚持使用。一个字符串同时包含单引号和双引号字符时，用另外一种来包裹字符串，而不是使用反斜杠来转义，以提高可读性。</p><p>对于三引号字符串，总是使用双引号字符来保持与文档字符串约定的一致性（PEP 257）。</p><h3 id="表达式和语句中的空格"><a href="#表达式和语句中的空格" class="headerlink" title="表达式和语句中的空格"></a>表达式和语句中的空格</h3><h4 id="不能忍受的情况"><a href="#不能忍受的情况" class="headerlink" title="不能忍受的情况"></a>不能忍受的情况</h4><p>避免在下列情况中使用多余的空格：</p><p>与括号保持紧凑（小括号、中括号、大括号）：</p><pre><code class="python">Yes: spam(ham[1], {eggs: 2})No:  spam( ham[ 1 ], { eggs: 2 } )</code></pre><p>与后面的逗号、分号或冒号保持紧凑：</p><pre><code class="python">Yes: if x == 4: print x, y; x, y = y, xNo:  if x == 4 : print x , y ; x , y = y , x</code></pre><p>切片内的冒号就像二元操作符一样，任意一侧应该被等同对待（把它当做一个极低优先级的操作）。在一个可扩展的切片中，冒号两侧必须有相同的空格数量。例外：切片参数省略时，空格也省略。</p><p>好的：</p><pre><code class="python">ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset]</code></pre><p>  不好的：</p><pre><code class="python">ham[lower + offset:upper + offset]ham[1: 9], ham[1 :9], ham[1:9 :3]ham[lower : : upper]ham[ : upper]</code></pre><p>函数名与其后参数列表的左括号应该保持紧凑：</p><pre><code class="python">Yes: spam(1)No:  spam (1)</code></pre><p>与切片或索引的左括号保持紧凑：</p><pre><code class="python">Yes: dct[&#39;key&#39;] = lst[index]No:  dct [&#39;key&#39;] = lst [index]</code></pre><p>在复制操作符（或其它）的两侧保持多余一个的空格：</p><p>好的：</p><pre><code class="python">x = 1y = 2long_variable = 3</code></pre><p>  不好的：</p><pre><code class="python">x             = 1y             = 2long_variable = 3</code></pre><p>5.2. 其他建议</p><p>总是在这些二元操作符的两侧加入一个空格：赋值(=)，增量赋值(+=, -= etc.)，比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not)，布尔运算(and, or, not)。</p><p>在不同优先级之间，考虑在更低优先级的操作符两侧插入空格。用你自己的判断力；但不要使用超过一个空格，并且在二元操作符的两侧有相同的空格数。</p><p>好的：</p><pre><code class="python">i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)</code></pre><p>  不好的：</p><pre><code class="python">i=i+1submitted +=1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b)</code></pre><p>不要在关键值参数或默认值参数的等号两边加入空格。</p><p>好的：</p><pre><code class="python">def complex(real, imag=0.0):    return magic(r=real, i=imag)</code></pre><p>  不好的：</p><pre><code class="python">def complex(real, imag = 0.0):    return magic(r = real, i = imag)</code></pre><p>【注：Python 3】带注释的函数定义中的等号两侧要各插入空格。此外，在冒号后用一个单独的空格，也要在表明函数返回值类型的-&gt;左右各插入一个空格。</p><p>好的：</p><pre><code class="python">def munge(input: AnyStr):def munge(sep: AnyStr = None):def munge() -&gt; AnyStr:def munge(input: AnyStr, sep: AnyStr = None, limit=1000):</code></pre><p>  不好的：</p><pre><code class="python">def munge(input: AnyStr=None):def munge(input:AnyStr):def munge(input: AnyStr)-&gt;PosInt:</code></pre><p>打消使用复合语句（多条语句在同一行）的念头。</p><p>好的：</p><pre><code class="python">if foo == &#39;blah&#39;:    do_blah_thing()do_one()do_two()do_three()</code></pre><p>  宁可不：</p><pre><code class="python">if foo == &#39;blah&#39;: do_blah_thing()do_one(); do_two(); do_three()</code></pre><p>有时候把 if/for/while 和一个小的主体放在同一行也是可行的，千万不要在有多条语句的情况下这样做。此外，还要避免折叠，例如长行。</p><p>宁可不：</p><pre><code class="python">if foo == &#39;blah&#39;: do_blah_thing()for x in lst: total += xwhile t &lt; 10: t = delay()</code></pre><p>  绝对不：</p><pre><code class="python">if foo == &#39;blah&#39;: do_blah_thing()else: do_non_blah_thing()try: something()finally: cleanup()do_one(); do_two(); do_three(long, argument,                             list, like, this)if foo == &#39;blah&#39;: one(); two(); three()</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>与代码相矛盾的注释不如没有。注释总是随着代码的变更而更新。</p><p>注释应该是完整的句子。如果注释是一个短语或语句，第一个单词应该大写，除非是一个开头是小写的标识符（从不改变标识符的大小写）。</p><p>如果注释很短，末尾的句点可以省略。块注释通常由一个或多个有完整句子的段落组成，并且每个句子应该由句点结束。</p><p>你应该在一个句子的句点后面用两个空格。</p><p>写英语时，遵循《Strunk and White》（注：《英文写作指南》，参考维基百科）。</p><p>来自非英语国家的程序员：请用英语写注释，除非你120%确定你的代码永远不会被那些不说你的语言的人阅读。</p><h4 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h4><p>块注释通常用来说明跟随在其后的代码，应该与那些代码有相同的缩进层次。块注释每一行以#起头，并且#后要跟一个空格（除非是注释内的缩进文本）。</p><h4 id="行内注释"><a href="#行内注释" class="headerlink" title="行内注释"></a>行内注释</h4><p>有节制的使用行内注释。</p><p>一个行内注释与语句在同一行。行内注释应该至少与语句相隔两个空格。以#打头，#后接一个空格。</p><p>无谓的行内注释如果状态明显，会转移注意力。不要这样做：</p><pre><code class="Python">x = x + 1                 # Increment x</code></pre><p>但有的时候，这样是有用的：</p><pre><code class="python">x = x + 1                 # Compensate for border</code></pre><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>编写良好的文档字符串（a.k.a “docstring”）的约定常驻在 PEP 257</p><p>为所有的公共模块、函数、类和方法编写文档字符串。对于非公共的方法，文档字符串是不必要的，但是也应该有注释来说明代码是干什么的。这个注释应该放在方法声明的下面。<br>PEP 257 描述了良好的文档字符串的约定。注意，文档字符串的结尾”””应该放在单独的一行，例如：</p><pre><code class="python">&quot;&quot;&quot;Return a foobangOptional plotz says to frobnicate the bizbaz first.&quot;&quot;&quot;</code></pre><p>对于单行的文档字符串，把结尾”””放在同一行。</p><h3 id="版本注记"><a href="#版本注记" class="headerlink" title="版本注记"></a>版本注记</h3><p>如果必须要 Subversion，CVS 或 RCS 标记在你的源文件里，像这样做：</p><p><strong>version</strong> = “$Revision$”</p><h1 id="Source"><a href="#Source" class="headerlink" title="$Source$"></a>$Source$</h1><p>这几行应该在模块的文档字符串后面，其它代码的前面，上下由一个空行分隔。</p><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>Python 库的命名规则有点混乱，因此我们永远也不会使其完全一致的 – 不过，这里有一些当前推荐的命名标准。新的模块和包（包括第三方框架）应该按照这些标准来命名，但是已存在库有不同的风格，内部一致性是首选。</p><h4 id="覆盖原则"><a href="#覆盖原则" class="headerlink" title="覆盖原则"></a>覆盖原则</h4><p>API 里对用户可见的公共部分应该遵循约定，反映的是使用而不是实现。</p><h4 id="规定：命名约定"><a href="#规定：命名约定" class="headerlink" title="规定：命名约定"></a>规定：命名约定</h4><p>有许多不同的命名风格。这有助于识别正在使用的命名风格，独立于它们的用途。</p><p>下面的命名风格通常是有区别的：</p><pre><code class="python">b (一个小写字母)B (一个大写字母)lowercaselower_case_with_underscoresUPPERCASEUPPER_CASE_WITH_UNDERSCORES</code></pre><p>CapitalizedWords (又叫 CapWords，或者 CamelCase(骆驼命名法) – 如此命名因为字母看起来崎岖不平[3]。有时候也叫 StudlyCaps。<br>  注意：在 CapWords 使用缩略语时，所有缩略语的首字母都要大写。因此HTTPServerError比HttpServerError要好。</p><p>mixedCase (和上面不同的是首字母小写)<br>Capitalized_Words_With_Underscores (丑陋无比！)<br>也有种风格用独一无二的短前缀来将相似的命名分组。在 Python 里用的不是很多，但是为了完整性被提及。例如，os.stat()函数返回一个元组，通常有像st_mode，st_size，st_mtime等名字。（强调与 POSIX 系统调用的字段结构一致，有助于程序员对此更熟悉）</p><p>X11 库的所有公共函数都用 X 打头。在 Python 中这种风格被认为是不重要的，因为属性和方法名的前缀是一个对象，函数名的前缀为一个模块名。</p><p>此外，下面的特许形式用一个前导或尾随的下划线进行识别（这些通常可以和任何形式的命名约定组合）：</p><p>_single_leading_underscore ：仅内部使用的标识，如from M import *不会导入像这样一下划线开头的对象。<br>single_trailingunderscore : 通常是为了避免与 Python 规定的关键字冲突，如Tkinter.Toplevel(master, class_=’ClassName’)。<br>double_leading_underscore : 命名一个类属性，调用的时候名字会改变（在类FooBar中，<code>boo变成了_FooBar__boo</code>；见下）。<br>double_leading_and_trailing_underscore ：”魔术”对象或属性，活在用户控制的命名空间里。例如，<strong>init</strong>，<strong>import</strong>和<strong>file</strong>。永远不要像这种方式命名；只把它们作为记录。</p><h4 id="规定：命名约定-1"><a href="#规定：命名约定-1" class="headerlink" title="规定：命名约定"></a>规定：命名约定</h4><h5 id="应该避免的名字"><a href="#应该避免的名字" class="headerlink" title="应该避免的名字"></a>应该避免的名字</h5><p>永远不要使用单个字符l(小写字母 el)，O(大写字母 oh)，或I(大写字母 eye)作为变量名。</p><p>在一些字体中，这些字符是无法和数字1和0区分开的。试图使用l时用L代替。</p><h5 id="包和模块名"><a href="#包和模块名" class="headerlink" title="包和模块名"></a>包和模块名</h5><p>模块名应该短，且全小写。如果能改善可读性，可以使用下划线。Python 的包名也应该短，全部小写，但是不推荐使用下划线。</p><p>因为模块名就是文件名，而一些文件系统是大小写不敏感的，并且自动截断长文件名，所以给模块名取一个短小的名字是非常重要的 – 在 Unix 上这不是问题，但是把代码放到老版本的 Mac， Windows，或者 DOS 上就可能变成一个问题了。</p><p>用 C/C++ 给 Python 写一个高性能的扩展(e.g. more object oriented)接口的时候，C/C++ 模块名应该有一个前导下划线。</p><h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><p>类名通常使用 CapWords 约定。</p><p>The naming convention for functions may be used instead in cases where the interface is documented and used primarily as a callable.</p><p>注意和内建名称的区分开：大多数内建名称是一个单独的单词（或两个单词一起），CapWords 约定只被用在异常名和内建常量上。</p><h5 id="异常名"><a href="#异常名" class="headerlink" title="异常名"></a>异常名</h5><p>因为异常应该是类，所以类名约定在这里适用。但是，你应该用Error作为你的异常名的后缀（异常实际上是一个错误）。</p><h5 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h5><p>（我们希望这些变量仅仅在一个模块内部使用）这个约定有关诸如此类的变量。</p><p>若被设计的模块可以通过from M import *来使用，它应该使用<strong>all</strong>机制来表明那些可以可导出的全局变量，或者使用下划线前缀的全局变量表明其是模块私有的。</p><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名应该是小写的，有必要的话用下划线来分隔单词提高可读性。</p><p>混合大小写仅仅在上下文都是这种风格的情况下允许存在（如thread.py），这是为了维持向后兼容性。</p><h4 id="函数和方法参数"><a href="#函数和方法参数" class="headerlink" title="函数和方法参数"></a>函数和方法参数</h4><p>总是使用self作为实例方法的第一个参数。</p><p>总是使用cls作为类方法的第一个参数。</p><p>如果函数参数与保留关键字冲突，通常最好在参数后面添加一个尾随的下划线，而不是使用缩写或胡乱拆减。因此class_比clss要好。（或许避免冲突更好的方式是使用近义词）</p><h5 id="方法名和实例变量"><a href="#方法名和实例变量" class="headerlink" title="方法名和实例变量"></a>方法名和实例变量</h5><p>用函数名的命名规则：全部小写，用下划线分隔单词提高可读性。</p><p>用一个且有一个前导的下划线来表明非公有的方法和实例变量。</p><p>为了避免与子类变量或方法的命名冲突，用两个前导下划线来调用 Python 的命名改编规则。</p><p>Python 命名改编通过添加一个类名：如果类Foo有一个属性叫<strong>a，它不能被这样Foo.</strong>a访问（执着的人可以通过这样Foo._Foo__a来访问）通常，双前导的下划线应该仅仅用来避免与其子类属性的命名冲突。</p><p>注意：这里有一些争议有关__names的使用（见下文）。</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>常量通常是模块级的定义，全部大写，单词之间以下划线分隔。例如MAX_OVERFLOW和TOTAL。</p><h5 id="继承的设计"><a href="#继承的设计" class="headerlink" title="继承的设计"></a>继承的设计</h5><p>总是决定一个类的方法和变量（属性）是应该公有还是非公有。如果有疑问，选择非公有；相比把共有属性变非公有，非公有属性变公有会容易得多。</p><p>公有属性是你期望给那些与你的类无关的客户端使用的，你应该保证不会出现不向后兼容的改变。非公有的属性是你不打算给其它第三方使用的；你不需要保证非公有的属性不会改变甚至被移除也是可以的。</p><p>我们这里不适用“私有”这个术语，因为在 Python 里没有真正的私有属性（一般没有不必要的工作量）。</p><p>另一种属性的分类是“子类 API”的一部分（通常在其它语言里叫做“Protected”）。一些类被设计成被继承的，要么扩展要么修改类的某方面行为。设计这样一个类的时候，务必做出明确的决定，哪些是公有的，其将会成为子类 API 的一部分，哪些仅仅是用于你的基类的。</p><p>处于这种考虑，给出 Pythonic 的指南：</p><p>共有属性不应该有前导下划线。<br>如果你的公有属性与保留关键字发生冲突，在你的属性名后面添加一个尾随的下划线。这比使用缩写或胡乱拆减要好。（尽管这条规则，已知某个变量或参数可能是一个类情况下，cls是首选的命名，特别是作为类方法的第一个参数）<br>  注意一：见上面推荐的类方法参数命名方式。</p><p>对于简单的公有数据属性，最好的方式是暴露属性名，不要使用复杂的访问属性/修改属性的方法。记住，Python 提供了捷径去提升特性，如果你发现简单的数据属性需要增加功能行为。在这种情况下，使用properties把功能实现隐藏在简单的数据属性访问语法下面。<br>  注意一：properties仅仅在新式类下工作。   注意二：尽量保持功能行为无边际效应，然而如缓存有边际效应也是好的。   注意三：避免为计算开销大的操作使用properties；属性标记使调用者相信这样来访问（相对来说）是开销很低的。</p><p>如果你的类是为了被继承，你有不想让子类使用的属性，给属性命名时考虑给它们加上双前导下划线，不要加尾随下划线。这会调用 Python 的名称重整算法，把类名加在属性名前面。避免了命名冲突，当子类不小心命名了和父类属性相同名称的时候。<br>  注意一：注意只是用了简单的类名来重整名字，因此如果子类和父类同名的时候，你仍然有能力避免冲突。</p><p>  注意二：命名重整有确定的用途，例如调试和<strong>getattr</strong>()，就不太方便。命名重整算法是有据可查的，易于手动执行。</p><p>  注意三：不是每个人都喜欢命名重整。尽量平衡名称的命名冲突与面向高级调用者的潜在用途。</p><h3 id="公共和内部接口"><a href="#公共和内部接口" class="headerlink" title="公共和内部接口"></a>公共和内部接口</h3><p>保证所有公有接口的向后兼容性。用户能清晰的区分公有和内部接口是重要的。</p><p>文档化的接口考虑公有，除非文档明确的说明它们是暂时的，或者内部接口不保证其的向后兼容性。所有的非文档化的应该被假设为非公开的。</p><p>为了更好的支持内省，模块应该用<strong>all</strong>属性来明确规定公有 API 的名字。设置<strong>all</strong>为空list表明模块没有公有 API。</p><p>甚至与<strong>all</strong>设置相当，内部接口（包、模块、类、函数、属性或者其它的名字）应该有一个前导的下划线前缀。</p><p>被认为是内部的接口，其包含的任何名称空间（包、模块或类）也被认为是内部的。</p><p>导入的名称应始终视作一个实现细节。其它模块不能依赖间接访问这些导入的名字，除非它们是包含模块的 API 明确记载的一部分，例如os.path或一个包的<strong>init</strong>模块暴露了来自子模块的功能。</p><h3 id="程序编写建议"><a href="#程序编写建议" class="headerlink" title="程序编写建议"></a>程序编写建议</h3><p>代码的编写方式不能对其它 Python 的实现（PyPy、Jython、IronPython、Cython、Psyco，诸如此类的）不利。</p><p>例如，不要依赖于 CPython 在字符串拼接时的优化实现，像这种语句形式a += b和a = a + b。即使是 CPython（仅对某些类型起作用） 这种优化也是脆弱的，不是在所有的实现中都不使用引用计数。在库中性能敏感的部分，用’’.join形式来代替。这会确保在所有不同的实现中字符串拼接是线性时间的。</p><p>比较单例，像None应该用is或is not，从不使用==操作符。</p><p>当你的真正用意是if x is not None的时候，当心if x这样的写法 – 例如，测试一个默认值为None的变量或参数是否设置成了其它值，其它值可能是那些布尔值为 false 的类型（如空容器）。</p><p>用is not操作符而不是not … is。虽然这两个表达式是功能相同的，前一个是更可读的，是首选。</p><p>好的:</p><p>if foo is not None:<br>  不好的:</p><p>if not foo is None:<br>用富比较实现排序操作的时候，实现所有六个比较操作符（ <strong>eq</strong> 、 <strong>ne</strong> 、 <strong>lt</strong> , <strong>le</strong>, <strong>gt</strong> , <strong>ge</strong>）是更好的，而不是依赖其它仅仅运用一个特定比较的代码</p><p>为了最大限度的减少工作量，functools.total_ordering()装饰器提供了一个工具去生成缺少的比较方法。</p><p>PEP 207 说明了 Python 假定的所有反射规则。因此，解释器可能交换y &gt; x与x &lt; y，y &gt;= x与x &lt;= y，也可能交换x == y和x != y。sort()和min()操作肯定会使用&lt;操作符，max()函数肯定会使用&gt;操作符。当然，最好是六个操作符都实现，以便不会在其它上下文中有疑惑。</p><p>始终使用def语句来代替直接绑定了一个lambda表达式的赋值语句。</p><p>好的:</p><p>def f(x): return 2*x<br>  不好的:</p><p>f = lambda x: 2*x<br>  第一种形式意味着函数对象的名字是’f’而不是’’的。通常这对异常追踪和字符串表述是更有用的。使用赋值语句消除的唯一好处，lambda表达式可以提供一个显示的def语句不能提供的，如，lambda能镶嵌在一个很长的表达式里。</p><p>异常类应派生自Exception而不是BaseException。直接继承自BaseException是为Exception保留的，如果从BaseException继承，捕获到的错误总是错的。</p><p>设计异常结构层次，应基于那些可能出现异常的代码，而不是在出现异常后的。编码的时候，以回答“出了什么问题？”为目标，而不是仅仅指出“这里出现了问题”（见 PEP 3151 一个内建异常结构层次的例子）。</p><p>类的命名约定适用于异常，如果异常类是一个错误，你应该给异常类加一个后缀Error。用于非本地流程控制或者其他形式的信号的非错误异常不需要一个特殊的后缀。</p><p>适当的使用异常链。在 Python 3 里，raise X from Y用于表明明确的替代者，不丢失原有的回溯信息。</p><p>有意替换一个内部的异常时（在 Python 2 用raise X，Python 3.3+ 用raise X from None），确保相关的细节全部转移给了新异常（例如，把KeyError变成AttributeError时保留属性名，或者把原始异常的错误信息嵌在新异常里）。</p><p>在 Python 2 里抛出异常时，用raise ValueError(‘message’)代替旧式的raise ValueError, ‘message’。</p><p>在 Python 3 之后的语法里，旧式的异常抛出方式是非法的。</p><p>使用括号形式的异常意味着，当你传给异常的参数过长或者包含字符串格式化时，你就不需要使用续行符了，这要感谢括号！</p><p>捕获异常时，尽可能使用明确的异常，而不是用一个空的except:语句。</p><p>例如，用：</p><pre><code class="python">try:    import platform_specific_moduleexcept ImportError:    platform_specific_module = None</code></pre><p>  一个空的except:语句将会捕获到SystemExit和KeyboardInterrupt异常，很难区分程序的中断到底是Ctrl+C还是其他问题引起的。如果你想捕获程序的所有错误，使用except Exception:(空except:等同于except BaseException)。</p><p>  一个好的经验是限制使用空except语句，除了这两种情况：</p><p>如果异常处理程序会打印出或者记录回溯信息；至少用户意识到错误的存在。<br>如果代码需要做一些清理工作，但后面用raise向上抛出异常。try .. finally是处理这种情况更好的方式。<br>绑定异常给一个名字时，最好使用 Python 2.6 里添加的明确的名字绑定语法：</p><pre><code class="python">try:    process_data()except Exception as exc:    raise DataProcessingFailedError(str(exc))</code></pre><p>Python 3 只支持这种语法，避免与基于逗号的旧式语法产生二义性。</p><p>捕获操作系统错误时，最好使用 Python 3.3 里引进的明确的异常结构层次，而不是自省的errno值。</p><p>此外，对于所有的try/except语句来说，限制try里面有且仅有绝对必要的代码。在强调一次，这能避免屏蔽错误。</p><p>好的：</p><pre><code class="python">try:    value = collection[key]except KeyError:    return key_not_found(key)else:    return handle_value(value)</code></pre><p>  不好的：</p><pre><code class="python">try:    # Too broad!    return handle_value(collection[key])except KeyError:    # Will also catch KeyError raised by handle_value()    return key_not_found(key)</code></pre><p>当资源是本地的特定代码段，用with语句确保其在使用后被立即干净的清除了，try/finally也是也接受的。</p><p>当它们做一些除了获取和释放资源之外的事的时候，上下文管理器应该通过单独的函数或方法调用。例如：</p><p>好的：</p><pre><code class="python">with conn.begin_transaction():    do_stuff_in_transaction(conn)</code></pre><p>  不好的：</p><pre><code class="python">with conn:    do_stuff_in_transaction(conn)</code></pre><p>  第二个例子没有提供任何信息来表明<strong>enter</strong>和<strong>exit</strong>方法在完成一个事务后做了一些除了关闭连接以外的其它事。在这种情况下明确是很重要的。</p><p>坚持使用return语句。函数内的return语句都应该返回一个表达式，或者None。如果一个return语句返回一个表达式，另一个没有返回值的应该用return None清晰的说明，并且在一个函数的结尾应该明确使用一个return语句（如果有返回值的话）。</p><p>好的：</p><pre><code class="python">def foo(x):    if x &gt;= 0:        return math.sqrt(x)    else:        return Nonedef bar(x):    if x &lt; 0:        return None    return math.sqrt(x)</code></pre><p>  不好的：</p><pre><code class="python">def foo(x):    if x &gt;= 0:        return math.sqrt(x)def bar(x):    if x &lt; 0:        return    return math.sqrt(x)</code></pre><p>用字符串方法代替字符串模块。</p><p>字符串方法总是更快，与 unicode 字符串共享 API。如果需要向后兼容性覆盖这个规则，需要 Python 2.0 以上的版本。</p><p>用’’.startswith()和’’.endswith()代替字符串切片来检查前缀和后缀。</p><p>startswith()和endswith()是更简洁的，不容易出错的。例如：</p><p>Yes: if foo.startswith(‘bar’):<br>No:  if foo[:3] == ‘bar’:<br>对象类型的比较应该始终使用isinstance()而不是直接比较。<br>Yes: if isinstance(obj, int):</p><p>No:  if type(obj) is type(1):<br>  当比较一个对象是不是字符串时，记住它有可能也是一个 unicode 字符串！在 Python 2 里面，str和unicode有一个公共的基类叫basestring，因此你可以这样做：</p><p>if isinstance(obj, basestring):<br>  注意，在 Python 3 里面，unicode和basestring已经不存在了（只有str），byte对象不再是字符串的一种（被一个整数序列替代）。</p><p>对于序列（字符串、列表、元组）来说，空的序列为False：</p><p>好的：</p><p>if not seq:<br>if seq:<br>  不好的：</p><p>if len(seq):<br>if not len(seq):<br>不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，一些编辑器（or more recently, reindent.py）会将其裁剪掉。<br>不要用==比较True和False。<br>Yes:   if greeting:<br>No:    if greeting == True:<br>Worse: if greeting is True:<br>Python 标准库将不再使用函数标注，以至于给特殊的标注风格给一个过早的承若。代替的，这些标注是留给用户去发现和体验的有用的标注风格。</p><p>建议第三方实验的标注用相关的修饰符指示标注应该如何被解释。</p><p>早期的核心开发者尝试用函数标注显示不一致、特别的标注风格。例如：</p><p>[str]是很含糊的，它可能代表一个包含字符串的列表，也可能代表一个为字符串或为空的值。<br>open(file:(str,bytes))可能用来表示file的值可以是一个str或者bytes，也可能用来表示file的值是一个包含str和bytes的二元组。<br>标注seek(whence:int)体现了一个过于明确又不够明确的混合体：int太严格了（有<strong>index</strong>的应该被允许），又不够严格（只有0,1,2是被允许的）。同样的，标注write(b: byte)太严格了（任何支持缓存协议的都应该被允许）。<br>像read1(n: int=None)这样的标注自我矛盾，因为None不是int。像source_path(self, fullname:str) -&gt; object标注是迷惑人的，返回值到底是应该什么类型？<br>除了上面之外，在具体类型和抽象类型的使用上是不一致的：int对integral（整数），set/fronzenset对MutableSet/Set。<br>不正确的抽象基类标注规格。例如，集合之间的操作需要另一个对象是集合的实例，而不只是一个可迭代序列。<br>另一个问题是，标注成为了规范的一部分，但却没有经受过考验。<br>在大多数情况下，文档字符串已经包括了类型规范，比函数标注更清晰。在其余的情况下，一旦标注被移除，文档字符串应该被完善。<br>观察到的函数标注太标新立异了，相关的系统不能一致的处理自动类型检查和参数验证。离开这些标注的代码以后很难做出更改，使自动化工具可以支持。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]：PEP 7 , Style Guide for C Code, van Rossum</p><p>[2]：Barry’s GNU Mailman style guide <a href="http://barry.warsaw.us/software/STYLEGUIDE.txt" target="_blank" rel="noopener">http://barry.warsaw.us/software/STYLEGUIDE.txt</a></p><p>[3]：<a href="http://www.wikipedia.com/wiki/CamelCase" target="_blank" rel="noopener">http://www.wikipedia.com/wiki/CamelCase</a></p><h3 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h3><p>This document has been placed in the public domain.</p><p>Source: <a href="https://hg.python.org/peps/file/tip/pep-0008.txt" target="_blank" rel="noopener">https://hg.python.org/peps/file/tip/pep-0008.txt</a></p><p>总结</p><blockquote><p>即使内容有点多，但每一个 Python 开发者都应该尽量遵守 PEP8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PEP8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给MacOS X下的Python3安装requests模块</title>
      <link href="/2016/09/08/%E7%BB%99MacOS-X%E4%B8%8B%E7%9A%84Python3%E5%AE%89%E8%A3%85requests%E6%A8%A1%E5%9D%97/"/>
      <url>/2016/09/08/%E7%BB%99MacOS-X%E4%B8%8B%E7%9A%84Python3%E5%AE%89%E8%A3%85requests%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>默认情况下直接用</p><pre><code class="python">pip install requests</code></pre><p>会安装到MacOS 自带的Python 2下面，Python 3还是不能使用requests模块。<br>解决方案</p><p>下载request源代码：</p><pre><code class="sh">curl -OL https://github.com/kennethreitz/requests/zipball/master</code></pre><p>加扩展名.zip后解压，从命令行进入这个目录下然后执行：</p><pre><code class="sh">python3 setup.py install</code></pre><p>这样requests模块就被安装在Python 3下面了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你使用charles抓取https消息</title>
      <link href="/2016/09/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8charles%E6%8A%93%E5%8F%96https%E6%B6%88%E6%81%AF/"/>
      <url>/2016/09/03/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8charles%E6%8A%93%E5%8F%96https%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<ol><li>安装charles</li><li><p>安装sslproxy证书</p><ul><li>电脑端（Mac）：  charles–&gt;help–&gt;SSL Proxying –&gt; install charles Root certificate<br>在密钥管理中将该证书设置信任。</li><li>手机端（iOS）：<br> 将网络代理设置成电脑网络，然后在safari中输入“<a href="http://charlesproxy.com/getssl”下载证书并安装" target="_blank" rel="noopener">http://charlesproxy.com/getssl”下载证书并安装</a></li></ul></li><li><p>制作对应用网站的crt证书 这里以”<a href="https://cf.ushareit.com&quot;为例" target="_blank" rel="noopener">https://cf.ushareit.com&quot;为例</a></p><a id="more"></a><h1 id="制作流程："><a href="#制作流程：" class="headerlink" title="制作流程："></a>制作流程：</h1></li><li>生成密钥<br> 打开终端，输入以下命令：<pre><code class="js"> cd /private/etc/apache2/ssl //进行该文件夹中 sudo ssh-keygen -f server.key //生成key ,若要求输入密码，可以按Enter进入下一步</code></pre></li><li><p>用上面生成的server.key 生成证书请求文件<br>   输入以命令：</p><pre><code class="js">   sudo openssl req -new -key server.key -out cf.ushareit.com.csr</code></pre><p>   执行记录：</p><pre><code class="js">   localhost:ssl yuanpinghua$ sudo openssl req -new -key server.key -out cf.ushareit.com.csr             Password:             You are about to be asked to enter information that will be incorporated             into your certificate request.             What you are about to enter is what is called a Distinguished Name or a DN.             There are quite a few fields but you can leave some blank             For some fields there will be a default value,             If you enter &#39;.&#39;, the field will be left blank.             -----             Country Name (2 letter code) [AU]:             State or Province Name (full name) [Some-State]:             Locality Name (eg, city) []:             Organization Name (eg, company) [Internet Widgits Pty Ltd]:             Organizational Unit Name (eg, section) []:             Common Name (e.g. server FQDN or YOUR name) []:cf.ushareit.com //站点的域名             Email Address []:             Please enter the following &#39;extra&#39; attributes             to be sent with your certificate request             A challenge password []:             An optional company name []:</code></pre></li><li>使用上述生成的server.key 和证书请求文件生成ssl 证书:<pre><code> 输入如下命令： ```js sudo openssl x509 -req -days 365 -in cf.ushareit.com.csr -signkey server.key -out cf.ushareit.com.crt ``` 执行记录： ```js localhost:ssl yuanpinghua$     sudo openssl x509 -req -days 365 -in cf.ushareit.com.csr -signkey server.key -out cf.usharit.com.crt Signature ok subject=/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=cf.ushareit.com Getting Private key ```</code></pre></li><li><p>到此证书已经制作完成，接下来要进行Appache网络配置：</p><pre><code> 使用编辑器打开`/etc/apache2/httpd.conf`文件 将下面两行前的`#`号去掉,后保存。 ```js # LoadModule php5_module libexec/apache2/libphp5.so # LoadModule hfs_apple_module libexec/apache2/mod_hfs_apple.so ``` 打开`/etc/apache2/extra/httpd-vhosts.conf`文件，在文件末尾添加如下内容： ```js &lt;VirtualHost *:80&gt;     DocumentRoot &quot;/Library/WebServer/Documents/cf_ushareit_com&quot;     ServerName cf.ushareit.com       RewriteEngine on     RewriteRule ^(.*)$ /abc.php     ErrorLog &quot;/private/var/log/apache2/dummy-cm.ushareit.com-error_log&quot;     CustomLog &quot;/private/var/log/apache2/dummy-cm.ushareit.com-access_log&quot; common &lt;/VirtualHost&gt; &lt;VirtualHost *:443&gt;   SSLEngine on   SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULL   SSLCertificateFile /private/etc/apache2/ssl/cf.ushareit.com.crt   SSLCertificateKeyFile /private/etc/apache2/ssl/server.key   DocumentRoot &quot;/Library/WebServer/Documents/cf_ushareit_com&quot;   ServerName cf.ushareit.com      RewriteEngine on   RewriteRule ^(.*)$ /abc.php &lt;/VirtualHost&gt; ``` 在`/Library/WebServer/Documents/`站点下创建`cf_ushareit_com`文件夹。同时创建一个  `crt`文件夹，用来存放刚创建的`cf_ushareit_com.crt`证书</code></pre></li><li><p>在命令行中输入以下命令，检查刚加入的文件进行语法检查，并重新启动Appache:</p><pre><code>```jssudo apachectl configtest //检查配置sudo apachectl -k restart  //强制重启```</code></pre></li><li>证书安装与sslproxy设置<pre><code> 在手机端安装刚才创建的crt证书。 在charles中进行ssl设置： ``` charles --&gt;Proxy--&gt;SSL Proxying Setting --&gt; add --&gt;Host:cf.ushareit.com /port:443 --&gt; ok ``` 现在可以尽情使用了！哈哈</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> https 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS X中Apache开启ssl</title>
      <link href="/2016/09/03/Mac-OS-X%E4%B8%ADApache%E5%BC%80%E5%90%AFssl/"/>
      <url>/2016/09/03/Mac-OS-X%E4%B8%ADApache%E5%BC%80%E5%90%AFssl/</url>
      
        <content type="html"><![CDATA[<ol><li>生成主机密钥<br> 这里会要求输入密码，不输入，直接回车<pre><code> sudo mkdir /private/etc/apache2/ssl cd /private/etc/apache2/ssl sudo ssh-keygen -f server.key</code></pre> 执行过程：<pre><code> localhost:~ yuanpinghua$ sudo mkdir  /private/etc/apache2/ssl Password: localhost:~ yuanpinghua$ cd /private/etc/apache2/ssl localhost:ssl yuanpinghua$ sudo ssh-keygen -f server.key Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in server.key. Your public key has been saved in server.key.pub. The key fingerprint is: SHA256:MX4CY5k2ehZtPjp+SQ3F5Au+RKdYrlpN+ycdI43MlQw root@localhost The key&#39;s randomart image is: +---[RSA 2048]----+ |         o.      | |       + .E      | |      X O.oo .   | |     + #.* .+    | |    . + S=o+     | |     o *.** +    | |      =.+. o o   | |     + .o.. o    | |    . ..  .o     | +----[SHA256]-----+</code></pre> <a id="more"></a></li><li><p>生成证书请求文件</p><pre><code>   sudo openssl req -new -key server.key -out request.csr</code></pre><p>   执行过程：</p><pre><code>   localhost:ssl yuanpinghua$ sudo openssl req -new -key server.key -out request.csr   You are about to be asked to enter information that will be incorporated   into your certificate request.   What you are about to enter is what is called a Distinguished Name or a DN.   There are quite a few fields but you can leave some blank   For some fields there will be a default value,   If you enter &#39;.&#39;, the field will be left blank.   -----   Country Name (2 letter code) [AU]:   State or Province Name (full name) [Some-State]:   Locality Name (eg, city) []:   Organization Name (eg, company) [Internet Widgits Pty Ltd]:   Organizational Unit Name (eg, section) []:   Common Name (e.g. server FQDN or YOUR name) []:   Email Address []:   Please enter the following &#39;extra&#39; attributes   to be sent with your certificate request   A challenge password []:   An optional company name []:</code></pre></li><li><p>生成ssl证书<br> 用上一步生成的文件生成ssl证书</p><pre><code> sudo openssl x509 -req -days 365 -in request.csr -signkey server.key -out server.crt</code></pre><p> 到这里，自签名证书就生成好了，下面就开始配置Apache</p><ul><li><p><code>/private/etc/apache2/httpd.conf</code>，编辑这个文件去掉下面三行前面的 ‘#’</p><pre><code> LoadModule ssl_module libexec/apache2/mod_ssl.so Include /private/etc/apache2/extra/httpd-ssl.conf Include/private/etc/apache2/extra/httpd-vhosts.conf</code></pre></li><li><p><code>/private/etc/apache2/extra/httpd-ssl.conf</code>，编辑这个文件去掉下面两行前面的 ‘#’</p><pre><code> ```           SSLCertificateFile &quot;/private/etc/apache2/ssl/server.crt&quot; SSLCertificateKeyFile &quot;/private/etc/apache2/ssl/server.key&quot; ```</code></pre></li><li><p><code>/private/etc/apache2/extra/httpd-vhosts.conf</code>，编辑这个文件在<code>&#39;NameVirtualHost*:80&#39;</code> 后面添加</p><pre><code> &lt;VirtualHost *:443&gt;     SSLEngine on     SSLCipherSuite ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP:+eNULL     SSLCertificateFile /private/etc/apache2/ssl/server.crt     SSLCertificateKeyFile /private/etc/apache2/ssl/server.key     ServerName localhost     DocumentRoot &quot;/Library/WebServer/Documents&quot; &lt;/VirtualHost&gt;</code></pre></li></ul></li><li><p>复制凭证和密钥到apache2目录下<br>将/private/ect/apache2/ssl中的server.crt,server.key 复制到/private/ect/apache2/下</p></li><li><p>到这里就配置完了，检查配置，没问题的话重启Apache就好了</p><pre><code> sudo apachectl configtest 检查配置 sudo apachectl -k restart 强制重启</code></pre></li><li><p>在浏览器中输入：可以正常访问<br><a href="https://localhost/" target="_blank" rel="noopener">https://localhost/</a> , <a href="https://192.168.0.1/" target="_blank" rel="noopener">https://192.168.0.1/</a> ,<a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> , <a href="http://192.168.0.106/" target="_blank" rel="noopener">http://192.168.0.106/</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Appache </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac上 Appache 的操作</title>
      <link href="/2016/09/02/Mac%E4%B8%8A-Appache-%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/09/02/Mac%E4%B8%8A-Appache-%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h1><ol><li>打开终端，运行启动Apache命令：<br><code>`</code><br>sudo apachectl start</li></ol><pre><code>2. 关闭命令：</code></pre><p>sudo apachectl stop</p><pre><code>3. 重启命令</code></pre><p>sudo apachectl restart</p><pre><code>4. 查看Apache版本命令</code></pre><p>httpd –v</p><pre><code>5. 语法检测</code></pre><p>apachectl configtest</p><pre><code>6. 查看Apache版本号：</code></pre><p>httpd -v</p><pre><code>&lt;!-- more --&gt;# Root目录启用Apache之后，可以直接在浏览器中访问`http://localhost`，如果出现”It works!”就表示运正常。启用Apache之后，首先得知道网页文件应该放在哪个目录才能正常运行。Mac OS X 中默认有两个目录可以直接运行Web程序，一个是系统级的根目录，一个是用户级的根目录。* 系统级的根目录是：</code></pre><p>  /Library/WebServer/Documents/</p><pre><code>  它对应的网址是:</code></pre><p>  <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a></p><pre><code>* 用户级的根目录是:</code></pre><p>  ~/Sites</p><pre><code>  这里需要注意的~/Sites也就是你用户目录下面的”站点”目录，在OS X 10.8以后，这个目录可能没有，所以你需要手动建立一个同名目录。建立方式很简单，直接在终端中运行：</code></pre><p>  sudo mkdir ~/Sites</p><pre><code>  或者可以直接在目录中新建Sites文件夹## 配置用户级目录  1. 创建有户目录“Sites”文件夹，找开终端：</code></pre><pre><code>sudo mkdir ~/Sites```</code></pre><ol start="2"><li><p>进入 /etc/apache2/users/</p><pre><code>cd /etc/apache2/users/sudo vim username.conf</code></pre><p>添加内容为：</p><pre><code>&lt;Directory &quot;/Users/yuanpinghua/Sites/&quot;&gt; AllowOverride All Options Indexes MultiViews FollowSymLinks Require all granted&lt;/Directory&gt;</code></pre><p>上行中的<code>yuanpinghua</code>就是用户名，然后将该文件权限改为：644</p><pre><code>sudo chmod 644 username.conf</code></pre><ol start="3"><li>进到/etc/apache2/目录，sudo vim httpd.conf 将下面三句话的注释去掉：<pre><code>LoadModule authz_core_module libexec/apache2/mod_authz_core.soLoadModule authz_host_module libexec/apache2/mod_authz_host.soLoadModule userdir_module libexec/apache2/mod_userdir.soInclude /private/etc/apache2/extra/httpd-userdir.conf</code></pre>将这四句前的“#”去掉</li><li>进到/etc/apache2/extra/目录，<pre><code>sudo vim httpd-userdir.conf</code></pre>将<code>Include /private/etc/apache2/users/*.conf</code>这句话放开注释。</li><li>然后终端输入：<code>sudo apachectl restart</code>重启apache，浏览器输入：<code>loacal/~yuanpinghua/</code> 就可以正常显示该目录下的文件</li></ol></li></ol><p>参考网页：<br><a href="http://www.aichengxu.com/view/4587749" target="_blank" rel="noopener">在Mac上配置Apache+PHP环境</a><br><a href="http://www.jianshu.com/p/7b8d5d6f22c9" target="_blank" rel="noopener">Mac OS X 上的Apache配置</a><br><a href="http://www.aichengxu.com/view/10044030" target="_blank" rel="noopener">Mac OS X EI Captitan 中Apache开启SSL (HTTPS)</a><br><a href="http://www.cnblogs.com/y500/p/3596473.html" target="_blank" rel="noopener">Mac OS X中Apache开启ssl</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Appache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC环境下内存问题</title>
      <link href="/2016/09/01/ARC%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2016/09/01/ARC%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<pre><code class="objc">NSMutableArray * array  = [NSMutableArray arrayWithArray:@[@&quot;2&quot;,@&quot;2&quot;,@&quot;1&quot;,@&quot;fad&quot;,@&quot;23&quot;]];for(NSString* str  in array){  if (str isEqualToString:@&quot;fad&quot;]) {    [array removeObject:str];  }}</code></pre><p>编译运行时出现崩溃：</p><pre><code>Terminating app due to uncaught exception &#39;NSGenericException&#39;, reason: &#39;*** Collection &lt;__NSArrayM: 0x100103560&gt; was mutated while being enumerated.&#39;</code></pre><pre><code class="objc">NSMutableArray * array  = [NSMutableArray arrayWithArray:@[@&quot;2&quot;,@&quot;2&quot;,@&quot;1&quot;,@&quot;fad&quot;,@&quot;23&quot;]];[array enumerateObjectsUsingBlock:^(NSString*  obj, NSUInteger idx, BOOL *  stop) {           if ([obj isEqualToString:@&quot;fad&quot;]) {               [array removeObject:obj];           }       }];   </code></pre><pre><code class="objc">NSMutableArray * arrayNum  = [NSMutableArray arrayWithArray:@[@(2),@(21),@(1),@(100),@(23)]];[arrayNum enumerateObjectsUsingBlock:^(NSNumber *  obj, NSUInteger idx, BOOL *  stop) {           if ([obj isEqualToString:@(2)]) {               [arrayNum removeObject:obj];           }       }];   </code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block学习</title>
      <link href="/2016/08/28/Block%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/08/28/Block%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Blocks概要"><a href="#Blocks概要" class="headerlink" title="Blocks概要"></a>Blocks概要</h1><h2 id="什么是Blocks"><a href="#什么是Blocks" class="headerlink" title="什么是Blocks"></a>什么是Blocks</h2><p>Blocks是Ｃ语言的扩充功能。有一句话来表示Blocks的扩充功能：带有自动变量（局部变量）值的匿名函数。</p><blockquote><p>“匿名函数”：不带名称的函数</p></blockquote><a id="more"></a><ol><li>Ｃ语言中函数的声明与使用<pre><code class="c">int function(int count);//声明名为func的函数int res = function(10);//使用函数名称调用</code></pre></li><li><p>Ｃ中使用函数指针调用函数</p><pre><code class="c">int (* funptr)(int) = &amp;function;//定义函数指针，取得函数的地址int res = (* funptr)(10);//通过函数指针调用函数</code></pre><p>通过Blocks，源代码中就能够使用匿名函数。</p><blockquote><p>对于开发人员而言，命名是工作的本质，函数名、变量名、方法名、属性名、类名和框架名等都必须具备。能够编写不带名称的函数对研发人员相当具有吸引力。</p></blockquote></li><li><p>回顾Ｃ语言的函数中可能使用的变量</p><ul><li>自动变量（局部变量）</li><li>函数的参数</li><li>静态变量（静态局部变量）</li><li>静态全局变量</li><li>全局变量<br>其中，在函数的多次调用之间能够传递值的变量有：</li><li>静态全局变量</li><li>静态变量（静态局部变量）</li><li>全局变量<br>这些变量的作用域不同，但在整个程序当中，一个变量总保持在一个内存区域。因此，当多次调用函数时，该变量值总能保持不变，在任何时候以任何状态调用，使用的都是同样的变量值。</li></ul></li></ol><p>“带有自动变量值的若名函数”这一概念并不仅指Blocks，它还存在其他程序语言中。在计算机科学中，称为“闭包（Closure）”、lambda计算 等；<br>如下表：</p><table><thead><tr><th style="text-align:left">程序语言</th><th style="text-align:left">Block名称</th></tr></thead><tbody><tr><td style="text-align:left">C+Block</td><td style="text-align:left">Block</td></tr><tr><td style="text-align:left">SmallTallk</td><td style="text-align:left">Block</td></tr><tr><td style="text-align:left">Ruby</td><td style="text-align:left">Block</td></tr><tr><td style="text-align:left">LISP</td><td style="text-align:left">lambda</td></tr><tr><td style="text-align:left">Python</td><td style="text-align:left">lambda</td></tr><tr><td style="text-align:left">C++11</td><td style="text-align:left">lambda</td></tr><tr><td style="text-align:left">javascript</td><td style="text-align:left">Anonymous function</td></tr></tbody></table><h1 id="Blocks模式"><a href="#Blocks模式" class="headerlink" title="Blocks模式"></a>Blocks模式</h1><h2 id="Block语法"><a href="#Block语法" class="headerlink" title="Block语法"></a>Block语法</h2><p>block块：</p><pre><code class="objc">//使用block 定义一个加操作^(int a,int b){       NSLog(@&quot;%d&quot;,a+b);   };// 其完整的形式是^void(int a,int b){       NSLog(@&quot;%d&quot;,a+b);   };</code></pre><p>C语言函数</p><pre><code class="c">//定义一个加方法void add(int a,int b){    NSLog(@&quot;%d&quot;,a+b);}</code></pre><p>将上面两个代码进行比较，我们发现完整的Block语法与一般的Ｃ语言函数相比，有以下同点：</p><ul><li>没有函数:Block是匿名函数</li><li>带有”^”: 返回值前带有“^”(插入记号).  </li></ul><ol><li><p>Block的完整语法</p><pre><code>^ 返回值类型 (参数列表){表达式};</code></pre><p>示例：</p><pre><code class="objc">//定义一个加方法int  add(int a,int b){ return a+b ;}</code></pre><blockquote><p>“返回值类型”同Ｃ语言函数的返回值类型，“参数列表”同Ｃ语言的参数列表，“表达式”同Ｃ语言函数中允许使用的表达式。当然与Ｃ语言函数一样，表达式中含有return语句时，其类型必须与返回值类型相同。</p></blockquote></li><li><p>省略返回值类型</p><pre><code> ^ 返回值类型 (参数列表){表达式};==&gt; ^ (参数列表){表达式};</code></pre><p>示例：  </p><pre><code class="objc">^(int a,int b){   NSLog(@&quot;%d&quot;,a+b);};^(int a,int b){   return a+b;};</code></pre><blockquote><p>省略返回值类型，如果表达式中有return 语句就使用该返回值类型，如果表达式没有return语句，使用void类型。表达工中含有多个return语句时，所有return的返回值类型必须相同。</p></blockquote></li><li><p>省略返回值类型和参数列表</p><blockquote><p>如果不使用参数，参数列表也可以省略  </p></blockquote><pre><code>^ 返回值类型 (参数列表){表达式};==&gt; ^{表达式};</code></pre><p>示例：</p><pre><code class="objc">^{      //TODO:: do something      NSLog(@&quot;hello&quot;);  };^{    //TODO::do something   return @&quot;hello&quot;;};</code></pre></li></ol><h2 id="Block类型变量"><a href="#Block类型变量" class="headerlink" title="Block类型变量"></a>Block类型变量</h2><blockquote><p>从Block语法的表述方式上来看，除了没有名称及带有“^”以外，其他都与Ｃ语言函数定义一样。在定义Ｃ函数时，可以将所定义的函数地址赋值给函数指针类型变量中。</p></blockquote><pre><code class="c">// 定义名为add的一个加法int add(int add1,int add2){  return add2+add1;}int (*funcPtr)(int,int)=&amp;add;//定义函数指针类型变量，并将变量指向add函数的地址</code></pre><p>同样地，在Block语法下，可以将Block语法赋值给声明为Block类型的变量中。<br>声明Block类型变量示例：</p><pre><code class="objc">int (^add)(int add1,int add2);</code></pre><p>对比函数指针的定义，会发现声明Block类型变量仅仅是将声明函数指针类型变量的“＊”变成了“^”.Block类型变量与一般Ｃ语言变量完全相同，可以作以下用途使用：</p><ul><li>自动变量</li><li>函数参数</li><li>静态变量</li><li>静态全局变量</li><li>全局变量</li></ul><p>使用Block语法将Block赋值为Block类型变量：</p><pre><code class="objc">int (^add)(int add1,int add2)=^(int add1,int add2){       return add1+add2;   };</code></pre><p>由“^”开始的Block语法生成Block被赋值给变量add中，Block变量与一般的变量一样，所以，也可以由Block类型变量向Block类型变量赋值。</p><pre><code class="objc">    int (^add1)(int,int)= add;    int (^add2)(int,int);    add2= add1;</code></pre><p>在函数参数中可以使用Block变量向函数传递Block:</p><pre><code class="objc">void addFunc(int (^add)(int)){    add(12);}</code></pre><p>在函数返回值中指字Block类型，可以将Block作为函数的返回值返回：</p><pre><code class="objc">int (^func())(int) {    return^(int count){        return count+1;    };};</code></pre><p>使用typedef简化Block的声明和使用：</p><pre><code class="objc">// typedef 的语法规则typedef &lt;#returnType#&gt;(^&lt;#name#&gt;)(&lt;#arguments#&gt;);</code></pre><p>通过typedef,我们将上述函数中使用的Block,和函数返回值指定Block返回类型重写：</p><pre><code class="objc">typedef int (^addBlock)(int);//定义一个block类型// 在函数参数中传递blockvoid addFunc(addBlock add) {  add(12);}// 返回block类型返回值addBlock func(){    return ^(int number){        return number+1;    };};</code></pre><blockquote><p>在Ｃ语言中可以使用函数指针，那么block是否也可以使用Block指针类型变量呢？<br>答案：那是肯定的 。block类型变量可以像Ｃ语言中其类型变量一亲使用。</p></blockquote><pre><code class="objc">typedef int (^pointBlock)(int);pointBlock block = ^(int count){  return count+1;};pointBlock * pointB= &amp;block;(*pointB)(10);</code></pre><h2 id="截获自动变量值"><a href="#截获自动变量值" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><blockquote><p>通过前面的block语法和block类型变量的说明，我们已经知道，block是“带有自动变量值的匿名函数”，与Ｃ语言函相比中，我们对匿名函数的理解会更加深入，“带有自动变量值”在block中是怎么样的表现形式？＝＝＝&gt; “截获自动变量值”</p></blockquote><pre><code class="objc">  int val = 100;  const char *fmt = &quot;val = %d\n&quot;;  void (^block)() =^{    printf(fmt,val );  };  val = 1000;  fmt =&quot;val value was changed .val = %d\n&quot;;  block();</code></pre><p><strong>Block语法的表达式中使用的是在它之前声明的自动变量fmt和val.在Block中Block表达式截获所使用的局部变量的值，即何存该局部变量的瞬间值。因为Block表达式保存了局部变量的值，所以在执行Block语法后，改动block表达式中使用的局部变量的值也不会影响Block执行时局部变量的值</strong></p><h2 id="block说明符"><a href="#block说明符" class="headerlink" title="__block说明符"></a><code>__block</code>说明符</h2><blockquote><p>局部变量值截获只能保存执行Block语法瞬间的值，保存后不能改写该值</p></blockquote><p>尝试改写截获的局部变量的值：</p><pre><code class="objc">int val = 100;void (&amp;block)()=^ {  val = 10000;//给局部变量赋上新值};block();printf(&quot;val = %d\n&quot;,val );</code></pre><p>尝试编译该段代码，Xcode6会给一个大大的红色错误警告，警告内容为：<code>Variable is not assignable (missing __block type specifier)</code>  </p><p>若想在Block语法的表达式中将值赋值给在Block语法外声明的局部变量，需要在自动变量上附加<code>__block</code>修饰符。将上述代码进行改正后如下：</p><pre><code class="objc">__block int val = 100;void (^block)()=^ {  val = 10000;//给局部变量赋上新值};block();printf(&quot;val = %d\n&quot;,val );</code></pre><p>该代码段可以正常运行。</p><blockquote><p>使用附有 <code>__block</code>修饰符的局部变量可以Block中赋值。该变量称为<code>__block</code>变量</p></blockquote><h2 id="截获的自动变量"><a href="#截获的自动变量" class="headerlink" title="截获的自动变量"></a>截获的自动变量</h2><p>在前面<strong>block修饰符一小节中，我们了解到，在没有加</strong>block修饰符，直接去修改block语法表达式中截获的自动变量的值时，会产生编译错误。那么截获OC对象会产生编译错误吗？</p><pre><code class="objc">NSMutableArray *array = [NSMutableArray array];void (^block)()=^  {  id obj = [[NSObject alloc]init];  [array addObject:obj];}block();</code></pre><p>代码编译运行没有问，若向变量赋上新的值就会产生编译错误了，代码如下：</p><pre><code class="objc">NSMutableArray *array = [NSMutableArray array];void (^block)()=^  {  array = [NSMutableArray array];}block();</code></pre><p>上述代码同样会产生<code>//  Variable is not assignable (missing __block type specifier)</code>错误提示<br>解决办法就是在array前添加__block修饰符</p><pre><code class="objc">__block NSMutableArray *array = [NSMutableArray array];void (^block)()=^  {  array = [NSMutableArray array];}block();</code></pre><p>使用C语言数组时的指针的坑：</p><pre><code class="c">const char text[]= &quot;hello&quot;;void (^block)() =^  {printf(&quot;%c\n&quot;, text[2]);};</code></pre><p><strong>使用Ｃ语言的字符串数组，而没有向截获的自动变量赋值 肯定没有什么问题？</strong><br>编译代码后得到：<code>Cannot refer to declaration with an array type inside block</code>错误提示<br>因为现在block中，截获的自动变量的方法并没有实现对Ｃ语言数组的截获。使用指针可以解决这个问题</p><pre><code class="c">const char *text = &quot;hello&quot;;void (^block)() =^  {printf(&quot;%c\n&quot;, text[2]);};</code></pre><h1 id="Blocks实现"><a href="#Blocks实现" class="headerlink" title="Blocks实现"></a>Blocks实现</h1><h2 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h2><blockquote><p>Block是带有自动变量值的匿名函数，但block究竟是什么？</p></blockquote><p>Clang(LLVM编译器)具有转换为可读源码的功能。通过“-rewrite-objc”选项能将Block语法的源码转成C++源码（struct结构体）。<br>使用方法：</p><pre><code class="c">clang -rewrite-objc 源码文件名</code></pre><p>以最为简单的block代码为例：</p><pre><code class="objc">#include&quot;stdio.h&quot;int main(){    void(^block)()=^{        printf(&quot;hello&quot;);    };    block();    return 0;}</code></pre><p>将以上代码Clang成源码：</p><pre><code class="objc">struct __block_impl {    void *isa;    int Flags;    int Reserved;    void *FuncPtr;};struct __main_block_impl_0 {  struct __block_impl impl;  struct __main_block_desc_0 * Desc;  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) {    printf(&quot;hello&quot;);}static struct __main_block_desc_0 {  size_t reserved;  size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main(){void(*block)()=((void ( *)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));((void ( *)(__block_impl * ))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);return 0;}static struct IMAGE_INFO { unsigned version; unsigned flag; } _OBJC_IMAGE_INFO = { 0, 2 };</code></pre><p>接下来我们来细读下这段代码：<br>最初的block语法：</p><pre><code class="objc">    ^{      printf(&quot;hello&quot;);    };</code></pre><p>转换后：</p><pre><code class="objc">static void __main_block_func_0(struct __main_block_impl_0 *__cself) {    printf(&quot;hello&quot;);}</code></pre><p>由上述代码所示，Block使用的匿名函数实际上被作为简单的C语言函数来处理。另外，根据Block语法所属的函数名（这里是main）和Block语法在该函数出现的位置顺序值来给经clang变换的函数命名。</p><h3 id="了解clang源码中的结构体"><a href="#了解clang源码中的结构体" class="headerlink" title="了解clang源码中的结构体"></a>了解clang源码中的结构体</h3><p>  先看该Ｃ函数的参数的声明：</p><pre><code class="c">  struct __main_block_impl_0 *__cself</code></pre><p>  参数<code>__cself</code>是<code>__main_block_impl_0</code>结构体指针，该结构体的声明如下：</p><pre><code class="c">  struct __main_block_impl_0 {    struct __block_impl impl;    struct __main_block_desc_0 * Desc;  };</code></pre><p>  为简单明了，此处将构造函数给去了。第一个成员变量是<code>impl</code>,是<code>__block_impl</code>的一个变量，其结构体的声明如下：</p><pre><code class="c">  struct __block_impl {      void *isa;      int Flags;      int Reserved;      void *FuncPtr;//函数指针  };</code></pre><p>  第二个成员变量是<code>Desc</code>指针，是<code>__main_block_desc_0</code>结构体的一个变量，其声明如下：</p><pre><code class="c">  static struct __main_block_desc_0 {    size_t reserved;//保留区域    size_t Block_size;//Block的大小  };</code></pre><p>  接下来我们来看下初始化含有这些结构体的<code>__main_block_impl_0</code>结构体构造函数:</p><pre><code class="c">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {    impl.isa = &amp;_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }</code></pre><p>以上是初始化<code>__main_block_impl_0</code>结构体成员的源码，<code>_NSConcreteStackBlock</code>用于初始化<code>__block_impl</code>结构体的<code>isa</code>成员，在后面会对<code>_NSConcreteStackBlock</code>进行讲解。</p><h3 id="调用结构体构造函数"><a href="#调用结构体构造函数" class="headerlink" title="调用结构体构造函数"></a>调用结构体构造函数</h3><p>  以下是<code>__main_block_impl_0</code>结构体构造函数的调用：</p><pre><code class="c">  void(*block)()=((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</code></pre><p>  什么鬼，看不懂，分解他：</p><pre><code class="c">  struct __main_block_impl_0 temp =__main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA);//生成`__main_block_impl_0`结构体实例的变量  struct __main_block_impl_0 *blk = &amp;temp;//将生成的实例变量赋值给结构体指针</code></pre><p>  上述代码对应的源码：</p><pre><code class="objc">  void(^block)()=^{         printf(&quot;hello&quot;);     };</code></pre><blockquote><p>将block语法生成的block赋给block类型的变量block，等同于将<code>__main_block_impl_0</code>结构体实例的指针赋给变量blk.该源码中的Block就是<code>__main_block_impl_0</code>结构体类型的自动变量blk.</p></blockquote><h3 id="深入-main-block-impl-0构造函数"><a href="#深入-main-block-impl-0构造函数" class="headerlink" title="深入__main_block_impl_0构造函数"></a>深入<code>__main_block_impl_0</code>构造函数</h3><p>  构造函数：</p><pre><code class="objc">  __main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA);</code></pre><p>第一个参数是由Block语法转换成Ｃ语言函数指针。第二个参数是作为静态全局变量初始化的<code>__main_block_desc_0</code>结构体实例指针。<br>以下为<code>__main_block_desc_0</code>结构体实例化部分代码：</p><pre><code class="c">static struct __main_block_desc_0   __main_block_desc_0_DATA = {  0,  sizeof(struct __main_block_impl_0)};</code></pre><p>该源码中使用Block,即__main_block_impl_0结构体实例的大小进行初始化。</p><h3 id="展开后的-main-block-impl-0"><a href="#展开后的-main-block-impl-0" class="headerlink" title="展开后的__main_block_impl_0"></a>展开后的<code>__main_block_impl_0</code></h3><p>我们来看下栈上的<code>__main_block_impl_0</code>结构体实例如何根据参数进行初始化。将结构体中的<code>__block_impl</code>展开，会是如下形式：</p><pre><code class="C">struct __main_block_impl_0{  void *isa;  int Flags;  int Reserved;  void *FuncPtr;  struct __main_block_desc_0 * Desc;}</code></pre><p>该构造函数会像下面一样进行初始化：</p><pre><code class="C">isa= &amp; _NSConcreteStackBlock;Flags= 0;Reserved= 0;FuncPtr= __main_block_func_0;Desc= &amp; __main_block_desc_0_DATA;</code></pre><h3 id="block的调用"><a href="#block的调用" class="headerlink" title="block的调用"></a>block的调用</h3><p>说了这么久，还没有看到block的调用，接下来我们分析下block的调用</p><pre><code class="objc">   block();</code></pre><p>转换后的源码：</p><pre><code class="objc">((void ( * )(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</code></pre><p>转换部分太多太杂，去掉他：</p><pre><code class="objc">（*block-&gt;impl.FuncPtr）(block);</code></pre><p>这就是简单的使用函数指针调用函数。正如我们所确认的,由Block语法转换的<code>__main_block_func_0</code>函数的指针被赋值给成员变量<code>FuncPtr</code>.另外，<code>__main_block_func_0</code>的参数<code>__cself</code>指向<code>Block</code>。在调用该函数的源代码中可以看出block正是作为以数进行了传递。</p><h3 id="解密isa"><a href="#解密isa" class="headerlink" title="解密isa"></a>解密<code>isa</code></h3><p>在刚才我们看到这样的一句代码：</p><pre><code class="objc"> isa= &amp;_NSConcreteStackBlock;</code></pre><p> 将Block指针赋给Block的结构体成员变量<code>isa</code>.要理解<code>isa</code>是何方神圣，我们需要先了解下OC的类和对象的实质。Block就是OC对象。<br> 我们将一个简单person类，clang下它的源码：</p><pre><code class="objc"> @interface Person : NSObject{    int a ;    int age;}@end</code></pre><p> clang后的代码，我将分散的代码集中到一块了：</p><pre><code class="objc"> #ifndef _REWRITER_typedef_Person#define _REWRITER_typedef_Persontypedef struct objc_object Person;typedef struct {} _objc_exc_Person;#endifstruct objc_object {    Class isa __attribute__((deprecated));};typedef struct objc_object *id;//这个是在runtime.h文件中找到的struct objc_class {    Class isa  OBJC_ISA_AVAILABILITY;};typedef struct objc_class *Class;struct NSObject_IMPL {    Class isa;};struct Person_IMPL {    struct NSObject_IMPL NSObject_IVARS;    int a;    int age;};</code></pre><p>“id”类型变量主要用于存放OC对象。我们可以像使用 <code>void *</code> 那样使用id.由上述clang中的代码我们发现id的声明如下：</p><pre><code class="objc">  typedef struct objc_object *id;</code></pre><p><code>id</code>是<code>objc_object</code>结构体的一个指针类型变量，<code>objc_object</code>其声明如下：</p><pre><code class="objc">  struct objc_object {      Class isa __attribute__((deprecated));  };</code></pre><p>该结构体中只有一个<code>isa</code>成员变量，<code>Class</code>又是什么呢？</p><pre><code class="objc">typedef struct objc_class *Class;</code></pre><p><code>Class</code>是<code>objc_class</code>的指针类型变量，<code>objc_class</code>又是什么东西，在runtime.h文件中，我找到了如下代码：</p><pre><code class="objc">//这个是在runtime.h文件中找到的struct objc_class {    Class isa  OBJC_ISA_AVAILABILITY;};</code></pre><p>与<code>objc_object</code>结构体相对比，我们发现，它们的结构体成员都是一样的。<code>objc_object</code>和<code>objc_class</code>结构体都是各个对象和类的实现中使用的最基本的结构体。</p><p>我们回过头来看下，刚才声明<code>Person</code>类：</p><pre><code class="objc">@interface Person : NSObject{   int a ;   int age;}@end</code></pre><p>clang转换后的结构体为：</p><pre><code class="objc">struct Person_IMPL {    struct NSObject_IMPL NSObject_IVARS;    int a;    int age;};</code></pre><p>将结构体中使用到的<code>NSObject_IMPL</code>结构体：</p><pre><code class="objc">struct NSObject_IMPL {    Class isa;};</code></pre><p>展开后，得到：</p><pre><code class="objc">struct Person_IMPL {  Class isa;    int a;    int age;};</code></pre><p>类中的a ,age实例变量被直接转换成结构体的成员。<br>“OC中由类生成的对象”意味着，像该结构体“生成由该类生成的对象的结构体实例”。生成的各个对象（生成由该类生成的对象的结构体实例）通过成员变量isa保持该类的结构体实例指针。</p><blockquote><p>各类的结构体是基于<code>objc_class</code>结构体的<code>class_t</code>结构体。<code>class_t</code>结构体在objc4运行库中的声明如下：<a href="https://opensource.apple.com/source/objc4/objc4-437/runtime/objc-runtime-new.h" target="_blank" rel="noopener">runtime</a></p><pre><code class="objc">typedef struct class_t {    struct class_t *isa;    struct class_t *superclass;    Cache cache;    IMP *vtable;    class_rw_t *data;} class_t;</code></pre><p>在ＯＣ中，如NSMutableArray的class_t实例和NSObject的class_t实例，均生成并保持各个类的class_t结构体实例，该实例持有声明的成员变量，方法的名称，方法的实现（函数指针），属性及父类的指针，并被OC 运行时库使用。</p></blockquote><p>回到__main_block_impl_0结构体：</p><pre><code class="C">struct __main_block_impl_0{  void *isa;  int Flags;  int Reserved;  void *FuncPtr;  struct __main_block_desc_0 * Desc;}</code></pre><p>该__main_block_impl_0结构体相当于基于objc_object结构体的OC类对象的结构体。对成员变量isa的初始化如下：</p><pre><code class="objc">isa =&amp;_NSConcreteStackBlock;</code></pre><p><code>_NSConcreteStackBlock</code>相当于class_t结构体实例。在将Block作为OC对象处理里，关于该类的信息放_NSConcreteStackBlock中。</p><blockquote><p>Block 实质就是OC对象。</p></blockquote><h2 id="截获自动变量值-1"><a href="#截获自动变量值-1" class="headerlink" title="截获自动变量值"></a>截获自动变量值</h2><h2 id="block说明符-1"><a href="#block说明符-1" class="headerlink" title="__block说明符"></a><code>__block</code>说明符</h2><h2 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h2><h2 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a><code>__block</code>变量存储域</h2><h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><h2 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a><code>__block</code>变量和对象</h2><h2 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h2><h2 id="copy-release"><a href="#copy-release" class="headerlink" title="copy/release"></a>copy/release</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS @property、 @synthesize和@dynamic</title>
      <link href="/2016/08/23/iOS-synthesize%E5%92%8C-dynamic/"/>
      <url>/2016/08/23/iOS-synthesize%E5%92%8C-dynamic/</url>
      
        <content type="html"><![CDATA[<h1 id="property"><a href="#property" class="headerlink" title="@property"></a><code>@property</code></h1><p>  <code>@Property</code>是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器</p><blockquote><p>存取器（accessor）：指用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。<br>用<code>@Property</code>声明一个属性之后, 编译器会自动给你生成setter和getter方法的声明以及实现还有一个以_xxx 的成员变量(xxx是你属性定义的变量名字)  </p></blockquote>  <a id="more"></a><h1 id="property对应两个选择"><a href="#property对应两个选择" class="headerlink" title="@property对应两个选择"></a><code>@property</code>对应两个选择</h1><h2 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a><code>@synthesize</code></h2><ul><li><code>@synthesize</code> 能够为您的属性的<code>getter</code>和<code>setter</code>方法。有自定义会屏蔽自动生成的<code>getter</code>和<code>setter</code></li><li>Xcode6以后省略这个了, 默认在 <code>@implementation</code> .m中添加了<code>@synthesize xxx = _xxx</code>;</li><li>如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用<code>@synthesize</code>声明，系统会帮我们自动完成。<pre><code>    如果我们希望自己命名实例变量命，那么我们就使用`@synthesize`显示声明我们希望的实例变量名。</code></pre></li></ul><h2 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a><code>@dynamic</code></h2><ul><li><code>@dynamic</code> 不会自动生成<code>getter/setter</code>方法，需要自己实现，不然会报错</li><li>Xcode6以后省略这个了, 默认在 <a href="mailto:`@implementation.m" target="_blank" rel="noopener">`@implementation.m</a><code>中添加了</code>@synthesize xxx`;</li></ul><h1 id="property的特性"><a href="#property的特性" class="headerlink" title="@property的特性"></a><code>@property的特性</code></h1><p>  @property还有一些关键字，它们都是有特殊作用的，它们分为三类，分别是：原子性，存取器控制，内存管理。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul><li><code>atomic</code>（默认）：<code>atomic</code>意为操作是原子的，意味着只有一个线程访问实例变量。<code>atomic</code>是线程安全的，至少在当前的存取器上是安全的。它是一个默认的特性，但是很少使用，因为比较影响效率，这跟ARM平台和内部锁机制有关。</li><li><code>nonatomic</code>：<code>nonatomic</code>跟<code>atomic</code>刚好相反。表示非原子的，可以被多个线程访问。它的效率比<code>atomic</code>快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。</li></ul><h2 id="存取器控制"><a href="#存取器控制" class="headerlink" title="存取器控制"></a>存取器控制</h2><ul><li><code>readwrite</code>（默认）：<code>readwrite</code>是默认值，表示该属性同时拥有<code>setter</code>和<code>getter</code>。</li><li><code>readonly</code>： readonly表示只有<code>getter</code>没有<code>setter</code>。<br>有时候为了语意更明确可能需要自定义访问器的名字：<pre><code class="objc">@property (nonatomic, setter = mySetter:,getter = myGetter ) NSString *name;</code></pre>最常见的是BOOL类型，比如标识View是否隐藏的属性hidden。可以这样声明：<pre><code class="objc">@property (nonatomic,getter = isHidden ) BOOL hidden;</code></pre></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><blockquote><p><code>@property</code>有显示的内存管理策略。这使得我们只需要看一眼<code>@property</code>声明就明白它会怎样对待传入的值</p></blockquote><ul><li><code>assign</code>（默认）：<code>assign</code>用于值类型，如<code>int</code>、<code>float</code>、<code>double</code>和<code>NSInteger</code>、<code>CGFloat</code>等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。</li><li><code>retain</code>：在<code>setter</code>方法中，需要对传入的对象进行引用计数加1的操作。<br>简单来说，就是对传入的对象拥有所有权，只要对该对象拥有所有权，该对象就不会被释放。如下代码所示：<pre><code class="objc">-(void)setName:(NSString * )_name{     //首先判断是否与旧对象一致，如果不一致进行赋值。     //因为如果是一个对象的话，进行if内的代码会造成一个极端的情况：当此name的retain为1时，使此次的set操作让实例name提前释放，而达不到赋值目的。     if ( name !=_name){          [name release];          name = [_name retain];     }  }</code></pre></li><li><code>strong</code>：<code>strong</code>是在<code>iOS</code>引入<code>ARC</code>的时候引入的关键字，是<code>retain</code>的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。<code>strong</code>跟<code>retain</code>的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。</li><li><p><code>weak</code>：在<code>setter</code>方法中，需要对传入的对象不进行引用计数加1的操作。<br>简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用<code>weak</code>声明的实例变量指向<code>nil</code>，即实例变量的值为0。</p><blockquote><p>注：weak关键字是iOS5引入的，iOS5之前是不能使用该关键字的。<code>delegate</code>和 <code>Outlet</code> 一般用weak来声明。</p></blockquote></li><li><p><code>copy</code>：与<code>strong</code>类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS手机锁屏控制</title>
      <link href="/2016/08/19/iOS%E6%89%8B%E6%9C%BA%E9%94%81%E5%B1%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2016/08/19/iOS%E6%89%8B%E6%9C%BA%E9%94%81%E5%B1%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<pre><code class="objc"> [[UIApplication sharedApplication] setIdleTimerDisabled:YES];//禁止自动锁屏  [[UIApplication sharedApplication] setIdleTimerDisabled:NO];//允许自动锁屏</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD锁</title>
      <link href="/2016/08/16/GCD%E9%94%81/"/>
      <url>/2016/08/16/GCD%E9%94%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>何在GCD中快速的控制并发呢？<br>答案就是dispatch_semaphore</p></blockquote><a id="more"></a><h2 id="什么是dispatch-semaphore"><a href="#什么是dispatch-semaphore" class="headerlink" title="什么是dispatch_semaphore"></a>什么是dispatch_semaphore</h2><p>dispatch_semaphore是持有计数的信号,该计数是多线程编程中的计数类型信号,类似于过马路的信号灯,红灯表示不能通过,而绿灯表示可以通过.而在dispatch_semaphore中使用计数来实现该功能,进行更细粒度的排他控制.在没有Serial Dispatch Queue和dispatch_barrier_async函数那么大的粒度且一部分处理需要进行排他控制的情况下,dispatch Semaphore便可发挥威力  </p><h2 id="dispatch-semaphore语法说明"><a href="#dispatch-semaphore语法说明" class="headerlink" title="dispatch_semaphore语法说明"></a>dispatch_semaphore语法说明</h2><ol><li>通过<code>dispatch_semaphore_create(long value);</code>函数创建<code>Dispatch_Semaphore</code>,参数表示计数的初始值<pre><code class="objc">//参数说明//long value:表示计数的初始值dispatch_semaphore_t semaphore = dispatch_semaphore_create(long value);</code></pre></li></ol><ol start="2"><li><code>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code>函数等待<code>Dispatch Semaphore</code>的计数值大于或者等于1,当满足条件时计数器执行减法,并从wait函数中返回<br><strong>_当dispatch_semaphore_wait函数返回0时,可以安全地执行排他控制的处理_</strong></li></ol><pre><code class="objc">//参数说明//dispatch_semaphore_t dsema:操作的Dispatch_Semaphore对象//dispatch_time_t timeout:由dispatch_time_t类型值指定等待时间dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code></pre><ol start="3"><li><code>dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code>函数将 <code>Dispatch_Semaphore</code>的计数器加1</li></ol><pre><code class="objc">//参数说明//dispatch_semaphore_t dsema:操作的Dispatch_Semaphore对象dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code></pre><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>  没有加锁的情况下，异步添加1000个数据到数组中</p><pre><code class="objc">  void unusesemaphoreSameple(){     //1.创建全局队列    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);     //2.创建保存数据的可变数组    NSMutableArray * array = [NSMutableArray array];    //执行10000次操作    for (int i =0 ; i&lt;1000; i++) {         //异步添加数据        dispatch_async(queue, ^{             //处理数据            [array addObject:@(i)];        });    }    NSLog(@&quot;%@&quot;,array);}</code></pre><p>  执行结果是：代码出现问题，不能正常添加数据</p><pre><code>  GCDdispatch_semaphore(23505,0x700000081000) malloc: *** error for object 0x100700330: double free*** set a breakpoint in malloc_error_break to debug</code></pre><p>  加锁情况下，异步添加1000个数据到数组中</p><pre><code class="objc">  void usesemaphoreSameple(){    //1.创建全局队列    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);    //2.创建dispatch_semaphore_t对象    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);    //3.创建保存数据的可变数组    NSMutableArray * array = [NSMutableArray array];    //执行10000次操作    for (int i =0 ; i&lt;1000; i++) {        //异步添加数据        //数据进入,等待处理,信号量减1        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);        dispatch_async(queue, ^{            //处理数据            [array addObject:@(i)];            //数据处理完毕,信号量加1,等待下一次处理            dispatch_semaphore_signal(semaphore);        });    }    NSLog(@&quot;%@&quot;,array);}</code></pre><p>   执行结果：按顺序正常添加了1000个数据</p><pre><code class="objc">   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,   22,   ....</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSTimer</title>
      <link href="/2016/08/12/NSTimer/"/>
      <url>/2016/08/12/NSTimer/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建"><a href="#一、创建" class="headerlink" title="一、创建"></a>一、创建</h2><pre><code class="objc">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep NS_DESIGNATED_INITIALIZER;</code></pre><a id="more"></a><p>注：</p><ol><li><p>timerWithTimeInterval 需要手动添加到 runloop 中。<br>scheduledTimerWithTimeInterval 不需要手动添加到 runloop 中，创建timer已直接添加到 runloop 中。</p></li><li><p>一次性的timer在完成调用以后会自动将自己invalidate，而重复的timer则将永生，直到你显示的invalidate它为止。</p></li><li><p>repeats：timer是不一定准时的，是有可能被delay的，每次间隔的时间是不一定一样的。</p></li></ol><blockquote><p>API: A repeating timer reschedules itself automatically based on the scheduled firing time, not the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so much that it misses one or more of the scheduled firing times, the timer is fired only once for the missed time period. After firing for the missed period, the timer is rescheduled for the next scheduled firing time.</p></blockquote><p>译文：一个repeat的timer，它在创建的时候就把每次的执行时间算好了，而不是真正启动的时候才计算下次的执行时间。举个例子，假如一个timer在一个特定的时间t激活，然后以间隔5秒的时间重复执行。那么它的执行操作的时间就应该为t, t+5, t+10,… 假如它被延迟了，例如实际上timer在t＋2的时候才启动，那么它下次执行的时间还是t＋5，而并不是t＋2+5，如果很不幸地在t＋5还没有启动，那么它理应该在t执行的操作就跟下一次t＋5的操作合为一个了。至于为什么会延迟呢，这就跟当前线程的操作有关，因为timer是同步交付的，所以假如当前线程在执行很复杂的运算时，那必须等待运算的完成才能调用timer，这就导致了timer的延迟。</p><h2 id="二、使用（触发）"><a href="#二、使用（触发）" class="headerlink" title="二、使用（触发）"></a>二、使用（触发）</h2><pre><code class="objc">- (void)fire; //立即触发计时器@property (copy) NSDate *fireDate; //触发时间@property NSTimeInterval tolerance NS_AVAILABLE(10_9, 7_0); //误差值</code></pre><p>计时器允许其触发比预定触发的日期晚,计时器可能在预定时间 到 预定时间 ＋ 误差值 之间被触发。预定触发之前不会触发。对于重复计时器,下一次触发时间是从原先的预定时间计算从而会单个触发的时间的误差值。默认值为0。系统有权运用少量的宽容某些计时器而忽略这个属性的值。</p><p>注：</p><ol><li><p>timer 和 runloop<br>一个线程默认又一个runloop，子线程的runloop需要手动启动，在子线程中使用timer要启动NSRunLoop。当在非main thread中perform selector时，其thread中必须有一个激活的run loop。对于你自己创建的thread而 言，只有你的代码显式的运行一个run loop后该perform selector才能得到执行。Run loop在当loop运行时处理所有已排队的perform selector，而不是在一个loop循环时只处理某一个perform selector。</p></li><li><p>确保runloop mode的匹配<br>通常是主线程的default mode，NSTimer与NSURLConnection默认运行在default mode下，这样当用户在拖动UITableView处于UITrackingRunLoopMode模式时，NSTimer不能fire,NSURLConnection的数据也无法处理。</p></li></ol><h3 id="附：runloop-mode"><a href="#附：runloop-mode" class="headerlink" title="附：runloop mode"></a>附：runloop mode</h3><ol><li><p>kCFRunLoopDefaultMode: 默认 mode，通常主线程在这个 Mode 下运行。</p></li><li><p>UITrackingRunLoopMode: 追踪mode，保证Scrollview滑动顺畅不受其他 mode 影响。</p></li><li><p>UIInitializationRunLoopMode: 启动程序后的过渡mode，启动完成后就不再使用。</p></li><li><p>GSEventReceiveRunLoopMode: Graphic相关事件的mode，通常用不到。</p></li><li><p>kCFRunLoopCommonModes: 占位mode，作为标记DefaultMode和CommonMode用。</p></li></ol><ol start="3"><li>timer 的后台任务</li></ol><p>NSTimer 普通只可以在前台执行，进入后台则不能执行（坑：模拟器后台可运行，真机不行），但可以在app中设置定时执行的任务，使用：setKeepAliveTimeout: handler: 设置后台运行时的定时任务。</p><p>1、在Info.plist中添加UIBackgroundModes属性，即Required background modes，添加如VOIP、audio、location、蓝牙、download等。</p><p>2、使用setKeepAliveTimeout: handler:方法来注册一个周期性执行的任务, 而不管是否运行在后台.使用clearKeepAliveTimeout可以相应地清除该定时任务.</p><p>例：</p><pre><code class="objc">[[UIApplication sharedApplication] setKeepAliveTimeout:600 handler:^{[self reportDeviceInfo];}];</code></pre><h2 id="三、释放"><a href="#三、释放" class="headerlink" title="三、释放"></a>三、释放</h2><pre><code class="objc">- (void)invalidate;</code></pre><p>注：</p><ol><li><p>timer 的释放与创建必须在同一线程。</p></li><li><p>timer 的强引用：<br>timer 添加到runloop中，会被 runloop 强引用。解决方法：invalidate 方法，并且 timer ＝ nil；使得timer从runloop中release掉，<br>target 是strong类型，timer 强引用target，如果在target是viewController的话，则在其dealloc方法里面释放timer是不行的！viewController本身就不会释放。<br>解决方法：建立 target 与 timer 的弱引用关系。</p></li></ol><p>参考博客：<a href="http://blog.csdn.net/enuola/article/details/9163051" target="_blank" rel="noopener">http://blog.csdn.net/enuola/article/details/9163051</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单播，组播(多播)，广播以及任播</title>
      <link href="/2016/08/03/%E5%8D%95%E6%92%AD%EF%BC%8C%E7%BB%84%E6%92%AD-%E5%A4%9A%E6%92%AD-%EF%BC%8C%E5%B9%BF%E6%92%AD%E4%BB%A5%E5%8F%8A%E4%BB%BB%E6%92%AD/"/>
      <url>/2016/08/03/%E5%8D%95%E6%92%AD%EF%BC%8C%E7%BB%84%E6%92%AD-%E5%A4%9A%E6%92%AD-%EF%BC%8C%E5%B9%BF%E6%92%AD%E4%BB%A5%E5%8F%8A%E4%BB%BB%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p><strong>单播(unicast):</strong> 是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。<br><strong>组播(multicast):</strong> 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。<br><strong>广播(broadcast):</strong> 是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。<br><strong>任播(anycast):</strong> 是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</p><p>在Linux运行ifconfig, 如果网卡信息中包含UP BROADCAST RUNNING MULTICAST，则支持广播和组播。</p><h2 id="单播："><a href="#单播：" class="headerlink" title="单播："></a>单播：</h2><p>每次只有两个实体相互通信，发送端和接收端都是唯一确定的。在IPv4网络中，0.0.0.0到223.255.255.255属于单播地址。你对小月月喊“小月月”，那么只有小月月回过头来答应你。<br><img src="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/100px-Multicast.svg.png" alt="single"></p><h2 id="组播"><a href="#组播" class="headerlink" title="组播:"></a>组播:</h2><p>“组播”这个词通常用来指代IP组播。IP组播是一种通过使用一个组播地址将数据在同一时间以高效的方式发往处于TCP/IP网络上的多个接收者的协议。此外，它还常用来与RTP等音视频协议相结合。<br>互联网架构师戴夫·克拉克是这样描述IP组播的：“你把数据包从一头放进去，网络就会试图将它们传递到想要得到它们的人那里。”<br>组播报文的目的地址使用D类IP地址， D类地址不能出现在IP报文的源IP地址字段。<br>你在大街上大喊一声“美女”， 会有一群女性回头看你。<br><img src="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/100px-Multicast.svg.png" alt="multicast"></p><h2 id="广播"><a href="#广播" class="headerlink" title="广播:"></a>广播:</h2><p>并非所有的计算机网络都支持广播，例如X.25网络和帧中继都不支持广播，而且也没有在“整个互联网范围中”的广播。IPv6亦不支持广播，广播相应的功能由任播(anycast)代替。<br>通常，广播都是限制在局域网中的，比如以太网或令牌环网络。因为广播在局域网中造成的影响远比在广域网中小得多。</p><ul><li>以太网和IPv4网都用全1的地址表示广播，分别是ff:ff:ff:ff:ff:ff和255.255.255.255。</li><li>令牌环网络使用IEEE 802.2控制域中的一个特殊值来表示广播。<br>你在公司大喊一声“放假了”， 全部同事都会响应，大叫爽死了。<br><img src="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/100px-Broadcast.svg.png" alt="broadcast"></li></ul><h2 id="任播"><a href="#任播" class="headerlink" title="任播:"></a>任播:</h2><p>任播是与单播、广播和组播不同的方式。</p><ul><li>在单播中，在网络位址和网络节点之间存在一一对应的关系。</li><li>在广播和组播中，在网络位址和网络节点之间存在一对多的关系：每一个目的位址对应一群接收可以复制资讯的节点。</li><li>在任播中，在网络位址和网络节点之间存在一对多的关系：每一个位址对应一群接收节点，但在任何给定时间，只有其中之一可以接收到传送端来的资讯。在互联网中，通常使用边界网关协议来实现任播。作为老板，你在公司大喊一声“开发组的过来一个人”， 总会有一个人灰溜溜去响应， 挨批还是发钱啊？<br><img src="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/100px-Anycast.svg.png" alt="anycast"></li></ul><h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h2><p>组播组可以是永久的也可以是临时的。组播组地址中，有一部分由官方分配的，称为永久组播组。永久组播组保持不变的是它的ip地址，组中的成员构成可以发生变化。永久组播组中成员的数量都可以是任意的，甚至可以为零。那些没有保留下来供永久组播组使用的ip组播地址，可以被临时组播组利用。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TTL</title>
      <link href="/2016/08/01/TTL/"/>
      <url>/2016/08/01/TTL/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://baike.baidu.com/subview/2696/13746361.htm#reference-[1]-13746361-wrap" target="_blank" rel="noopener">TTL(生存时间值)</a></strong>：<br>TTL是time to live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量，TTL就IPv4包头的一个8bit字段。<br>TTL 的作用是限制IP数据包在计算机网络中的存在时间。TTL的最大值是255,TTL的一个推荐值是64。<br>虽然TTL从字面上翻译，是可以存活时间，但实际上TTL是IP数据包在计算机网络中可以转发的最大跳数。TTL字段由IP数据包发送者设置，在IP数据包从源到目的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把TTL值减1,然后将IP包转发出去。如果在IP包到达目的IP之前，TTL的值减为0,路由器将会丢弃收到的TTL＝0的IP包，并向IP包的发送者发送ICMP time exceeded消息。<br>生存时间，就是一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器(权威域名服务器）发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器(各地的缓存服务器，也叫递归域名服务器）中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。[1]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开发问题</title>
      <link href="/2016/07/28/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
      <url>/2016/07/28/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>今天在上传应用包到apptore里，发生了如下的一些问题：<br>ERROR ITMS-90242: “The product archive is invalid. The Info.plist must contain a LSApplicationCategoryType key, whose value is the UTI for a valid category. For more details, see “Submitting your Mac apps to the App Store”.”<br>====&gt;这个问题是由于我没有给应用设置类型，给应用设上对应的类型就可以了，我这里选择的是效率类</p><p>ERROR ITMS-90511: “CFBundleIdentifier Collision. The Info.plist CFBundleIdentifier value ‘$(PRODUCT_BUNDLE_IDENTIFIER)’ of ‘SHAREit.app/Contents’ is already in use by another application.”</p><p>ERROR ITMS-90277: “Invalid Bundle Identifier. The application bundle contains a tool or framework $(PRODUCT_NAME) [com.ushareit.SHAREit.pkg/Payload/SHAREit.app/Contents] using the bundle identifier ‘$(PRODUCT_BUNDLE_IDENTIFIER)’, which is not a valid bundle identifier.”</p><p>ERROR ITMS-90261: “Bad CFBundleExecutable. Cannot find executable file that matches the value of CFBundleExecutable in the nested bundle $(PRODUCT_NAME) [com.ushareit.SHAREit.pkg/Payload/SHAREit.app/Contents] property list file.”</p><p>ERROR ITMS-90280: “The CFBundleExecutable of two bundles may not point to the same file. The following shared bundle path have been found: SHAREit.app/Contents.”</p><p>＝＝＝＝＝&gt; 这几个问题呢，是由于我把info.plist文件放在 copy Bundle Resource 里面去了，只要将其从中删除就可以了 ＝＝》<br>选中对应的target ＝＝＝&gt; build Phases==&gt; copy bundle Resource  找到info.plist 文件，移除</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CFBundleName等关键字解析</title>
      <link href="/2016/07/28/CFBundleName%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/07/28/CFBundleName%E7%AD%89%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>CFBundleName:</strong> CFBundleName指定了该束的简称。简称应该小于16个字符并且适合在菜单和“关于”中显示。通过把它加入到适当的.lproj子文件夹下的InfoPlist.strings文件中，该关键字可以被本地化。如果您本地化了该关键字，那您也应该提供一个CFBundleDisplayName关键字的本地化版本。</p><a id="more"></a><p><strong>CFBundleDisplayName:</strong> CFBundleDisplayName关键字指定了一个字符串值来标识束的显示名称。Finder和其他用户界面组件会把它显示给用户。这个名称可以与文件系统中的束名不同。通过把关键字加入适当的.lproj子目录中的InfoPlist.strings文件，就可以实现该关键字的本地化。如果您需要本地化这个关键字，您还应该提供一个CFBundleName关键字的本地化版本</p><p><strong>CFBundleDevelopmentRegion:</strong> CFBundleDevelopmentRegion关键字指定了一个字符串值来标识束的地区。通常对应于作者的母语。如果不能找到用户首选的地区或语言的资源，系统最后会使用该值。</p><p><strong>CFBundleIdentifier:</strong> CFBundleIdentifier关键字指定了束的一个唯一的标识字符串。该标识符采用了类似Java包的命名方式，例如com.apple.myapp。该束标识符可以在运行时定位束。预置系统使用这个字符串来唯一地标识每个应用程序。</p><p><strong>CFBundleInfoDictionaryVersion:</strong> CFBundleInfoDictionaryVersion关键字指定了属性列表结构的当前版本号。该关键字的存在使得可以支持Info.plist格式将来的版本。在您建立一个束时，Project Builder会自动产生该关键字。</p><p><strong>CFBundleVersion:</strong> CFBundleVersion关键字指定了一个字符串用来标识创建号。该关键字的值通常随每一次创建而改变，并且会被显示在Cocoa”关于”对话框中的扩号里。</p><p>为了指定一个发布版的束的版本信息，可以使用CFBundleShortVersionString关键字。参见“CFBundleShortVersionString”。</p><p><strong>CFBundlePackageType:</strong> CFBundlePackageType关键字指定了束的类型，类似于Mac OS 9的文件类型代码。该关键字的值包含一个四个字母长的代码。应用程序的代码是‘APPL’；框架的代码是‘FMWK’；可装载束的代码是‘BND’。如果您需要，您也可以为可装载束选择其他特殊的类型代码。</p><p><strong>CFBundleSignature:</strong> CFBundleSignature关键字指定了束的创建者，类似于Mac OS 9中的文件创建者代码。该关键字的值包含四字母长的代码，用来确定每一个束。</p><p><strong>LSRequiresIPhoneOS:</strong> 因此如果你的应用只能在iPhone环境下使用的话，请设置为True。</p><p><strong>CFBundleAllowMixedLocalizations:</strong> 我们只需要在项目的 Info.plist文件中将这个键的值设置为 true。顾名思义，这个键允许混合形式的本地化。也就是说，当你设置了这个键之后，不管你的应用是否支持当前设备的语言环境，iOS系统都会尽可能都根据当前的语言进行本地化。</p><p><strong>CFBundleExecutable:</strong> CFBundleExecutable标识了束的可执行主文件的名称。对于一个应用程序来说,就是该应用程序的可执行文件。对于一个可加载束,它是一个可以被束动态加载的二进制文件。对于一个框架，它是一个共享库。Project Builder会自动把该关键字加入到合适项目的Info.plist文件中。</p><p>对于框架，考虑到启动效率的原因，可执行文件名需要和框架名同名。该可执行文件名不应该包含可用于多种平台的扩展名。</p><p><em>注意，您必须在束的Info.plist文件中包含一个有效的CFBundleExecutable关键字。即使当用户重命名应用程序或束的目录时，Mac OS X也可以使用这个关键字来定位可执行文件和共享库.</em></p><p><strong>UIDeviceFamily:</strong> 支持的设备</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5</title>
      <link href="/2016/07/21/MD5/"/>
      <url>/2016/07/21/MD5/</url>
      
        <content type="html"><![CDATA[<p>由NSString、NSData 生成的MD5字符串</p><pre><code class="objc">@interface NSString (MD5)-(NSString*)MD5;@end@interface NSData (MD5)-(NSString*)MD5;@end</code></pre><a id="more"></a><pre><code class="objc">#import &lt;CommonCrypto/CommonDigest.h&gt;@implementation NSString (MD5)-(NSString * )MD5{    if (!self.length) {        NSLog(@&quot;string not be nil&quot;);        return nil;    }    // Create pointer to the string as UTF8    const char * ptr = [self UTF8String];    // Create byte array of unsigned chars    unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH];    // Create 16 byte MD5 hash value, store in buffer    CC_MD5(ptr,(CC_LONG)strlen(ptr),md5Buffer);    // Convert MD5 value in the buffer to NSString of hex values    NSMutableString * output = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH*2];    for (int i = 0; i&lt;CC_MD5_DIGEST_LENGTH; i++) {        [output appendFormat:@&quot;%02x&quot;,md5Buffer[i]];    }    return output;}@end@implementation NSData (MD5)-(NSString * )MD5{    if (!self.length) {         NSLog(@&quot;data not be nil&quot;);        return nil;    }    // Create byte array of unsigned chars    unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH];     // Create 16 byte MD5 hash value, store in buffer    CC_MD5(self.bytes, (CC_LONG)self.length, md5Buffer);     // Convert unsigned char buffer to NSString of hex values    NSMutableString * output =[NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH*2];    for (int i = 0 ; i&lt;CC_MD5_DIGEST_LENGTH; i++) {        [output appendFormat:@&quot;%02x&quot;,md5Buffer[i] ];    }    return output;}@end</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MD5 </tag>
            
            <tag> NSString </tag>
            
            <tag> NSData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础之标识符</title>
      <link href="/2016/07/14/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
      <url>/2016/07/14/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>  标识符是计算机语言中允许用为名字的有效字符串集合。有一部分是关键字，构成语言的标识符。这样的标识符是保留字，不能用于其他用途，否则会引起语法错误。python中的“内建”标识符也不推荐使用。</p><h3 id="合法的标识符"><a href="#合法的标识符" class="headerlink" title="合法的标识符"></a>合法的标识符</h3><ul><li>第一个字符必须是字母或下划线</li><li>剩下的字符可以是字母和数字或下划线</li><li>大小写敏感</li><li>除了下划线，其他的符号都不允许使用。<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><img src="http://7xw3wp.com1.z0.glb.clouddn.com/pythonkeyword.jpg" alt="pythonkeyword.jpg"><h3 id="内建"><a href="#内建" class="headerlink" title="内建"></a>内建</h3>除关键字外，python还有可以在任一级代码使用的”内建（built-in）”的名字集合。这些名字由解释器设置或使用。python不支持重载标识符，所以任何时刻都只有一个名字绑定.<br>built-in是<strong>builtins</strong>模块的成员，在你的程序开始或义互解释器中给出&gt;&gt;&gt;提示前，由解释器自动导入。<h3 id="专用下划线标识符"><a href="#专用下划线标识符" class="headerlink" title="专用下划线标识符"></a>专用下划线标识符</h3>python中下划线作为变量前缀或后缀指定特殊变量<ul><li><code>_XXX</code> 不用<code>from moudle import*</code>导入</li><li><code>_XXX_</code> 系统定义的名字</li><li><code>_XXX</code>  类中的私有变量名</li></ul></li></ul><h2 id="模块结构与布局"><a href="#模块结构与布局" class="headerlink" title="模块结构与布局"></a>模块结构与布局</h2><p>  布局模式：</p><ul><li>起始行<ul><li>通常只有在类Unix环境下使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无需调用解释器</li></ul></li><li>模块文档<ul><li>简要介绍模块的功能及重要全局变量的定义，模块外可以通过<code>moudle.__doc__</code>访问这些内容</li></ul></li><li>模块导入<ul><li>导入当前模块的代码需要的模块；每个模块仅导入一次（当模块被加载时）；函数内部的模块导入代码不会执行，附非该函数正在执行</li></ul></li><li>变量定义<ul><li>这里主要定义全局变量，本模块中的所有函数都可以直接使用。如果不是必须，建议使用局部变量替代、</li></ul></li><li>类定义<ul><li>所有的类都在这里定义，当模块导入时class语句被执行，类也就被定义了。类的文档变量是<code>class.__doc__</code></li></ul></li><li>函数定义<ul><li>此处定义的函数可通过模块<code>module.function()</code>在外部访问，当模块被导入时def语句会被执行，函数也就都会定义好，函数的文档变量是<code>function.__doc__</code></li></ul></li><li>主程序<ul><li>无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码，通常在这里不会有太多功能性代码，是根据执行的模式调用不同的函数</li></ul></li></ul><p><code>__name__</code>系统变量：</p><ul><li>如果模块是导被导入，<code>__name__</code>的值为模块名</li><li>如果模块被直接执行,<code>__name__</code> 的值为<code>__main__</code><br><code>`</code>python<h1 id="coding-utf-8-起始行"><a href="#coding-utf-8-起始行" class="headerlink" title="coding=utf-8              # 起始行"></a>coding=utf-8              # 起始行</h1></li></ul><p>“this is a module document”  # 模块文档</p><p>import sys<br>import os  # 模块导入</p><p>debug = True  # 全局变量定义</p><p>class Test(object):  # 类定义<br>    “this is a test calss “  # 类文档</p><pre><code># passdef __init__(self):    print(&quot;fdasfd&quot;)def testFunction(self):  # 函数定义    &quot;this is a test function&quot;  # 函数文档    test = Test()    print(&#39;this test function&#39;)</code></pre><p>def test():  # 函数定义<br>    “test”<br>    print(“test”)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:  # 主程序<br>    test()<br>    print(<strong>name</strong>)</p><p><code>`</code></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>变量无须事先声明</li><li>变量无须指定类型</li><li>开发人员不用关心内存管理</li><li>变量名会被“回收”</li><li>del 语句能够直接释放资源</li></ul><h3 id="为什么变量无需事先声明，也无需类型声明"><a href="#为什么变量无需事先声明，也无需类型声明" class="headerlink" title="为什么变量无需事先声明，也无需类型声明"></a>为什么变量无需事先声明，也无需类型声明</h3><p>  在Python语言中，对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，python依然是一种解释型语言。在创建时，解释器会根据语法和右侧的操作数来决定新对象的类型。在对象创建后，该对象的引用会被赋值给左侧的变量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python基础之变量赋值</title>
      <link href="/2016/07/13/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/"/>
      <url>/2016/07/13/python%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>今天主要来学习下python的变量赋值方面的知识，及注意事项</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p>在python语言中，等号（＝）是主要的赋值运算符，其他的是增量赋值运算符。<br><strong><em>注意：赋值并不是直接将一个值赋给一个变量。在python语言中，对象是通过引用传递。在赋值时，不管这个对象是新创建的，还是已存在的变量，都是将该对象的引用（并不是值）赋值给变量。</em></strong></p><pre><code class="python">aint = 12astring = &#39;yuanph&#39;afloat= -3.141582653aotherString  = &#39;ping&#39;+&#39;hua&#39;alist =[3,1.4,&#39;ufasd&#39;,8.3-1.9]print(aint,astring,afloat,aotherString,alist)</code></pre><p>以下的赋值语句是非法的</p><pre><code class="python">&gt;&gt;&gt; x=1&gt;&gt;&gt; y= (x=x+1)  File &quot;&lt;stdin&gt;&quot;, line 1    y= (x=x+1)         ^SyntaxError: invalid syntax</code></pre><p>如果你较为熟悉Ｃ的话，赋值语句其实就是当成一个表达式（可以返回值）,上述赋值在Ｃ中是合法的</p><pre><code class="C">int x = 1;int y  = (x=x+1);printf(&quot;%d\t%d&quot;,x,y);//2    2</code></pre><p>如将上述的语句改成链接赋值，那是合法的</p><pre><code class="python">&gt;&gt;&gt; x=1&gt;&gt;&gt; y = x =x+1&gt;&gt;&gt; x,y(2, 2)</code></pre><h4 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值"></a>增量赋值</h4><p>从python2.0开始，等号可以和一个算述操作符组合在一起，将计算结果重新赋值给左边的变量，这被称为<font style="color:red;">增量赋值</font><br>增量赋值通过使用赋值运行算，将数学运算隐藏在赋值过程中，如果学过其他语言，对下面的增量运算符会比较熟悉：</p><table><thead><tr><th></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td><code>+=</code></td><td style="text-align:center"><code>-=</code></td><td style="text-align:center"><code>*=</code></td><td style="text-align:center"><code>/=</code></td></tr><tr><td><code>%=</code></td><td style="text-align:center"><code>**=</code></td><td style="text-align:center"><code>&lt;&lt;=</code></td><td style="text-align:center"><code>&gt;&gt;=</code></td></tr><tr><td><code>&amp;=</code></td><td style="text-align:center"><code>^=</code></td><td style="text-align:center">&#124;=</td></tr></tbody></table><p><em>增量赋值相对于普通和赋值不仅是写法改变，最有意义的变化是第一个对象仅被处理一次。可变对象会被就地修改（无需拷贝引用），不可变对象则和Ａ＝Ａ＋Ｂ的结果一样（分配一个新的对象）</em><br><strong><em>不支持<code>++</code>、<code>--</code>这样的前/后置的自增/减运算</em></strong></p><h4 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h4><pre><code class="python">&gt;&gt;&gt; x=y = z= b= 1&gt;&gt;&gt; x,y,z,b(1, 1, 1, 1)</code></pre><p> 上述代码说明：一个值为1的整形对象被创建，该对象的同一个引用被赋值给x,y,z,b.d 在python中可以将多个对象赋给多个变量，请下看下的多元赋值</p><h4 id="多元赋值"><a href="#多元赋值" class="headerlink" title="多元赋值"></a>多元赋值</h4><p>将多个变量同时赋值的方法＝＝＝&gt;多元赋值（非官方术语）<br>采用这种赋值时，等号两边的对象都是元组（一种基本数据类型）</p><pre><code class="python">&gt;&gt;&gt; x,y,z = 1,2,&#39;yph&#39;&gt;&gt;&gt; x,y,z(1, 2, &#39;yph&#39;)</code></pre><p>上述代码中，将两个整型变量和一个字符串对象，分别赋值给x,y,z.通常情况下元组需要用括号括起来，增加可读性（这是可选操作），但推荐使用。<br>我们来看下使用多元赋值来完成两个变量值的交换，先看c的实现</p><pre><code class="c">int x = 10;int y = 100;int temp = x;x = y;y = temp;</code></pre><p>一般情况下我们需要一个中间变量来完成我们的数据交换，接下来我们看下python是如何快速实现这两值的交换的</p><pre><code class="python">&gt;&gt;&gt; x,y= 10,100&gt;&gt;&gt; x,y(10, 100)&gt;&gt;&gt; x,y= y,x&gt;&gt;&gt; x,y(100, 10)</code></pre><p>非常的方便快捷，显然，python在赋值之前已经对x,y的新值做了计算。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python 赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础之语法与句法</title>
      <link href="/2016/07/12/python-%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/07/12/python-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>在本文中主要了解python的基本语法，介绍基本的编程风格，了解变量、关键字以及变量占用的内存分配和回收。<br><a id="more"></a></p><h2 id="语法与句法"><a href="#语法与句法" class="headerlink" title="语法与句法"></a>语法与句法</h2><h3 id="python语句中的一些基本规则和特殊字符："><a href="#python语句中的一些基本规则和特殊字符：" class="headerlink" title="python语句中的一些基本规则和特殊字符："></a>python语句中的一些基本规则和特殊字符：</h3><ul><li>井号（#）表示之后的字符为python注释</li><li>换行（’\n’)是标准的行分隔符</li><li>反斜线（’\’）继续上一行</li><li>分号（;）将两个语句连接接在一行中</li><li>冒号（:）将代码块的头和体分开</li><li>语句块（代码块）用缩进块的方式体现</li><li>不同的缩进深度分隔不同的代码块</li><li>python文件以模块的形式组织</li></ul><h3 id="注释-："><a href="#注释-：" class="headerlink" title="注释(#)："></a>注释(#)：</h3><p>  python的注释语句从(#)号开始，注释可以在一行的任何地方开始，解析器会忽略该行(#)号之后的所有内容。我们需要正确使用注释，来提高代码的可读性</p><h3 id="继续-‘-’"><a href="#继续-‘-’" class="headerlink" title="继续(‘\’) :"></a>继续(‘\’) :</h3><p>  一行过长的语句可以用(‘\’)分解成几行</p><pre><code class="python">  #check condition  if (weather_is_hot == 1 ) and \          (shark_waring==0):      send_goto_beach_mesg_to_pager()</code></pre><p>以下两种情况例外不使用\ 也可以换行</p><ul><li>使用闭合操作符，单一语句也可以跨多行：在含有小括号、中括号、花括号时可以多行书写</li><li>三个单引号包括下的字符串可以跨行<br><strong style="color:red;">使用括号换行的可读性强，推荐使用</strong></li></ul><h3 id="多个语句构成代码组（-）"><a href="#多个语句构成代码组（-）" class="headerlink" title="多个语句构成代码组（:）"></a>多个语句构成代码组（:）</h3><p>缩进相同的一组语句构成一个代码块。像<code>if</code>、<code>while</code>、<code>def</code>和<code>class</code>这样的复合语句，首行以关键字开始，以冒号（:）结束，该行之后的一行或多行代码构成代码组。</p><h3 id="代码组由不同的缩进进行分隔"><a href="#代码组由不同的缩进进行分隔" class="headerlink" title="代码组由不同的缩进进行分隔"></a>代码组由不同的缩进进行分隔</h3><p>python使用缩进来分隔代码组。代码层次关系通过同样深度的空格或制表符缩进体现。同一代码组的代码行必须严格<bold style="color:red">左对齐</bold>，如不遵守，同一代码组的代码可能被当成另一个代码组，甚至导致语法错误。</p><blockquote><p>因python使用空格缩进表达代码块逻辑，因此“神对的大括号战争”永不会发生在python身上。C、C++、java、OC开始使用大括号可以在第一行的尾部，也可以在第二行的头部，也可以在第二行空几格后开始，这就造成不同的人选择不同的风格。</p></blockquote><h3 id="同一行书写多个语句（-）"><a href="#同一行书写多个语句（-）" class="headerlink" title="同一行书写多个语句（;）"></a>同一行书写多个语句（;）</h3><p>  分号（;）允许将多个语句写在同一行上，语句之间用分号隔开，而这些语句也不能在这行开始新的代码块。</p><pre><code class="python">  import sys;x= &#39;food&#39;; sys.stdout.write(x+&#39;\n&#39;)</code></pre><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>  每一个python脚本文件都可以当成一个模块。模块以磁盘文件形式存在，当一个模块变得过大，并且驱动了太多功能，应该考虑折分成多个模块。模块里的代码可能是一段直接执行的脚本，也可以是一堆类似库函数的代码，从而可以被别的模块导入（import）调用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 对象</title>
      <link href="/2016/07/12/Python-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2016/07/12/Python-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="python-对象"><a href="#python-对象" class="headerlink" title="python 对象"></a>python 对象</h1><p>  python 使用对象模型来存储对象。构造任何类型的值都是一个对象。<br>  所有的Python对象都拥有三个特性：身份，类型和值</p><ul><li>身份： 每一个对象都有一个唯一的身份标识自己。任何对象的身份可以使用内建函数id()来得到。这个值可以被认为是该对象的内存地址</li><li>类型： 对象的类型决定了对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。你可以内建type()查看对象的类型。</li><li><p>值：对象表示的数据项</p><a id="more"></a><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p>某些对象有属性、值或相关联的执行代码。python用句点（.）标记法来访问属性。属性包括相应对象的名字。最常用的属性是函数和方法</p></li></ul><h1 id="标准类型"><a href="#标准类型" class="headerlink" title="标准类型"></a>标准类型</h1><ul><li>数字（分为几个子类型，其中二个是整形）</li><li>Interger 整型</li><li>Boolean 布尔类型</li><li>Long integer 长整型</li><li>Float point real number 浮点型</li><li>Complex number 复数型</li><li>String 字符串</li><li>List 列表</li><li>Tuple  元组</li><li>Dictionary 字典</li></ul><h1 id="其他类型对象"><a href="#其他类型对象" class="headerlink" title="其他类型对象"></a>其他类型对象</h1><ul><li>类型</li><li>Null 对象（None）</li><li>文件</li><li>可变/不可 集合</li><li>函数/方法</li><li>模块</li><li>类</li></ul><h2 id="类型对象和type类型对象"><a href="#类型对象和type类型对象" class="headerlink" title="类型对象和type类型对象"></a>类型对象和type类型对象</h2><p>  对象的一系列固有行为和特性都是事先定义好，从这个角度来说，类型正是保存这些信息的最佳位置。描述一种类型所需要的信息不可以用一个字符串来搞定，所以类型不能是一个简单的字符串，也不能和数据保存在一起，所以用将类型定义成一个对象是最好的选择。</p><pre><code class="python">&gt;&gt;&gt; type(2)&lt;type &#39;int&#39;&gt;&gt;&gt;&gt; type(int)&lt;type &#39;type&#39;&gt;&gt;&gt;&gt; type(type(1))&lt;type &#39;type&#39;&gt;</code></pre><p>通过调用type()函数，能够得到特定对象的类型信息。从上述代码中我们可以知道，所有类型对象的类型都是type，它是所有python类型的根和所有python标准类型的默认元类（metaclass）.</p><h2 id="None-－－python中的Null对象"><a href="#None-－－python中的Null对象" class="headerlink" title="None －－python中的Null对象"></a>None －－python中的Null对象</h2><p>  python有一个特殊的类型，被称为Null对象，它只有一个值（None）,它的值始终是False.</p><blockquote><p>所有标准对象均可用于布尔测试，同类型的对象之间可以比较大小，每个对象天生具有<code>True</code>值或<code>False</code>值，空对象，值为0的任何数字或者<code>Null</code>对象<code>None</code>的布尔值都是<code>False</code><br>下列对对象的布尔值是<code>False</code></p><ul><li>None</li><li>False(布尔类型)</li><li>所有的值为零的数</li><li>0(整型)</li><li>0.0 (浮点型)</li><li>0L (长整型)</li><li>0.0+0.0j (复数)</li><li><code>&#39;&#39;</code>空字符串</li><li>[] 空列表</li><li>{} 空字典</li><li>() 空元组<br>值不是上面列出来的任何值的对象的布尔值都是<code>True</code></li></ul></blockquote><h1 id="标准类型操作符"><a href="#标准类型操作符" class="headerlink" title="标准类型操作符"></a>标准类型操作符</h1><h2 id="对象值的比较"><a href="#对象值的比较" class="headerlink" title="对象值的比较"></a>对象值的比较</h2><p>  比较操作符用来判断同类型对象是否相等，所有的内建类型均支持比较运行算。<br>  注： 进行实际比较运算中因类型而异，数字类型根据数据大小和符号比较，字符串按照字符序列值进行比较。<br>  <img src="http://7xw3wp.com1.z0.glb.clouddn.com/07/19/logicoperator.jpg" alt="logicoperator"></p><h2 id="对象身份的比较"><a href="#对象身份的比较" class="headerlink" title="对象身份的比较"></a>对象身份的比较</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>沙盒外读取防火墙状态</title>
      <link href="/2016/07/12/%E6%B2%99%E7%9B%92%E5%A4%96%E8%AF%BB%E5%8F%96%E9%98%B2%E7%81%AB%E5%A2%99%E7%8A%B6%E6%80%81/"/>
      <url>/2016/07/12/%E6%B2%99%E7%9B%92%E5%A4%96%E8%AF%BB%E5%8F%96%E9%98%B2%E7%81%AB%E5%A2%99%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>读取沙盒外的防火墙状态信息 默认是读取该路径下的文件<code>Library/Preferences/com.apple.alf.plist</code>中的<code>globalstate</code>字段的值 ，<code>0</code>–&gt;<code>off</code>, <code>1</code>–&gt;<code>ON</code><br><strong><em>在沙盒内读取不了</em></strong></p><pre><code class="objc">NSDictionary* dictionary = [NSDictionary dictionaryWithContentsOfFile:@&quot;/Library/Preferences/com.apple.alf.plist&quot;];       int status = [[dictionary valueForKey:@&quot;globalstate&quot;] intValue];      if (status==0) {          NSLog(@&quot;close&quot;);      }else{           NSLog(@&quot;open&quot;);      }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对多个target使用不同的 Bundle Display Name</title>
      <link href="/2016/07/11/%E5%AF%B9%E5%A4%9A%E4%B8%AAtarget%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-Bundle-Display-Name/"/>
      <url>/2016/07/11/%E5%AF%B9%E5%A4%9A%E4%B8%AAtarget%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-Bundle-Display-Name/</url>
      
        <content type="html"><![CDATA[<p>在项目多语言包xx.lproj里引入一个叫InfoPlist.strings的文件，可以对同一个App在不同系统语方中显示不同的Display Name 如：</p><pre><code class="objc">InfoPlist.strings (English) - &quot;CFBundleDisplayName&quot; = &quot;English Name&quot;;InfoPlist.strings (Chinese) - &quot;CFBundleDisplayName&quot; = &quot;中文&quot;;</code></pre><p>在单个target中很容易做，多个target的时候需要做一点额外的处理，在项目目录下新建与target同名的文件夹（为了方便区分），然后将xx.lproj文件夹复制到各target 下面，目录结构会是这样的</p><pre><code class="objc">./Target1/          en.lproj/InfoPlist.strings          zh-Hans.lproj/InfoPlist.strings./Target2/          en.lproj/InfoPlist.strings          zh-Hans.lproj/InfoPlist.strings</code></pre><p>复制后保持项目目录下还有 xx.lproj 文件夹，里面保留 Localizable.strings，因为多语言化一般是通用的，没必要针对每一个 Target 做多语言。复制后的 Target1/xx.lproj 下只有 InfoPlist.strings。然后添加到 Xcode 项目里，打开 Xcode - Views - Utilities （Command+Option+0），在 Target Membership 下针对不同的 Target 把对应文件夹下的 InfoPlist.strings 对应连接起来。<br>另外有一点需要注意的是：不同target对应着不同的info.plist文件，在不同的target中的<code>Build Settings</code>—&gt;<code>Packaging</code>—&gt;<code>Info.plist File</code>中设置对应的文件路路径，（最好使用相对路径如<code>$(SRCROOT)/文件夹名/Info.plist</code>）。<br><img src="http://7xw3wp.com1.z0.glb.clouddn.com/infoplistRoote.png" alt="infoplistRoote"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>清理mac的一些方去</title>
      <link href="/2016/07/11/%E6%B8%85%E7%90%86mac%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E5%8E%BB/"/>
      <url>/2016/07/11/%E6%B8%85%E7%90%86mac%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="一．-禁用SafeSleep休眠模式（可逆转操作）"><a href="#一．-禁用SafeSleep休眠模式（可逆转操作）" class="headerlink" title="一． 禁用SafeSleep休眠模式（可逆转操作）"></a>一． 禁用SafeSleep休眠模式（可逆转操作）</h3><p>SafeSleep的大小基本等同于设备的实际内存大小，例如Macbook Air是4GB的内存，那么SafeSleep的大小也是4GB左右。<br>禁用SafeSleep的弊端：如果电脑断电了，（没电）将无法恢复到断电前的状态。<br>禁用SafeSleep后需要：确保在电池将没电前保存好需求存储的内容。<br>具体操作：<br>1.开启Terminal<br>2.禁用SafeSleep，输入：<br>sudo pmset -a hibernatemode 0<br>3.然后定位到/private/var/vm/删除已经存在的sleepimage文件，输入：<br>cd /private/var/vm/<br>4.删除该文件，输入：<br>sudo rm sleepimage<br>5.制作一个替身，阻止系统新建SafeSleep文件，输入：<br>touch sleepimage<br>chmod 000 /private/var/vm/sleepimage<br>6.如果想恢复SafeSleep服务，请输入：<br>sudo pmset -a hibernatemode 3<br>sudo rm /private/var/vm/sleepimage</p><h3 id="二．清理系统噪音文件（不可逆转操作）"><a href="#二．清理系统噪音文件（不可逆转操作）" class="headerlink" title="二．清理系统噪音文件（不可逆转操作）"></a>二．清理系统噪音文件（不可逆转操作）</h3><p>Mac OS X内置了很多噪音文件，如果日常并不使用文字转换语音这个功能，这些文件可以删除以获取更多的磁盘空间。<br>具体操作：<br>1.开启 Terminal<br>2.定位到文件位置，输入：<br>cd /System/Library/Speech/<br>3.执行删除命令，输入：<br>sudo rm -rf Voices/*</p><h3 id="三．删除所有系统日志"><a href="#三．删除所有系统日志" class="headerlink" title="三．删除所有系统日志"></a>三．删除所有系统日志</h3><p>系统日志是用来调试和校验系统故障的，其文件会随着使用时间增长而增加，通常，此部分文件对于一般用户而言没有太多意义，可以删除。<br>具体操作：<br>1.开启Terminal<br>2.输入删除命令：<br>sudo rm -rf /private/var/log/*<br>请注意：系统日志文件是会不断的产生的，所以如果想删除，请定期操作。</p><h3 id="四．删除QuickLook缓存文件"><a href="#四．删除QuickLook缓存文件" class="headerlink" title="四．删除QuickLook缓存文件"></a>四．删除QuickLook缓存文件</h3><p>Quicklook 这个内置预览功能非常的好用，但是随着使用的增多，对应的缓存文件也会不断的增多，所以定期清理，也可以让磁盘空间得到很好的释放。<br>具体操作：<br>1.开启Terminal<br>2.输入删除命令：<br>sudo rm -rf /private/var/folders/</p><h3 id="五．删除临时文件"><a href="#五．删除临时文件" class="headerlink" title="五．删除临时文件"></a>五．删除临时文件</h3><p>可以尝试在Finder下，按Command＋Option＋G，然后前往：/private/var/tmp/ 这个文件夹，这里面是用来存储临时文件的。<br>对于这个路径下的内容，其实，系统在重启的时候一般都会做清理，但是鉴于现在很多用户都不怎么关机，导致这个里面的内容越来越多，所以有时候，我们还是有必要手动清理一下的。<br>具体操作<br>1.开启Terminal<br>2.定位到对应路径，请输入：<br>cd /private/var/tmp/<br>3.清理，请输入：<br>rm -rf TM*</p><h3 id="六．清除缓存文件"><a href="#六．清除缓存文件" class="headerlink" title="六．清除缓存文件"></a>六．清除缓存文件</h3><p>具体操作：<br>1.开启Terminal<br>2.定位到对应路径（当前用户的路径），请输入：<br>cd ~/Library/Caches/<br>3.清理，请输入：<br>rm -rf ~/Library/Caches/*<br>其上只是部分可以清理的mac垃圾，这些操作需要花费一定的时间和精力，而且有一定的难度，最重要的是并不可能完全清理mac。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS9新关键字</title>
      <link href="/2016/07/07/iOS9%E6%96%B0%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2016/07/07/iOS9%E6%96%B0%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>在iOS9 中苹果推出了很多新的关键字，目的其实很明确，主要是提高开发人员的效率，有益于程序员之间的沟通与交流，在开发中代码更加规范。</p><h2 id="关键字：-nullable-与-nonull"><a href="#关键字：-nullable-与-nonull" class="headerlink" title="关键字： nullable 与 nonull"></a>关键字： nullable 与 nonull</h2><p>   nullable:表示可以为nil<br>   nonull: 表示不可以为nil<br>   这两关键字只能修改对象，不能修饰基本数据类型，可以用在属性、方法的参数、方法的返回值中使用，在默认情况下，不加nonull，setter和getter都是可以为空nil的<br>   在定义属性中可以像如下一样使用：</p><pre><code class="objc">&lt;!-- more --&gt;//这样定义属性会得到以下的警告// Pointer is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)@property(nonatomic,strong)NSArray * array;//以下属性值不能为空@property(nonatomic,strong,nonnull) NSArray * array1;@property(nonatomic,strong)NSArray * _Nonnull array2;@property(nonatomic,strong)NSArray * __nonnull array3;//以下属性值可以为空@property(nonatomic,nullable)NSArray * array4;@property(nonatomic,strong)NSArray * __nullable array5;@property(nonatomic,strong)NSArray * _Nullable array6;</code></pre><p>在方法中可以与如下示例一样使用：</p><pre><code class="objc">//以下方法中参数不能为空，如若为空，系统会有警告提示//nonnull ,_Nonnull,__nonnull 这三个关键字可以起到同样的效果，具体区别是什么呢？？？-(nonnull NSString * )testString:(nonnull NSString  * )string;-(NSString * _Nonnull)testString1:(NSString* _Nonnull)string;-(NSString * __nonnull)testString2:(NSString*__nonnull)string;//以下方法中参数，返回值可以为空//__nullable,nullable ,_Nullable 这三个关键字可以起到同样的效果，具体区别是什么？？？-(nullable NSString * )testString3:(nullable NSString  * )string;-(NSString * _Nullable)testString4:(NSString* _Nullable)string;-(NSString * __nullable)testString5:(NSString*__nullable)string;</code></pre><p>在以下两个宏之间定义的所有对象属性都默认为nonull</p><pre><code class="objc">NS_ASSUME_NONNULL_BEGINNS_ASSUME_NONNULL_END</code></pre><pre><code class="objc">@interface LocationDataController : NSObjectNS_ASSUME_NONNULL_BEGIN//在这之间的所有属性的是非空的@property (nonatomic, readonly) NSArray *locations;@property (nullable, nonatomic, readonly) NSObject *latestLocation;//方法里的参数默认也是非空的- (void)addPhoto:(NSObject *)photo forLocation:(NSObject *)location;- (nullable NSObject *)photoForLocation:(NSObject *)location;NS_ASSUME_NONNULL_END@end</code></pre><h2 id="关键字-null-resettable"><a href="#关键字-null-resettable" class="headerlink" title="关键字: null_resettable"></a>关键字: null_resettable</h2><p>getter :不可以为nil<br>setter :可以为nil<br>如果使用 null_resettable 就必须重写 getter或者setter方法. 目的是为了处理值为空的情况<br>使用方法如下</p><pre><code class="objc">//如果使用下null_resettable，没有实现setter方法或getter 方法会得到如下的警告// Synthesized setter &#39;setObjc:&#39; for null_resettable property &#39;objc&#39; does not handle nil@property(nonatomic,strong,null_resettable)NSObject * objc;</code></pre><h2 id="关键字-Null-unspecified"><a href="#关键字-Null-unspecified" class="headerlink" title="关键字: _Null_unspecified"></a>关键字: _Null_unspecified</h2><p>这个关键字作用感觉不是那么大，因为默认情况下，都是不确定</p><pre><code class="objc">  //在不确定对象中是否为空的情况下可以使用null_unspecified关键字  @property(nonatomic,null_unspecified)NSObject * objc1;  @property(nonatomic)NSObject* _Null_unspecified objec2;  @property(nonatomic)NSObject * __null_unspecified objec3;</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>通过使用泛型, 我们可以非常容易地获取其中的元素，并访问其特有的属性和方法, 一般使用在集合中使用(例如:数组,字典), 当方法调用的时候才有效果, 我们来看看如何使用:</p><pre><code class="objc">//如下定义属性与方法会得到下面的警告// Pointer is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)@property(nonatomic,strong)NSMutableArray&lt;NSString*&gt; * mutableArray;-(NSArray * )testArray:(NSArray * )array;-(NSArray&lt;NSString*&gt;*)testArray2:(NSArray&lt;NSString*&gt;*)array;//加上_Nonnull、_Nullable、_Null_unspecified这几个关键字中的一个，都不会出现以上警告-(NSArray&lt;NSString*&gt;* __nonnull)testArray3:(NSArray&lt;NSString*&gt;*__nonnull)array;-(__kindof NSArray&lt;NSString*&gt;* __nonnull)testArray4:(NSArray&lt;NSString*&gt;*__nonnull)array;</code></pre><h3 id="带泛型的容器"><a href="#带泛型的容器" class="headerlink" title="带泛型的容器"></a>带泛型的容器</h3><p>  有了泛型后可以指定容器类中对象的类型了</p><pre><code class="objc">  NSArray&lt;NSString *&gt; * strings= @[@&quot;sun&quot;,@&quot;moon&quot;];  //这什么这样定义的数组不会报提示呢，它们的类型不是不一样的吗？？  NSArray &lt;NSString * &gt;* string = @[@&quot;su&quot;,@&quot;fasd&quot;,@10,@{@10:@10}];  NSMutableArray &lt;NSString*&gt;* array = [NSMutableArray array];//如下加入一个NSNumber会得到以下提示// Incompatible pointer types sending &#39;NSNumber *&#39; to parameter of type &#39;NSString * _Nonnull&#39;  [array addObject:@(10)];  //为什么我在泛型中指定值的类型为NSString，在实际给值中没有给string而是NSNumber，却没有给出提示信息，这是为什么呢？？  NSDictionary&lt;NSNumber *,NSString*&gt; * dic =@{@100:@100};//    指定字典键值类型  NSMutableDictionary&lt;NSString *,NSString*&gt; * mDic =[NSMutableDictionary dictionary];//    为什么在可变字典里，设置不同类型的键值，会有如下提示？//    Incompatible pointer types sending &#39;NSNumber *&#39; to parameter of type &#39;NSString * _Nullable&#39;  [mDic setValue:@10 forKey:@&quot;age&quot;];  [mDic setObject:@10 forKey:@10];  [mDic setValue:@&quot;yuan&quot; forKey:@10];</code></pre><p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p><pre><code class="objc">@property (readonly) NSArray *imageURLs;@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;</code></pre><p>不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。</p><h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><p>比起系统的泛型容器，更好 玩的是自定义一个泛型类</p><pre><code class="objc">@interface Stack&lt;ObjectType&gt; : NSObject- (void)pushObject:(ObjectType)object;- (ObjectType)popObject;@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;@end</code></pre><p>  这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p><pre><code class="objc">  // 只接受 NSNumber * 的泛型  @interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject  // 只接受满足 NSCopying 协议的泛型  @interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject</code></pre><p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br><img src="imagesource/logo.jpg" alt="logo.jpg"></p><h2 id="关键字：-kindof"><a href="#关键字：-kindof" class="headerlink" title="关键字： __kindof"></a>关键字： __kindof</h2><p>表示当前类, 或者它的子类(<strong>kindof使用: 放在类型前面, 表示修饰此类型)</strong>kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：</p><pre><code class="objc">- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;</code></pre><p>使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：</p><pre><code class="objc">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;</code></pre><p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p><pre><code class="objc">@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;</code></pre><p>这样，写下面的代码时就没有任何警告了：</p><pre><code class="objc">UIButton *button = view.subviews.lastObject;</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keywords </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用正则表达式</title>
      <link href="/2016/06/29/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2016/06/29/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="电话号码匹配"><a href="#电话号码匹配" class="headerlink" title="电话号码匹配"></a>电话号码匹配</h1><blockquote><p>如，中国国际代号是0086,我们要让外国人直接和我们联系表述如下：008610-85912411，或者，(008610)85912411、(0086) 10-85912411、+8610-8591241、+86-10-85912411<br>阿联酋固定电话：+971 4 2241288，+971 是他的国际区号，4是他的国内当地区号<br>英国伦敦固定电话+44-7778-188 810，7778应该是伦敦区号<br>英国固定电话：+44 (0)208 908 5848，208应该是国内当地区号</p></blockquote><blockquote><p>法国；+353 87 9114696 ，+353是法国区号</p></blockquote><blockquote><p>名片上是这样写的 。<br>英国：+44 (0)793 0179-230、<br> +44 (0)793 017-9230 、<br>+44 (00)7 0179 230</p></blockquote><blockquote><p>埃及：(+20) 010 188 8486、<br>0592-6054790、<br>0592 6054790</p></blockquote><a id="more"></a><ol><li>国际区号：<pre><code class="js">(?:\(?[0\+]\d{2,3}\)?)[\s-]?</code></pre><pre><code class="objc">(0086)-、+353-、&quot;(+20) &quot;、0086- ，其中&quot;(+20) &quot;后面带了一个空格</code></pre></li><li>国内区号：<pre><code class="js">(?:(?:\(0{1,3}\))?[0\d]{1,4})[\s-]</code></pre><pre><code class="objc"> &quot;010 &quot;、010-、7778-、(0)793、(0)208、</code></pre></li><li>电话号码：<pre><code class="js">(?:[\d]{7,8}|[\d]{3,4}[\s-][\d]{3,4})</code></pre><pre><code class="objc">2241288、&quot;188 810&quot;、&quot;0179 230&quot;、0179-230 、017-9230</code></pre></li><li>国际区号+国内区号+电话号码<pre><code class="js">(?:\(?[0\+]\d{2,3}\)?)[\s-]?(?:(?:\(0{1,3}\))?[0\d]{1,4})[\s-](?:[\d]{7,8}|[\d]{3,4}[\s-][\d]{3,4})</code></pre>该正则表达式可以基本的电话号码</li></ol><h1 id="手机号码匹配"><a href="#手机号码匹配" class="headerlink" title="手机号码匹配"></a>手机号码匹配</h1><blockquote><p>中国手机：+86013799265585、+86 0 13799265585<br>  +86-0-13799265585、13799265585<br>美国手机1-626-2287211，1是美国区号<br>拨打美国这个号码应该是拨：001-626-2287211<br>美国手机1-626-2287211，完整的表达方式是：001-626-2287211，或者，+1-626-2287211  </p></blockquote><ol><li>国际区号 ：<pre><code class="js">(?:(?[0\+]?\d{1,3}\)?)[\s-]</code></pre><pre><code class="objc">001-、1-、+1-</code></pre></li><li>国内区号：<pre><code class="js">(?:0|\d{1,4})[\s-]?</code></pre><pre><code class="js">0、&quot;0 &quot;、&quot;0-&quot;、&quot;626-&quot;、</code></pre></li><li>手机号码<pre><code class="js">(?:\(?[0\+]?\d{1,3}\)?)[\s-]?(?:0|\d{1,4})[\s-]?(?:(?:13\d{9})|(?:\d{7,8}))</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/2016/06/21/Python%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/06/21/Python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>序列的基本操作：</p><ol><li>len():求序列的长度</li><li><ul><li>:连接两个序列</li></ul></li><li><ul><li>:重复序列元素</li></ul></li><li>in :判断元素是否在序列中</li><li>max(): 返回最大的值</li><li>min():返回最小的值</li><li>cmp(tuple1,tuple2):比较两个序列是否相同</li></ol><p>元组（）：<br>元组和列表十分类似，但元组和字符串一样是不可变的。<br>－－元组通过圆括号中用逗号分割的项目定义<br>－－元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候</p><p><strong><font color="red"> id() 用于查看存储空间</font></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python入门知识：globals(),locals()</title>
      <link href="/2016/06/19/python%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%EF%BC%9Aglobals-locals/"/>
      <url>/2016/06/19/python%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%EF%BC%9Aglobals-locals/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MultiPeerConnectivity</title>
      <link href="/2016/06/17/MultiPeerConnectivity/"/>
      <url>/2016/06/17/MultiPeerConnectivity/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>引入GCDWebServer后编译出现的问题及其解决办法</title>
      <link href="/2016/06/15/%E5%BC%95%E5%85%A5GCDWebServer%E5%90%8E%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2016/06/15/%E5%BC%95%E5%85%A5GCDWebServer%E5%90%8E%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code>Undefined symbols for architecture arm64:  &quot;_deflate&quot;, referenced from:      -[GCDWebServerGZipEncoder readData:] in GCDWebServerResponse.o  &quot;_inflate&quot;, referenced from:      -[GCDWebServerGZipDecoder writeData:error:] in GCDWebServerRequest.o  &quot;_deflateInit2_&quot;, referenced from:      -[GCDWebServerGZipEncoder open:] in GCDWebServerResponse.o  &quot;_inflateEnd&quot;, referenced from:      -[GCDWebServerGZipDecoder close:] in GCDWebServerRequest.o  &quot;_inflateInit2_&quot;, referenced from:      -[GCDWebServerGZipDecoder open:] in GCDWebServerRequest.o  &quot;_deflateEnd&quot;, referenced from:      -[GCDWebServerGZipDecoder open:] in GCDWebServerRequest.o      -[GCDWebServerGZipEncoder open:] in GCDWebServerResponse.o      -[GCDWebServerGZipEncoder close] in GCDWebServerResponse.o</code></pre><p>解决办法：</p><p>在工程中添加 libz.dylib</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Framework制作</title>
      <link href="/2016/06/02/Framework%E5%88%B6%E4%BD%9C/"/>
      <url>/2016/06/02/Framework%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>知识科谱：<br> <em>什么是库?</em><br> 库是程序代码的集合，是共享程序代码的一种方式。<br> 依源代码的公开情况不同，库可以分为2种：<br> <strong>开源库</strong><br>  公开源代码，能看到具体实现（如我们常用的第三方库）<br> <strong>闭源库</strong><br>  不公开源代码，是经过编译后的二进制文件，看不到具体的实现 ，主要分为:<br>  <em>静态库</em> 、<em>动态库</em></p><p>  <strong>动/静态库存在的形式</strong><br>  静态库： .a 和 .framework<br>  动态库： .dylib 和 .framework</p><a id="more"></a><p>  <strong>静态库和动态库在使用上的区别</strong><br>    静态库：链接时，静态库会被完整地复制到可执行文件中， 被多次使用就有多份冗余拷贝<br><img src="http://upload-images.jianshu.io/upload_images/1112684-e597bfd02e25d1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态库"><br>  动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存<br>    <img src="http://upload-images.jianshu.io/upload_images/1112684-575a9125c1100f1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态库"></p><p>  <strong>需要注意的是：项目中如果使用了自制的动态库，不能被上传到 AppStore！</strong></p><hr><h4 id="framework的制作"><a href="#framework的制作" class="headerlink" title=".framework的制作"></a>.framework的制作</h4><p><a href="http://www.jianshu.com/p/ef3d5b7e7006" target="_blank" rel="noopener">iOS-制作Framework（最新）</a></p><h4 id="a制作"><a href="#a制作" class="headerlink" title=".a制作"></a>.a制作</h4><p><a href="http://www.jianshu.com/p/a1dc024a8a15#" target="_blank" rel="noopener">手把手教你制作.a静态库（iOS开发）</a></p><h4 id="bundle的制作"><a href="#bundle的制作" class="headerlink" title=".bundle的制作"></a>.bundle的制作</h4><p><a href="http://www.jianshu.com/p/58c3a27b2649" target="_blank" rel="noopener">【Xcode小技巧】生成Bundle包</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设置行间距</title>
      <link href="/2016/05/19/%E8%AE%BE%E7%BD%AE%E8%A1%8C%E9%97%B4%E8%B7%9D/"/>
      <url>/2016/05/19/%E8%AE%BE%E7%BD%AE%E8%A1%8C%E9%97%B4%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<p>在iOS开发过程中对文本的处理，可以需要去调整字间距，行间距之类，在这里给大伙介绍一个工具类（NSMutableParagraphStyle），它可以帮我们实现这个需求：<br><a id="more"></a><br>NSMutableParagraphStyle是NSParagraphStyle的可变类，用它可以设置以下属性：</p><ul><li>lineSpacing(行间距)</li><li>paragraphSpacing（段间距）</li><li>alignment（文本对齐方式）（左、右、居中对齐）</li><li>firstLineHeadIndent（首行缩进）</li><li>headIndent （头缩进）</li><li>tailIndent（尾缩进）</li><li>lineBreakMode（换行模式）（WordWrapping、CharWrapping，Clipping，TruncatingHead，TruncatingTail，runcatingMiddle）</li><li>minimumLineHeight（最小行高）</li><li>maximumLineHeight（最大行高）</li><li>baseWritingDirection（文字书写方向）（Natural，LeftToRight，RightToLeft）</li><li>paragraphSpacingBefore（段前间距）</li><li>hyphenationFactor（不知道这个是什么，它的取值范围（0〜1.0））<br>要想实现下划线等属性，我们可以使用NSAttributedString及其可变子类进行设置：<br>常用的属性名：</li><li>NSFontAttributeName (字体属性)</li><li>NSParagraphStyleAttributeName（段落属性）</li><li>NSForegroundColorAttributeName（文字前景色）</li><li>NSBackgroundColorAttributeName （背景色）</li><li>NSStrikethroughStyleAttributeName（删除线属性）</li><li>NSStrikethroughColorAttributeName（删除线颜色）</li><li>NSUnderlineStyleAttributeName（下划线）</li><li>NSUnderlineColorAttributeName（下划线颜色）</li></ul><p>我们可以通过创建一个NSMutableParagraphStyle对象，设置我们想要的段落属性，然后将段落属性添加至属性文本中，</p><pre><code class="objc">-(NSAttributedString *)adjustlineSpace:(float)space {    NSMutableAttributedString * attribute  = [[NSMutableAttributedString alloc]initWithAttributedString:self];//创建一个可变属性文本对象    NSMutableParagraphStyle * paragraph =[[NSMutableParagraphStyle alloc]init];//创建一个段落对象    [paragraph setLineSpacing:space];//设置段落属性    [attribute addAttribute:NSParagraphStyleAttributeName value:paragraph range:NSMakeRange(0, self.length)];//为属性文本添加属性    return attribute;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 行间距，lineSpacing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC中的拷贝</title>
      <link href="/2016/05/19/OC%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D/"/>
      <url>/2016/05/19/OC%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内存的栈区 : 由编译器自动分配释放, 存放函数的参数值, 局部变量的值等. 其 操作方式类似于数据结构中的栈.</p></blockquote><blockquote><p>内存的堆区 : 一般由程序员分配释放, 若程序员不释放, 程序结束时可能由OS回 收. 注意它与数据结构中的堆是两回事, 分配方式倒是类似于链表.</p></blockquote><h1 id="用copy和multableCopy对外象"><a href="#用copy和multableCopy对外象" class="headerlink" title="用copy和multableCopy对外象"></a>用copy和multableCopy对外象</h1><p>  当我们要创建一个与源对象内容相同的对象时，可以考虑使用copy和multableCopy。</p><pre><code class="objc">      NSString * string = @&quot;yuanph&quot;;      NSString * copyString = [string copy];//拷贝出内容为yuanph的NSString类型的字符串      NSString * multiString = [string mutableCopy];//拷贝出内容为yuanph的NSMutableString类型的字符串      NSArray * array = @[@&quot;yuanph&quot;];      NSArray * copyArray = [array copy];//拷贝出内容与array相同的NSArray类型的数组      NSArray * multiArray  =[array mutableCopy];//拷贝出内容与array相同的NSMutableArray类型的数组      NSDictionary * dict = @{@&quot;name&quot;:@&quot;yuanph&quot;};      NSDictionary * copyDict = [dict copy];//拷贝出内容与dict相同的NSDictionary类型的字典      NSDictionary * multiDict = [dict mutableCopy];//拷贝出内容与dict相同的NSMutableDictionary类型的字典</code></pre><blockquote><p>1.copy拷贝出来的对象类型总是不可变类型(例如, NSString, NSDictionary, NSArray等等)<br> 2.mutableCopy拷贝出来的对象类型总是可变类型(例如, NSMutableString, NSMutableDictionary, NSMutableArray等等)</p></blockquote><h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p>深拷贝 : 拷贝出来的对象与源对象地址不一致! ＝＝＝&gt;修改拷贝对象的值对源对象的值没有任何影响.</p><p>浅拷贝 : 拷贝出来的对象与源对象地址一致!   =====&gt;修改拷贝对象的值会直接影响到源对象.</p><font color="ff0000">copy都是浅拷贝, mutableCopy都是深拷贝???????</font><p>用copy从一个可变对象拷贝出一个不可变对象 =====&gt;深拷贝</p><p> 不完全拷贝与完全拷贝</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> copy </tag>
            
            <tag> multableCopy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const与define</title>
      <link href="/2016/05/18/const%E4%B8%8Edefine/"/>
      <url>/2016/05/18/const%E4%B8%8Edefine/</url>
      
        <content type="html"><![CDATA[<h2 id="const和-define使用"><a href="#const和-define使用" class="headerlink" title="const和#define使用"></a>const和#define使用</h2><blockquote><p>1.什么是const?<br>2.什么是#define?<br>3.有什么用？<br>4.区别是什么？<br>5.应该怎么用？</p></blockquote><a id="more"></a><h1 id="什么是const"><a href="#什么是const" class="headerlink" title="什么是const?"></a>什么是const?</h1><pre><code>const 是c/c++中的一个关键字（修饰符），const一般用来定义一个常量。该常量的值不能修改。</code></pre><pre><code class="objc">      const int var  = 100;      int var1 = var;      int var2 = var;      var = 2000;//这样会报如下错误    //    Cannot assign to variable &#39;var&#39; with const-qualified type &#39;const int&#39;</code></pre><h1 id="什么是-define"><a href="#什么是-define" class="headerlink" title="什么是#define?"></a>什么是#define?</h1><p>  而define, 宏定义, 则是一条预编译指令, 编译器在编译阶段会将所有使用到宏的地方简单地进行替换</p><pre><code class="objc">  #define kconst 1000  int defvar1 = kconst;  int defvar2 = kconst;  /*   编译后生成以下代码：   int defvar1 = 1000;   int defvar2 = 1000;   */</code></pre><h1 id="有什么用？"><a href="#有什么用？" class="headerlink" title="有什么用？"></a>有什么用？</h1><ol><li>const和define都可以定义一个常量，都能实现只改值一次，就可以所有用上该常量的地方同步改值，一句代码也都不用改。</li><li>使代码更易维护</li><li>提高代码的效率</li></ol><h1 id="有什么区别？"><a href="#有什么区别？" class="headerlink" title="有什么区别？"></a>有什么区别？</h1><p>  相同点：</p><pre><code>* 都能定义常量</code></pre><p>  不同点:</p><pre><code>* const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数,  所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝??????????</code></pre><pre><code class="objc">            const int var  = 100;           #define kconst 1000           int var1 = var;//此时为var分配内存，以后不在分配           int var2 = var;//不再分配内存           int defvar1 = kconst;//编译时进行宏替换，分配内存           int defvar2 = kconst;//编译时进行宏替换，再分配内存</code></pre><ul><li>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量没有了存储与读内存的操作，使得它的效率比宏定义要高</li></ul><blockquote><p>既然宏定义能做的事const都能做, 那宏还有什么存在的必要么?<br>宏能做到const不能办到的事.<br>  1.宏能定义函数<br>  2.OC的单例模式用到宏<br>  3.宏还能根据传入的参数生成字符串</p></blockquote><h1 id="该怎么用？"><a href="#该怎么用？" class="headerlink" title="该怎么用？"></a>该怎么用？</h1><p>const有条原则，那就是他右边是什么，什么就不可变，如下：</p><pre><code class="objc">        int a = 2;        const int b = 100;//b 不可变        int  const c = 200;// c 不可变，const和数据类型 位置可换        int const *p1 =&amp;a;//*p1 不可变，p1 可变        int * const p2 = &amp;a;//p2 不可变， *p2 可变        const int * const p3 = &amp;a;//p3 不可变，*p3不可变</code></pre><p>const 不可变原则：<br>用const修饰的函数形参，则能提高代码的安全性，同时减少程序员之间的沟通成本</p><pre><code class="objc">int add(const int * x,const int * y){    //不能对x,y进行修改    return *x + *y;}</code></pre><p>宏多用于条件编译，如需要对于不同的情况下执行不同的代码块，则可以使用宏的条件编译来进行判断</p><blockquote><p>在Objective-C中, 随处可见const常量, 所以大家应该大胆地使用const, 它会带给你大大的益处. 同时, 只要某个数据是定义之后永远都不需要也不能修改的, 请使用const!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> const </tag>
            
            <tag> define </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建block姿势</title>
      <link href="/2016/05/17/%E5%88%9B%E5%BB%BAblock%E5%A7%BF%E5%8A%BF/"/>
      <url>/2016/05/17/%E5%88%9B%E5%BB%BAblock%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在OC中声明一个block"><a href="#如何在OC中声明一个block" class="headerlink" title="如何在OC中声明一个block?"></a>如何在OC中声明一个block?</h2><font color="#2E73D6"> 作为一个本地变量：</font><br><code>objcreturnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};</code><br><br><br><font color="#2E73D6"> 作为一个属性：</font><pre><code class="objc">@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</code></pre><a id="more"></a><font color="#2E73D6">作为一个方法参数：</font><pre><code class="objc">- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</code></pre><font color="#2E73D6">作为参数传递：</font><pre><code class="objc">[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];</code></pre><font color="#2E73D6">作为自定义类型：typedef</font><pre><code class="objc">typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) {...};</code></pre>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
            <tag> 代码块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hex2Int</title>
      <link href="/2016/05/17/Hex2Int/"/>
      <url>/2016/05/17/Hex2Int/</url>
      
        <content type="html"><![CDATA[<p><strong><em>十六进制字符串转成整数</em></strong></p><pre><code class="c">unsigned int HEX2int(NSString  * hexString){    unsigned int nReval = 0;    int nPower = 1;    size_t nStrlen = hexString.length;    while(nStrlen--)    {        unichar ch=[hexString characterAtIndex:nStrlen];        if(isdigit(ch) == 0)        {            ch = ch&amp;0x4f;            nReval += (ch - 55)* nPower;        }        else        {            nReval += (ch - &#39;0&#39;)* nPower;        }        nPower *= 16;    }    return nReval;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法使用小技巧</title>
      <link href="/2016/05/08/markdown%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2016/05/08/markdown%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<ol><li>首行缩进<br>&emsp;&emsp;写文章时，我们常希望能够首行缩进，这时可以加入<code>&amp;ensp;</code>来输入一个控格，加入<code>&amp;emsp;</code>来输入两个空格</li><li>限制图片大小并居中<br>&emsp;&emsp;许多 MarkDown 编辑器中直接按原图大小显示图片，造成版面凌乱。如何让图片像简书中那样大小一致居中显示呢？使用该命令<code>&lt;img src=&quot;图片地址&quot; width=&quot;图片显示宽度&quot; height=&quot;显示高度&quot; alt=&quot;图片名称&quot;/&gt;</code>设置图片大小，再用<code>&lt;div align=center&gt;&lt;/div&gt;</code>命令包裹达到居中效果。<br>3.将部份内容显示出来 在文中添加<code>&lt;!-- more --&gt;</code>就可以，实现部分内容的显示</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OC中常用的遍历方式</title>
      <link href="/2016/05/08/OC%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2016/05/08/OC%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在开发过程中经常需要列举collection中的元素，在ＯＣ语言中可以有多种方法实现该功能，标准的Ｃ语言循环，OC 1.0的枚举器（ＮSNumerator）,OC 2.0中的快速遍历。在引入块这一特性后，又新增了几种新的遍历方式，采用这几种新方式遍历collection时，可以传入块，而collection中的每个元素都可能会放在块里运行一遍，这样可以大幅度简化编码过程。<br><a id="more"></a></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>&emsp;&emsp;遍边数组的第一种方式就是采用老式的for循环。在作为OC的根基的Ｃ语言中就有了些特征。通常的代码样式：</p><pre><code class="objc">void traditionalForArray(NSArray * array){    for (int i = 0; i &lt; array.count; i++) {        id object = array[i];        //TODO::to do something with object    }}</code></pre><p>&emsp;&emsp;那么遍历字典跟set集合可以会更复杂些：<br>&emsp;&emsp;<em>直接遍历字典的所有值</em></p><pre><code class="objc">void traditionalForDictonary(NSDictionary * dict){    NSArray * allValues = [dict allValues];    for (int i = 0 ; i &lt; allValues.count; i++) {        id value = allValues[i];        //TODO::to do something with value    }}</code></pre><p>&emsp;&emsp;<em>直接遍历字典的所有键</em></p><pre><code class="objc">void traditionalForDictonary(NSDictionary * dict){    NSArray * allKeys = [dict allKeys];    for (int i = 0 ; i &lt; allKeys.count; i++) {        id key = allKeys[i];        id value = dict[key];        //TODO::to do something with  key and value    }}</code></pre><p>&emsp;&emsp;<em>遍历set中所有对象</em></p><pre><code class="objc">void traditionalForSet(NSSet * set){    NSArray * allObject = [set allObjects];    for (int i = 0 ; i &lt; allObject.count; i++) {        id object = allObject[i];        //TODO::to do something with object    }}</code></pre><p>&emsp;&emsp;根据定义，字典和set都是“无序的（unordered）”所以无法根据特定的下标来获取其中的值，为此，需要先获取字典里所有的键/值或set中所有的对象，在获取到的有序数组里就可以使用for循环获取对应下标的键/值或对象了.但创建这个附加的数组会有额外的开销，而且还会多创建一个数组对象，它会保留collection中的所有以元素对象，在释放数组时这些附加对象也会释放，这些操作看起来有点多余，因为其他方式都可以不用这么做。<br>&emsp;&emsp;for循环可以实现反向遍历，计数器的值从“元素的个数减一”开始，每次迭代时递减直至为0结束。执行反向遍历时，会比其他方式简单。</p><blockquote><p>总结优缺点：<br>优点：被广泛使用，容易接受，操作简单；<br>缺点：遍历字典和set是比较繁琐，会占用比较多的系统资源。</p></blockquote><h3 id="枚举器（NSEnumerator）"><a href="#枚举器（NSEnumerator）" class="headerlink" title="枚举器（NSEnumerator）"></a>枚举器（<code>NSEnumerator</code>）</h3><p>&emsp;&emsp;<code>NSEnumerator</code> 是个抽象基类，其只定义了两个方法，供其具体子类实现:   </p><pre><code class="objc">- (nullable ObjectType)nextObject;- ( NSArray&lt;ObjectType&gt; *)allObjects;</code></pre><p>&emsp;&emsp;<code>nextObject</code>方法是关键，它返回枚举里的下一个对象，每次调用都会更新内部结构，使得下次调用时能返回下一个对象。枚举里的全部对象返回后，再调用将会返回nil.这表示已经枚举完了。下面是各容器使用Enumerator的样式：<br><em>正向枚举数组</em></p><pre><code class="objc">void enumeratorForArray(NSArray * array ){    NSEnumerator * enumerator =[array objectEnumerator];    id object ;    while (( object =  [enumerator nextObject])!= nil) {         //TODO::to do something with object    }}</code></pre><p><em>逆向枚举数组</em></p><pre><code class="objc">void enumeratorForReverseArray(NSArray * array ){    NSEnumerator * enumerator =[array reverseObjectEnumerator];    id object ;    while (( object =  [enumerator nextObject])!= nil) {        //TODO::to do something with object    }}</code></pre><p><em>使用key枚举字典</em></p><pre><code class="objc">void enumeratorForDictionaryAllKeys(NSDictionary * dict){    NSEnumerator * keyEnumerator = [dict keyEnumerator];    id key ;    while ((key = [keyEnumerator nextObject])!=nil) {        id value = dict[key];        //TODO::to do something with value    }}</code></pre><p><em>使用value 枚举字典</em></p><pre><code class="objc">void enumeratorForDictionaryAllValues(NSDictionary * dict){    NSEnumerator * valueEnumerator = [dict objectEnumerator];    id value ;    while ((value = [valueEnumerator nextObject])!=nil) {        //TODO::to do something with value    }}</code></pre><p><em>枚举set集合</em></p><pre><code class="objc">void enumeratorForSet(NSSet * set){    NSEnumerator * objectEnumerator = [set objectEnumerator];    id object;    while ((object = [objectEnumerator nextObject])!= nil) {        //TODO::to do something with object    }}</code></pre><p>枚举的写法跟标准的for循环相似，但代码多了一点，其优势在于：不论遍历哪种collection，都可以采用这种相似的语法。</p><blockquote><p>总结优缺点：<br>优点：代码更易读，不需要定义额外的数组；<br>缺点：</p><pre><code>1. 无法直接获取遍历操作的下标，需要另外声明变量记录；2. 需要自行创建NSEnumerator对象，稍显麻烦。</code></pre></blockquote><h3 id="快速遍历-forin"><a href="#快速遍历-forin" class="headerlink" title="快速遍历 (forin)"></a>快速遍历 (forin)</h3><p>字典</p><pre><code class="objc">void forinDic(NSDictionary * dict){    for (id key in dict) {        id value = dict[key];         //TODO::to do something with key &amp;&amp; value    }}</code></pre><p>数组</p><pre><code class="objc">void forinArray(NSArray * array){    for (id object in array) {       //TODO::to do something with object    }}</code></pre><p>SET集合</p><pre><code class="objc">void forinSet(NSSet * set){    for (id object in set) {         //TODO::to do something with object    }}</code></pre><blockquote><p>forin小结：<br>优点：<br>  语法简洁，使用方便，效率高；<br>缺点：</p><pre><code>1. 无法方便获取当前遍历的下标；2. 无法在遍历过程中修改被遍历的collection，否则会导致崩溃。</code></pre></blockquote><h3 id="块方法（block）"><a href="#块方法（block）" class="headerlink" title="块方法（block）"></a>块方法（block）</h3><p>数组</p><pre><code class="objc">void blockEnumeratorArray(NSArray * array){#pragma mark － 对数组整个区间进行遍历    [array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        //TODO::to do something with object  &amp; index  &amp; stop        //TODO::可以增删除改？？    }];//    typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) {//        NSEnumerationConcurrent = (1UL &lt;&lt; 0),并发//        NSEnumerationReverse = (1UL &lt;&lt; 1),逆序//    };#pragma mark - 对数组进行遍历，可设置遍历顺序，并发或反序    [array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        //TODO::to do something with object  &amp; index  &amp; stop    }];#pragma mark － 对数组的某个区间进行遍历操作    NSIndexSet * indexset  =[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, array.count)];    [array enumerateObjectsAtIndexes:indexset options:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        //TODO::to do something with object  &amp; index  &amp; stop    }];}</code></pre><p>字典</p><pre><code class="objc">void blockEnumeratorDict(NSDictionary *dict){    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {        //TODO::to do something with object  &amp; key  &amp; stop    }];#pragma mark  设置遍历顺序方式（正序或逆序)    [dict enumerateKeysAndObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {        //TODO::to do something with object  &amp; key  &amp; stop    }];}</code></pre><p>SET集合</p><pre><code class="objc">void blockEnumeratorSet(NSSet * set){    [set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {         //TODO::to do something with object    &amp; stop    }];    #pragma mark  设置遍历顺序方式（正序或逆序)    [set enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) {         //TODO::to do something with object    &amp; stop    }];}</code></pre><p><strong>若提前知道遍历的集合含有何种对象，则应修改块签名，指出对象的具体类型。</strong></p><blockquote><p>小结：<br>优点：</p><ol><li>可以完美实现for循环的所有功能；</li><li>可以方便获取集合中的每一项元素；</li><li>提供了循环遍历的参数，NSEnumerationReverse用来实现倒序循环。NSEnumerationConcurrent用来实现并发遍历，两个参数可以同时使用；</li><li>这种循环方式效率高，能够提升程序性能，开发者可以专注于业务逻辑，而不必担心内存和线程的问题；</li><li>当开启NSEnumerationConcurrent选项时，可以实现for循环和快速遍历无法轻易实现的并发循环功能，系统底层会通过GCD处理并发事宜，这样可以充分利用系统和硬件资源，达到最优的遍历效果；</li><li>可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。</li></ol></blockquote><blockquote><p>缺点：</p><ol><li>很多开发者不知道这种遍历方式；</li><li>这里使用了block，需要注意在block里容易引起的保留环问题，比如使用self调用方法时，把self转化成若引用即可打破保留环。如：<strong>weak </strong>typeof(self)weakSelf = self 或者 __weak MyController *weakSelf = self; 在block里使用weakSelf即可。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作随笔</title>
      <link href="/2016/05/06/%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/"/>
      <url>/2016/05/06/%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><strong>将对象指针存入属性文件</strong><br>因项目需要上一补丁，需求如下：<br>在SDWebImageDownloaderOperation类中的connectionDidFinishLoading函数里发现一些崩溃的迹象，其中一些迹象表明可能是下载的网络图片达大，而导至生成image对象时崩溃，现想要知到是哪里链接下的图片导致这些问题。初步的解决方案为在方法开头将url保存至userdefault中，并在函数尾部将这个url移除。再下次再次调用这个函数时，先检查是否有存在的url,有则说明发生了崩溃，因此将这个url上传上来。这里隐藏着一些问题，如这个涵数可能在多个线程里调用，如果用这个对象的url绑定一个userdefault中的一个key，那么这值会不断被覆盖，没有起到任何作用，因此我们需要做个map来存储NSURLConnection对象及相应的url,那么问题题来了，谁来做map的key值，用NSURLConnection对象指针来做吧，我们最先想到的是用指针对象NSNumber,最初代码会像下面一样：<br><a id="more"></a></p><pre><code class="objc"> NSUserDefaults * defaults =[NSUserDefaults standardUserDefaults]; NSMutableDictionary * dict = [NSMutableDictionary dictionary]; [dict setObject:[NSNumber valueWithPointer:(__bridge const void * _Nullable)(aConnection)] forKey:aConnection.currentRequest.URL.absoluteString]; [defaults setObject:dict forKey:@&quot;URL&quot;]; [defaults synchronize];</code></pre><p>代码看起来行完美，运行来看下结果吧</p><pre><code class="objc">Attempt to set a non-property-list object {    &quot;http://i7.ushareit.com/feed/xgeitCrB.png&quot; = &quot;&lt;10f3541a&gt;&quot;;} as an NSUserDefaults/CFPreferences value for key URL</code></pre><p>我们得到了如上的一个提示，并且界面处理卡住状态。这个提示已经很明了了， 它说这是一个非序列化对象，不能存入userdefault中，从中我们可以得到另外的一些信息，用NSNumber去装一个非序列化的指针对象，得到的还是一个非序列化的NSValue对象，我们知道在序列化中，只能对字典或数组中特定的序列化对象进行序列化，其他非序列化对象不能完成这操作。那这样不能实现需要，那就将其地址转成字符串，并做为key,这应该可以吧。</p><pre><code class="objc">NSUserDefaults * defaults =[NSUserDefaults standardUserDefaults];   NSMutableDictionary *dict = [NSMutableDictionary dictionary];   [dict setObject:[NSString stringWithFormat:@&quot;%p&quot;,aConnection] forKey:aConnection.currentRequest.URL.absoluteString];   [defaults setObject:dict forKey:@&quot;URL&quot;];   [defaults synchronize];</code></pre><p>字典里的值是这样的</p><pre><code class="objc">{    &quot;http://i7.ushareit.com/feed/xgeitCrB.png&quot; = 0x1a98db60;}</code></pre><p>运行结果很完美，实现了我们的需求，但是，我们要写的是补丁啊，NSString 在jspatch中不能使用stringWithFormat方法，对NSURLConnection这个类扫了一遍发现有使用它的description可以满足我们的需要。</p><pre><code class="objc">   NSUserDefaults * defaults =[NSUserDefaults standardUserDefaults];   NSMutableDictionary *dict = [NSMutableDictionary dictionary];   [dict setObject:[aConnection description] forKey:aConnection.currentRequest.URL.absoluteString];   [defaults setObject:dict forKey:@&quot;URL&quot;];   [defaults synchronize];</code></pre><p>这就是我们最终需要的代码，只要把这些翻译成js代码就大功告成了！<br><strong>ps:非序列化对象装在各容器集合中也不能写入文件和userdefault中</strong></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode技巧充电篇</title>
      <link href="/2016/04/25/Xcode%E6%8A%80%E5%B7%A7/"/>
      <url>/2016/04/25/Xcode%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Xcode技巧充电篇<br>作为工程师，我们最重要的事情就是熟悉我们每天使用的日常工具，但不能仅限于此。只要有可能，我们应该试着掌握和定制能使我们更快、更轻松地实现最终目标的工具。下面是一些小提示和技巧，都是我在 Xcode 上面进行编程时用到的。希望他们对你有用。</p><ol><li>Ctrl + 数字键<br>Xcode 能通过组合 ⌃+[1/2/4/5/6] 键，快速地从项目文件夹一直导航到函数。使用快捷键显示出面版后同样可以使用搜索功能。</li></ol><ol start="2"><li>断点叮当<br>断点是令人惊叹的。我们也可以补充一些相关知识。你知道吗？你可以在每次执行指令指针命中时执行一些令人惊叹的 llvm 命令并响起/叮当声。当你想知道一个函数被调用而无需不断地继续执行程序时，你可以结合自动继续执行功能/的使用。</li></ol><p>看看所有这些选项 ！</p><ol start="3"><li>模糊搜索<br>是否忘了你在寻找的东西在哪里？Xcode 允许你通过快捷键 ⌘⇧O 在整个项目内进行模糊搜索。整个功能的关键是模糊搜索；如果有多个搜索结果，你可以持续键入直到你期望的结果出现为止。</li></ol><p>非常多的选项</p><p>这样好多了</p><ol start="4"><li>域内编辑<br>在任意地方，把光标放在实例变量、函数名上并使用快捷键/⌘⌃E。请留意，每个词的实体如何被突出显示的？一旦修改它，Xcode 就会修改它所在类的各个地方。当你需要重命名实例变量或函数名时，请使用它。 编码时咖啡洒了这事没那么惨，这个也同样适用于在函数内定义的本地变量。从此在变量函数命名前再也无需三思而后行。</li></ol><ol start="5"><li>选中驼峰命名<br>下面的同之前提到的配合使用非常好；Xcode 可以通过 ⌃ 键选中驼峰命名。当你通过上档键和方向键搭配使用来突出显示驼峰命名的变量的特定部分时，这变得非常有用。请注意，该选中按键会和 OSX 的一个在空格间直接跳跃的按键发生冲突，为确保该功能准确执行，你可以通过在系统偏好配置中禁止该动作。</li></ol><ol start="6"><li><p>在编辑器和导航器之间跳转<br>你想要跳到导航内你正在编辑的文件吗？使用 ⌘⇧J 。这是它所有的光芒。因为它太慢了，所以想要不通过触摸板跳回右侧的编辑器内，使用 ⌘J。小彩蛋：你可以使用 ⌘⌥J 在文件导航器内搜索一个指定文件。</p></li><li><p>变量断点<br>在实例变量声明行添加一个断点，每次该变量修改时 Xcode 就会在该点停止。</p></li></ol><ol start="8"><li><p>快速跳转到定义<br>你是否曾经使用 ⌘ 点击 Apple Framework 函数或属性，以了解更多详情？将输入光标/放在文本上的任何地方并使用快捷键⌘⌃J。这同样适应于你自定义的函数和变量。</p></li><li><p>比较上次提交差异<br>当可以使用 ⌘⌃⌥⏎ 在 Xcode 内看到舒适的自定义主题差异时，没有人需要第三方 git 差异工具。</p></li></ol><p>你可以在 Xcode 内使用 ⌘⌃⌥⏎ 很舒适地在自定义主题中查看提交差异，这还需要第三方 git diff 工具？</p><ol start="10"><li>快速切换断点<br>在你当前标记行通过快捷键 ⌘: 切换断点，并使用 ⌘Y 在项目中/切换断点的激活状态。</li></ol><p>这些快捷键已经成为我日常工作的一部分，并加快了我编写和重构代码的速度。如果在某些情况下，某些快捷键和之前设置的快捷键发生了冲突，你就知道它们都是可以定制的。只需要键入 ⌘, 并导航到 “Key Bindings”。让编程更快吧！  </p><p><a href="http://www.phperz.com/article/16/0411/213454.html" target="_blank" rel="noopener">Xcode技巧充电篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 配置文件 </tag>
            
            <tag> Xcode技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScrollViewDelegate学习</title>
      <link href="/2016/04/19/scrollviewdelegate%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/04/19/scrollviewdelegate%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>用户拖动界面时所触发的代理方法调用有如下：</strong></p><ol><li>当用户将手指放在界面中并开始拖动一定距离时会调用<code>scrollViewWillBeginDragging：</code></li><li>随之会触发<code>scrollViewDidScroll</code>方法的调用</li><li>当用户手指离开界面时会触发<code>scrollViewWillEndDragging:withVelocity:targetContentOffset:</code>的调用，在这个代理方法的实现中我们可以去修改的目标的<code>contentOffset</code></li><li>随之系统会调用结束拖动方法<code>scrollViewDidEndDragging:willDecelerate:</code>的调用，其第二个参数用来说明是否需要做减速，这个值的主要来源于上个方法中的<code>Velocity</code>，如果这个值不为CGPointZero，那第二个参数的值为YES;如果为（0，0）则方法调用到此结束。</li><li>如果将要减速为YES,则系统会继续调用<code>scrollViewWillBeginDecelerating:</code>方法，并开始减速滑动同时调用<code>scrollViewDidScroll:</code>方法</li><li>当速度为0时会调用<code>scrollViewDidEndDecelerating:</code>方法结束减速滑动操作</li></ol><p><strong>设置内容偏移量或显示某个区域时所触发的方法调用</strong></p><ul><li>设置内容偏移量<code>setContentOffset:animated:</code></li><li>滑动至某一区域<code>scrollRectToVisible:animated:</code></li><li>当上述方法中的<code>animated</code>为yes时，会调用<code>scrollViewDidScroll:</code>和<code>scrollViewDidEndScrollingAnimation:</code>方法,如果animated的值为<code>NO</code>,只会调用<code>scrollViewDidScroll:</code>方法，</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> ScrollViewDelegate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AVAudioPlayer学习</title>
      <link href="/2016/04/17/avaudioplayer%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/04/17/avaudioplayer%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="AVAudioPlayer-使用方式"><a href="#AVAudioPlayer-使用方式" class="headerlink" title="AVAudioPlayer 使用方式"></a>AVAudioPlayer 使用方式</h2><blockquote><p>音频播放是很多应用程序的常见需求，AVFoundation让这一功能变得非常简单，这一点得归功于AVAudioPlayer这个类。这个类的实例提供了一种简单地从广西或内存中播放音频的方法。虽接口简单，但功能强大 并且在mac和iOS系统中经常被作为实现音频播放的最佳选择<br> AVAudioPlayer 构建于CoreAudio中的C-based Audio Queue Services的最顶层，所以它可以提供你在AVAudio Queue Services 中所能找到的核心功能，比如播放、循环甚至音频计量，但其也有不足之处如：需要从网络流中播入音频、需要访问原始音频样本或者更低的延时时它不能胜任些重任。</p></blockquote><a id="more"></a><p><strong>创建实例对象的方式方法</strong>  </p><ol><li>使用包含要播放音频的内存版本的NSData <code>initWithData:error:</code>  </li><li>使用本地音频文件的NSURL<code>initWithContentsOfURL:error:</code><br><strong><em>在用上述方法返回一个有效实例时，建议调用<code>prepareToPlay</code>方法。如此一来会取得需要的音频硬件并预加载<code>Audio Queue</code>的缓冲区</em></strong></li></ol><p><strong>对播放实例的控制操作</strong>  </p><ol><li>基础功能：<code>play</code> 、<code>pause</code>、<code>stop</code>  </li><li>修改实例的音量：<code>volume</code> 范围值0.0~1.0之间的浮点值  </li><li>修改实例的<code>pan</code>值，允许使用立体声：<code>pan</code>值 范围：-1.0~1.0之间的浮点值  </li><li>调整播放速率：<code>rate</code> 范围值：0.5(半速)~2.0(2倍速)  </li><li>设置循环次数属性实现无缝循环：<code>numberOfLoops</code>设置一个大于0的数n，可以循环n次，相反若设成-1，会无限次循环  </li><li>进行音频计量</li></ol><p><strong>配置音频会话</strong>  </p><ol><li>播放音频时切换设备侧面的“铃音/静音”按钮，可以音频在这两种状态下输出  </li><li>播放音频时按下<code>LOCK</code>锁，进入后台，音频可以正常输出    </li></ol><p><strong>要实现上面两个需要，我们需要做如下工作:</strong>  </p><ul><li>在<code>didFinishLaunchingWithOptions</code>方法里配置AVAudioSession,<br> 正确设置音频会话分类为<code>AVAudioSessionCategoryPlayback</code> 并启动会话</li></ul><pre><code class="objc">AVAudioSession * session  = [AVAudioSession sharedInstance];    NSError * error;    if (![session setCategory:AVAudioSessionCategoryPlayback error:&amp; error]) {        NSLog(@&quot;%@&quot;,error.localizedDescription);    }    if (![session setActive:YES error:&amp;error]) {        NSLog(@&quot;%@&quot;,error.localizedDescription);    }</code></pre><ul><li>在<code>info.plist</code>文件中添加键值，该值表示应用程序允许在后台播放音频内容</li></ul><pre><code class="objc">&lt;key&gt;UIBackgroundModes&lt;/key&gt;    &lt;array&gt;        &lt;string&gt;audio&lt;/string&gt;    &lt;/array&gt;</code></pre><p><strong>音频会话中断通知处理</strong></p><blockquote><p>测试你的应用程序是否做了会话中断处理：  </p><ol><li>在真机上运行你的应用并播放音频  </li><li>当音频处于播放状态，从另一台设备上向当前设备发起电话或FaceTime以造成音频会话中断  </li><li>中断电话发起或FaceTime<br>当中断时，播放的音频会慢慢消失和暂停，这一效果系统自动实现，当中断恢复后，查看我的的应用音频是否还会自动继续播放呢<br>如果没有，我们需要注册<code>AVAudioSessionInterruptionNotification</code>通知，并处理该通知  </li></ol></blockquote><p>注册监听</p><pre><code class="objc">//        监听中断通知        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleInterruption: ) name:AVAudioSessionInterruptionNotification object:[AVAudioSession sharedInstance]];</code></pre><p>处理中断通知：</p><pre><code class="objc">-(void)handleInterruption:(NSNotification*)notification{//    首先通过检索AVAudioSessionInterruptionTypeKey来确定中类型（AVAudioSessionInterruptionType）,该类型用于表中断的开始或是结束    NSDictionary * userinfo  = notification.userInfo;    AVAudioSessionInterruptionType type = [userinfo[AVAudioSessionInterruptionTypeKey] unsignedIntegerValue];    if (type== AVAudioSessionInterruptionTypeBegan) {    //中断音频播放    }else {        AVAudioSessionInterruptionOptions options =[userinfo[AVAudioSessionInterruptionOptionKey] unsignedIntegerValue];        if (options == AVAudioSessionInterruptionOptionShouldResume) {      //在这里继续播放音频           }    }}</code></pre><p><em>线路改变通知处理</em></p><blockquote><p>如何确保应用程序对线路变换做出正确的响应。在iOS设备上添加或移除音频输入或输出线路时，会发现线路改变。有多重因会导致线路变化，如用户插入耳机或断开ＵＳＢ麦克风，这些事件的发生时，音频会根据情况改变输入输出线路，同时会广播一个描述该变化的通知给所有相关的监听器。<br>我们做这么一个小测试：运行你的应用，并播放音频，在播放期间插入耳机，音频输出线路变为耳机插孔并继续正常播放，这是我们希望的效果。断开耳机连接。音频线路再次回到设备的内置扬声器，我们再次听到了声音。虽然这和我们预期的效果一样，不过按苹果公司的相关文档，该音频应处理静音状态。当用插入耳机时隐含的意思是用户不希望外界听到具体的音频内容，这就意味着用户断开耳机，播放的内容需要继续保密，所有我们需要停止音频播放。    </p></blockquote><p>监听线路改变通知</p><pre><code class="objc">    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(handleRouteChange:) name:AVAudioSessionRouteChangeNotification object:[AVAudioSession sharedInstance]];</code></pre><p>处理通知：</p><pre><code class="objc">-(void)handleRouteChange:(NSNotification*)notification{//    通过AVAudioSessionRouteChangeReasonKey来确认发现改变的原因//    我们在这里需要注意的是耳机中断事件    NSDictionary * userinfo =notification.userInfo;    AVAudioSessionRouteChangeReason reason = [userinfo[AVAudioSessionRouteChangeReasonKey] unsignedIntegerValue];    if (reason ==AVAudioSessionRouteChangeReasonOldDeviceUnavailable) {//        知道有设备断开连接后，需要向userinfo字典提出请求，获取其中用于描述前一线路的AVAudioSessionRouteDescription。线路的描述信息整合在一个输入NSArray和一个输出NSArray中，数组中的实例都是AVAudioSessionPortDescription,用于描术不同的I/O接口属性。        AVAudioSessionRouteDescription * previousRoute  = userinfo[AVAudioSessionRouteChangePreviousRouteKey];        AVAudioSessionPortDescription * previousPort  = previousRoute.outputs[0];        NSString * type =  previousPort.portType;        if ([type isEqualToString:AVAudioSessionPortHeadphones]) {      //   如果需要日更新界面，需要使用主线去更新，当前线程可以是后台线程                dispatch_async(dispatch_get_main_queue(), ^{                });            }        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> AVAudioPlayer </tag>
            
            <tag> AVAudioSession </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CoreWlan框架学习解析</title>
      <link href="/2016/04/13/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/04/13/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="CoreWlan-框架解析"><a href="#CoreWlan-框架解析" class="headerlink" title="CoreWlan 框架解析"></a>CoreWlan 框架解析</h1><h2 id="CoreWlan框基础类"><a href="#CoreWlan框基础类" class="headerlink" title="CoreWlan框基础类"></a>CoreWlan框基础类</h2><ul><li><code>CWWiFiClient</code></li><li><code>CWInterface</code></li><li><code>CWNetwork</code></li><li><code>CWNetworkProfile</code>与<code>CWMutableNetworkProfile</code></li><li><code>CWConfiguration</code>与<code>CWMutableConfiguration</code></li><li><code>CWChannel</code></li><li><code>CoreWlanUtil</code></li><li><code>CoreWLANTypes</code><br>主要由以上类组成，接下来我们一一来看下这些类给我们提供了什么功能接口，以及具有哪些属性:<br><strong>首先来看来有哪些类型的枚举</strong><ul><li>[<a href="https://zh.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">IEEE 802.11 (无线局域网通用)的标准</a><ul><li><pre><code class="objc">typedef NS_ENUM(NSInteger, CWPHYMode){kCWPHYModeNone        = 0,kCWPHYMode11a        = 1,kCWPHYMode11b        = 2,kCWPHYMode11g        = 3,kCWPHYMode11n        = 4,kCWPHYMode11ac  = 5,} NS_ENUM_AVAILABLE_MAC(10_7);  </code></pre></li></ul></li></ul></li></ul><h2 id="CoreWlan使用方式"><a href="#CoreWlan使用方式" class="headerlink" title="CoreWlan使用方式"></a>CoreWlan使用方式</h2>]]></content>
      
      
      
        <tags>
            
            <tag> CoreWlan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
